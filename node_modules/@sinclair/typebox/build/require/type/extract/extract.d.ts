import type { TSchema, SchemaOptions } from '../schema/index';
import type { Assert, AssertRest, AssertType, UnionToTuple } from '../helpers/index';
import type { TMappedResult } from '../mapped/index';
import { type TTemplateLiteral } from '../template-literal/index';
import { type TLiteral } from '../literal/index';
import { type TUnion } from '../union/index';
import { type Static } from '../static/index';
import { type TUnionEvaluated } from '../union/index';
import { type TExtractFromMappedResult } from './extract-from-mapped-result';
type TFromTemplateLiteralResult<T extends string> = TUnionEvaluated<AssertRest<UnionToTuple<{
    [K in T]: TLiteral<K>;
}[T]>>>;
type TFromTemplateLiteral<T extends TTemplateLiteral, U extends TSchema> = Extract<Static<T>, Static<U>> extends infer S ? TFromTemplateLiteralResult<Assert<S, string>> : never;
type TFromArray<T extends TSchema[], U extends TSchema> = AssertRest<UnionToTuple<{
    [K in keyof T]: Static<AssertType<T[K]>> extends Static<U> ? T[K] : never;
}[number]>> extends infer R extends TSchema[] ? TUnionEvaluated<R> : never;
type TExtractResolve<T extends TSchema, U extends TSchema> = (T extends TTemplateLiteral ? TFromTemplateLiteral<T, U> : T extends TUnion<infer S> ? TFromArray<S, U> : T);
export type TExtract<T extends TSchema, U extends TSchema> = TExtractResolve<T, U>;
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export declare function Extract<L extends TMappedResult, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtractFromMappedResult<L, R>;
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export declare function Extract<L extends TSchema, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtract<L, R>;
export {};
