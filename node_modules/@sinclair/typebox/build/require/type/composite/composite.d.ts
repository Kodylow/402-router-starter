import type { UnionToTuple, Assert, Evaluate } from '../helpers/index';
import { type TObject, type TProperties, type ObjectOptions } from '../object/index';
import { type TIntersect } from '../intersect/index';
import { type TIndex } from '../indexed/index';
type TCompositeKeys<T extends TObject[], Acc extends PropertyKey = never> = T extends [infer L extends TObject, ...infer R extends TObject[]] ? TCompositeKeys<R, Acc | keyof L['properties']> : Acc;
type TCompositeIndex<T extends TIntersect<TObject[]>, K extends string[], Acc extends TProperties = {}> = K extends [infer L extends string, ...infer R extends string[]] ? TCompositeIndex<T, R, Acc & {
    [_ in L]: TIndex<T, [L]>;
}> : Acc;
type TCompositeReduce<T extends TObject[]> = UnionToTuple<TCompositeKeys<T>> extends infer K ? Evaluate<TCompositeIndex<TIntersect<T>, Assert<K, string[]>>> : {};
type TCompositeResolve<T extends TObject[]> = TIntersect<T> extends TIntersect ? TObject<TCompositeReduce<T>> : TObject<{}>;
export type TComposite<T extends TObject[]> = TCompositeResolve<T>;
/** `[Json]` Creates a Composite object type */
export declare function Composite<T extends TObject[]>(T: [...T], options?: ObjectOptions): TComposite<T>;
export {};
