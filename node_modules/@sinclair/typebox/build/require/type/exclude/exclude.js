"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Exclude = void 0;
const index_1 = require("../template-literal/index");
const index_2 = require("../union/index");
const index_3 = require("../never/index");
const index_4 = require("../extends/index");
const type_1 = require("../clone/type");
const exclude_from_mapped_result_1 = require("./exclude-from-mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const type_2 = require("../guard/type");
// prettier-ignore
function ExcludeResolve(L, R) {
    return ((0, type_2.IsTemplateLiteral)(L) ? ExcludeResolve((0, index_1.TemplateLiteralToUnion)(L), R) :
        (0, type_2.IsTemplateLiteral)(R) ? ExcludeResolve(L, (0, index_1.TemplateLiteralToUnion)(R)) :
            (0, type_2.IsUnion)(L) ? (() => {
                const narrowed = L.anyOf.filter((inner) => (0, index_4.ExtendsCheck)(inner, R) === index_4.ExtendsResult.False);
                return (narrowed.length === 1 ? narrowed[0] : (0, index_2.Union)(narrowed));
            })() :
                (0, index_4.ExtendsCheck)(L, R) !== index_4.ExtendsResult.False ? (0, index_3.Never)() :
                    L);
}
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
function Exclude(unionType, excludedMembers, options = {}) {
    if ((0, type_2.IsMappedResult)(unionType)) {
        return (0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(unionType, excludedMembers, options);
    }
    else {
        const E = ExcludeResolve(unionType, excludedMembers);
        return (0, type_1.CloneType)(E, options);
    }
}
exports.Exclude = Exclude;
