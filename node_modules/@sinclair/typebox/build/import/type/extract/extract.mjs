import { TemplateLiteralToUnion } from '../template-literal/index.mjs';
import { Union } from '../union/index.mjs';
import { Never } from '../never/index.mjs';
import { ExtendsCheck, ExtendsResult } from '../extends/index.mjs';
import { CloneType } from '../clone/type.mjs';
import { ExtractFromMappedResult } from './extract-from-mapped-result.mjs';
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
import { IsMappedResult, IsTemplateLiteral, IsUnion } from '../guard/type.mjs';
// prettier-ignore
function ExtractResolve(L, R) {
    return (IsTemplateLiteral(L) ? ExtractResolve(TemplateLiteralToUnion(L), R) :
        IsTemplateLiteral(R) ? ExtractResolve(L, TemplateLiteralToUnion(R)) :
            IsUnion(L) ? (() => {
                const narrowed = L.anyOf.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
                return (narrowed.length === 1 ? narrowed[0] : Union(narrowed));
            })() :
                ExtendsCheck(L, R) !== ExtendsResult.False ? L :
                    Never());
}
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export function Extract(type, union, options = {}) {
    if (IsMappedResult(type)) {
        return ExtractFromMappedResult(type, union, options);
    }
    else {
        const E = ExtractResolve(type, union);
        return CloneType(E, options);
    }
}
