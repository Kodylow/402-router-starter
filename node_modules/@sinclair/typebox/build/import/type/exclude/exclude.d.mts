import type { TSchema, SchemaOptions } from '../schema/index.mjs';
import type { UnionToTuple, AssertRest, AssertType, Assert } from '../helpers/index.mjs';
import type { TMappedResult } from '../mapped/index.mjs';
import { type TTemplateLiteral } from '../template-literal/index.mjs';
import { type TUnion } from '../union/index.mjs';
import { type TNever } from '../never/index.mjs';
import { type TLiteral } from '../literal/index.mjs';
import { type Static } from '../static/index.mjs';
import { type TUnionEvaluated } from '../union/index.mjs';
import { type TExcludeFromMappedResult } from './exclude-from-mapped-result.mjs';
type TExcludeTemplateLiteralResult<T extends string> = TUnionEvaluated<AssertRest<UnionToTuple<{
    [K in T]: TLiteral<K>;
}[T]>>>;
type TExcludeTemplateLiteral<T extends TTemplateLiteral, U extends TSchema> = (Exclude<Static<T>, Static<U>> extends infer S ? TExcludeTemplateLiteralResult<Assert<S, string>> : never);
type TExcludeArray<T extends TSchema[], U extends TSchema> = AssertRest<UnionToTuple<{
    [K in keyof T]: Static<AssertType<T[K]>> extends Static<U> ? never : T[K];
}[number]>> extends infer R extends TSchema[] ? TUnionEvaluated<R> : never;
type TExcludeResolve<T extends TSchema, U extends TSchema> = T extends TTemplateLiteral ? TExcludeTemplateLiteral<T, U> : T extends TUnion<infer S> ? TExcludeArray<S, U> : T extends U ? TNever : T;
export type TExclude<T extends TSchema, U extends TSchema> = TExcludeResolve<T, U>;
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
export declare function Exclude<L extends TMappedResult, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExcludeFromMappedResult<L, R>;
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
export declare function Exclude<L extends TSchema, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExclude<L, R>;
export {};
