/// <reference types="bun-types" />
import type { Serve, Server } from 'bun';
import type { Static, TSchema } from '@sinclair/typebox';
import type { Context } from './context';
import type { WS } from './ws/types';
import { ELYSIA_RESPONSE } from './error';
import type { ElysiaConfig, DecoratorBase, DefinitionBase, RouteBase, Handler, InputSchema, LocalHook, MergeSchema, RouteSchema, UnwrapRoute, InternalRoute, HTTPMethod, VoidHandler, PreHandler, BodyHandler, OptionalHandler, AfterHandler, ErrorHandler, LifeCycleStore, MaybePromise, Prettify, ListenCallback, AddPrefix, AddSuffix, AddPrefixCapitalize, AddSuffixCapitalize, TraceReporter, TraceHandler, MaybeArray, GracefulHandler, GetPathParameter, MapResponse, MacroManager, BaseMacro, MacroToProperty, TransformHandler } from './types';
import { t } from './type-system';
/**
 * ### Elysia Server
 * Main instance to create web server using Elysia
 *
 * ---
 * @example
 * ```typescript
 * import { Elysia } from 'elysia'
 *
 * new Elysia()
 *     .get("/", () => "Hello")
 *     .listen(8080)
 * ```
 */
export default class Elysia<BasePath extends string = '', Decorators extends DecoratorBase = {
    request: {};
    store: {};
    derive: {};
    resolve: {};
}, Definitions extends DefinitionBase = {
    type: {};
    error: {};
}, ParentSchema extends RouteSchema = {}, Macro extends Record<string, unknown> = {}, Routes extends RouteBase = {}, Scoped extends boolean = false> {
    config: ElysiaConfig<BasePath>;
    private dependencies;
    store: Decorators['store'];
    private decorators;
    private definitions;
    schema: Routes;
    private macros;
    event: LifeCycleStore;
    reporter: TraceReporter;
    server: Server | null;
    private getServer;
    private validator;
    private router;
    private wsRouter;
    routes: InternalRoute[];
    private staticRouter;
    private wsPaths;
    private dynamicRouter;
    private lazyLoadModules;
    path: BasePath;
    stack: string | undefined;
    constructor(config?: Partial<ElysiaConfig<BasePath, Scoped>>);
    private add;
    private setHeaders?;
    headers(header: Context['set']['headers'] | undefined): this;
    /**
     * ### start | Life cycle event
     * Called after server is ready for serving
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onStart(({ url, port }) => {
     *         console.log("Running at ${url}:${port}")
     *     })
     *     .listen(8080)
     * ```
     */
    onStart(handler: MaybeArray<GracefulHandler<this>>): this;
    /**
     * ### request | Life cycle event
     * Called on every new request is accepted
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onRequest(({ method, url }) => {
     *         saveToAnalytic({ method, url })
     *     })
     * ```
     */
    onRequest<Schema extends RouteSchema = {}>(handler: MaybeArray<PreHandler<MergeSchema<Schema, ParentSchema>, Decorators>>): this;
    /**
     * ### parse | Life cycle event
     * Callback function to handle body parsing
     *
     * If truthy value is returned, will be assigned to `context.body`
     * Otherwise will skip the callback and look for the next one.
     *
     * Equivalent to Express's body parser
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onParse((request, contentType) => {
     *         if(contentType === "application/json")
     *             return request.json()
     *     })
     * ```
     */
    onParse(parser: MaybeArray<BodyHandler<ParentSchema, Decorators>>): this;
    /**
     * ### transform | Life cycle event
     * Assign or transform anything related to context before validation.
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onTransform(({ params }) => {
     *         if(params.id)
     *             params.id = +params.id
     *     })
     * ```
     */
    onTransform<Schema extends RouteSchema = {}>(handler: MaybeArray<TransformHandler<MergeSchema<Schema, ParentSchema>, Decorators>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    resolve<Resolver extends Object>(resolver: (context: Prettify<Context<ParentSchema, Decorators>>) => MaybePromise<Resolver> extends {
        store: any;
    } ? never : Resolver): Elysia<BasePath, {
        request: Decorators['request'];
        store: Decorators['store'];
        derive: Decorators['resolve'];
        resolve: Prettify<Decorators['resolve'] & Awaited<Resolver>>;
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    /**
     * ### Before Handle | Life cycle event
     * Intercept request **before(()) main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response` and skip the main handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onBeforeHandle(({ params: { id }, status }) => {
     *         if(id && !isExisted(id)) {
     * 	           status(401)
     *
     *             return "Unauthorized"
     * 	       }
     *     })
     * ```
     */
    onBeforeHandle<Schema extends RouteSchema = {}>(handler: MaybeArray<OptionalHandler<MergeSchema<Schema, ParentSchema>, Decorators>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    onAfterHandle<Schema extends RouteSchema = {}>(handler: MaybeArray<AfterHandler<MergeSchema<Schema, ParentSchema>, Decorators>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .mapResponse((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    mapResponse<Schema extends RouteSchema = {}>(handler: MaybeArray<MapResponse<MergeSchema<Schema, ParentSchema>, Decorators>>): this;
    /**
     * ### response | Life cycle event
     * Called when handler is executed
     * Good for analytic metrics
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onResponse<Schema extends RouteSchema = {}>(handler: MaybeArray<VoidHandler<MergeSchema<Schema, ParentSchema>, Decorators>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    trace<Route extends RouteSchema = {}>(handler: TraceHandler<Route, Decorators>): this;
    /**
     * Register errors
     *
     * ---
     * @example
     * ```typescript
     * class CustomError extends Error {
     *     constructor() {
     *         super()
     *     }
     * }
     *
     * new Elysia()
     *     .error('CUSTOM_ERROR', CustomError)
     * ```
     */
    error<const Errors extends Record<string, {
        prototype: Error;
    }>>(errors: Errors): Elysia<BasePath, Decorators, {
        type: Definitions['type'];
        error: Definitions['error'] & {
            [K in keyof Errors]: Errors[K] extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : Errors[K];
        };
    }, ParentSchema, Macro, Routes, Scoped>;
    /**
     * Register errors
     *
     * ---
     * @example
     * ```typescript
     * class CustomError extends Error {
     *     constructor() {
     *         super()
     *     }
     * }
     *
     * new Elysia()
     *     .error({
     *         CUSTOM_ERROR: CustomError
     *     })
     * ```
     */
    error<Name extends string, const CustomError extends {
        prototype: Error;
    }>(name: Name, errors: CustomError): Elysia<BasePath, Decorators, {
        type: Definitions['type'];
        error: Definitions['error'] & {
            [name in Name]: CustomError extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : CustomError;
        };
    }, ParentSchema, Macro, Routes, Scoped>;
    /**
     * Register errors
     *
     * ---
     * @example
     * ```typescript
     * class CustomError extends Error {
     *     constructor() {
     *         super()
     *     }
     * }
     *
     * new Elysia()
     *     .error('CUSTOM_ERROR', CustomError)
     * ```
     */
    error<const NewErrors extends Record<string, Error>>(mapper: (decorators: Definitions['error']) => NewErrors): Elysia<BasePath, Decorators, {
        type: Definitions['type'];
        error: {
            [K in keyof NewErrors]: NewErrors[K] extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : never;
        };
    }, ParentSchema, Macro, Routes, Scoped>;
    /**
     * ### Error | Life cycle event
     * Called when error is thrown during processing request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onError<Schema extends RouteSchema = {}>(handler: ErrorHandler<Definitions['error'], MergeSchema<Schema, ParentSchema>, Decorators>): this;
    /**
     * ### stop | Life cycle event
     * Called after server stop serving request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onStop((app) => {
     *         cleanup()
     *     })
     * ```
     */
    onStop(handler: MaybeArray<GracefulHandler<this>>): this;
    /**
     * ### on
     * Syntax sugar for attaching life cycle event by name
     *
     * Does the exact same thing as `.on[Event]()`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .on('error', ({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    on<Event extends keyof LifeCycleStore>(type: Exclude<Event, 'onResponse'> | 'response', handlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>): this;
    group<const NewElysia extends Elysia<any, any, any, any, any, any, any>, const Prefix extends string>(prefix: Prefix, run: (group: Elysia<`${BasePath}${Prefix}`, Decorators, Definitions, ParentSchema, Macro, {}>) => NewElysia): NewElysia extends Elysia<any, infer PluginDecorators, infer PluginDefinitions, infer PluginSchema, any, any> ? Elysia<BasePath, PluginDecorators, PluginDefinitions, PluginSchema, Macro, Prettify<Routes & NewElysia['schema']>> : this;
    group<const LocalSchema extends InputSchema<Extract<keyof Definitions['type'], string>>, const NewElysia extends Elysia<any, any, any, any, any, any, any>, const Prefix extends string, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>>(prefix: Prefix, schema: LocalHook<LocalSchema, Schema, Decorators, Definitions['error'], Macro, `${BasePath}${Prefix}`>, run: (group: Elysia<`${BasePath}${Prefix}`, Decorators, Definitions, Schema, Macro, {}>) => NewElysia): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & NewElysia['schema']>>;
    guard<const LocalSchema extends InputSchema, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>>(hook: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, BasePath>): Elysia<BasePath, Decorators, Definitions, Route, Macro, Routes, Scoped>;
    guard<const LocalSchema extends InputSchema<Extract<keyof Definitions['type'], string>>, const NewElysia extends Elysia<any, any, any, any, any, any, any>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>>(schema: LocalHook<LocalSchema, Schema, Decorators, Definitions['error'], Macro>, run: (group: Elysia<BasePath, Decorators, Definitions, Schema, Macro, {}, Scoped>) => NewElysia): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & NewElysia['schema']>>;
    use<NewElysia extends Elysia<any, any, any, any, any, any, any> = this>(plugin: MaybePromise<(app: NewElysia) => MaybePromise<NewElysia>>): NewElysia extends Elysia<any, infer PluginDecorators, infer PluginDefinitions, infer PluginSchema, infer PluginMacro, any> ? Elysia<BasePath, {
        request: Prettify<Decorators['request'] & PluginDecorators['request']>;
        store: Prettify<Decorators['store'] & PluginDecorators['store']>;
        derive: Prettify<Decorators['derive'] & PluginDecorators['derive']>;
        resolve: Prettify<Decorators['resolve'] & PluginDecorators['resolve']>;
    }, {
        type: Prettify<Definitions['type'] & PluginDefinitions['type']>;
        error: Prettify<Definitions['error'] & PluginDefinitions['error']>;
    }, Prettify<MergeSchema<ParentSchema, PluginSchema>>, Prettify<Macro & PluginMacro>, Routes & NewElysia['schema'], Scoped> : this;
    use<NewElysia extends Elysia<any, any, any, any, any, any, any>>(instance: MaybePromise<NewElysia>): NewElysia extends Elysia<any, infer PluginDecorators, infer PluginDefinitions, infer PluginSchema, infer PluginMacro, any, infer IsScoped> ? IsScoped extends true ? Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, BasePath extends `` ? Routes & NewElysia['schema'] : Routes & AddPrefix<BasePath, NewElysia['schema']>, Scoped> : Elysia<BasePath, {
        request: Prettify<Decorators['request'] & PluginDecorators['request']>;
        store: Prettify<Decorators['store'] & PluginDecorators['store']>;
        derive: Prettify<Decorators['derive'] & PluginDecorators['derive']>;
        resolve: Prettify<Decorators['resolve'] & PluginDecorators['resolve']>;
    }, {
        type: Prettify<Definitions['type'] & PluginDefinitions['type']>;
        error: Prettify<Definitions['error'] & PluginDefinitions['error']>;
    }, Prettify<MergeSchema<ParentSchema, PluginSchema>>, Prettify<Macro & PluginMacro>, BasePath extends `` ? Routes & NewElysia['schema'] : Routes & AddPrefix<BasePath, NewElysia['schema']>, Scoped> : this;
    use<NewElysia extends Elysia<any, any, any, any, any, any, any>>(plugin: Promise<{
        default: (elysia: Elysia<any, any, any, any, any, any, any>) => MaybePromise<NewElysia>;
    }>): NewElysia extends Elysia<any, infer PluginDecorators, infer PluginDefinitions, infer PluginSchema, infer PluginMacro, any> ? Elysia<BasePath, {
        request: Decorators['request'] & PluginDecorators['request'];
        store: Decorators['store'] & PluginDecorators['store'];
        derive: Decorators['derive'] & PluginDecorators['derive'];
        resolve: Decorators['resolve'] & PluginDecorators['resolve'];
    }, {
        type: Definitions['type'] & PluginDefinitions['type'];
        error: Definitions['error'] & PluginDefinitions['error'];
    }, MergeSchema<ParentSchema, PluginSchema>, Prettify<Macro & PluginMacro>, BasePath extends `` ? Routes & NewElysia['schema'] : Routes & AddPrefix<BasePath, NewElysia['schema']>, Scoped> : this;
    use<LazyLoadElysia extends Elysia<any, any, any, any, any, any, any>>(plugin: Promise<{
        default: LazyLoadElysia;
    }>): LazyLoadElysia extends Elysia<any, infer PluginDecorators, infer PluginDefinitions, infer PluginSchema, infer PluginMacro, any> ? Elysia<BasePath, {
        request: PluginDecorators['request'] & Decorators['request'];
        store: PluginDecorators['store'] & Decorators['store'];
        derive: Decorators['derive'] & PluginDecorators['derive'];
        resolve: Decorators['resolve'] & PluginDecorators['resolve'];
    }, {
        type: PluginDefinitions['type'] & Definitions['type'];
        error: PluginDefinitions['error'] & Definitions['error'];
    }, MergeSchema<PluginSchema, ParentSchema>, Prettify<Macro & PluginMacro>, BasePath extends `` ? Routes & LazyLoadElysia['schema'] : Routes & AddPrefix<BasePath, LazyLoadElysia['schema']>> : this;
    private _use;
    macro<const NewMacro extends BaseMacro>(macro: (route: MacroManager<Routes, Decorators, Definitions['error']>) => NewMacro): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro & Partial<MacroToProperty<NewMacro>>, Routes, Scoped>;
    mount(handle: ((request: Request) => MaybePromise<Response>) | Elysia<any, any, any, any, any, any, any>): this;
    mount(path: string, handle: ((request: Request) => MaybePromise<Response>) | Elysia<any, any, any, any, any, any, any>): this;
    /**
     * ### get
     * Register handler for path with method [GET]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .get('/', () => 'hi')
     *     .get('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    get<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            get: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### post
     * Register handler for path with method [POST]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .post('/', () => 'hi')
     *     .post('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    post<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            post: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### put
     * Register handler for path with method [PUT]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .put('/', () => 'hi')
     *     .put('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    put<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            put: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### patch
     * Register handler for path with method [PATCH]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .patch('/', () => 'hi')
     *     .patch('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    patch<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            patch: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### delete
     * Register handler for path with method [DELETE]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .delete('/', () => 'hi')
     *     .delete('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    delete<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            delete: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### options
     * Register handler for path with method [OPTIONS]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .options('/', () => 'hi')
     *     .options('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    options<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            get: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### all
     * Register handler for path with any method
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .all('/', () => 'hi')
     * ```
     */
    all<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            [method in string]: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### head
     * Register handler for path with method [HEAD]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .head('/', () => 'hi')
     *     .head('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    head<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            head: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### connect
     * Register handler for path with method [CONNECT]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .connect('/', () => 'hi')
     *     .connect('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    connect<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            connect: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### ws
     * Register handler for path with method [ws]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .ws('/', {
     *         message(ws, message) {
     *             ws.send(message)
     *         }
     *     })
     * ```
     */
    ws<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>>(path: Path, options: WS.LocalHook<LocalSchema, Route, Decorators, Definitions['error'], `${BasePath}${Path}`>): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            subscribe: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: Route['response'];
            };
        };
    }>, Scoped>;
    /**
     * ### route
     * Register handler for path with custom method
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .route('CUSTOM', '/', () => 'hi')
     *     .route('CUSTOM', '/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    route<const Method extends HTTPMethod, const Path extends string, const LocalSchema extends InputSchema<Extract<keyof Definitions['type'], string>>, const Handle extends Exclude<Route['response'], Handle> | Handler<Route, Decorators, `${BasePath}${Path}`>, const Route extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, ParentSchema>>(method: Method, path: Path, handler: Handle, { config, ...hook }?: LocalHook<LocalSchema, Route, Decorators, Definitions['error'], Macro, `${BasePath}${Path}`> & {
        config: {
            allowMeta?: boolean;
        };
    }): Elysia<BasePath, Decorators, Definitions, ParentSchema, Macro, Prettify<Routes & {
        [path in `${BasePath}${Path}`]: {
            [method in Lowercase<Method>]: {
                body: Route['body'];
                params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
                query: Route['query'];
                headers: Route['headers'];
                response: unknown extends Route['response'] ? (Handle extends (...a: any) => infer Returned ? Returned : Handle) extends infer Res ? keyof Res extends typeof ELYSIA_RESPONSE ? Prettify<{
                    200: Exclude<Res, {
                        [ELYSIA_RESPONSE]: number;
                    }>;
                } & (Extract<Res, {
                    [ELYSIA_RESPONSE]: number;
                }> extends infer ErrorResponse extends {
                    [ELYSIA_RESPONSE]: number;
                    response: any;
                } ? {
                    [status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response'];
                } : {})> : {
                    200: Res;
                } : never : Route['response'] extends {
                    200: any;
                } ? Route['response'] : {
                    200: Route['response'];
                };
            };
        };
    }>, Scoped>;
    /**
     * ### state
     * Assign global mutatable state accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .state({ counter: 0 })
     *     .get('/', (({ counter }) => ++counter)
     * ```
     */
    state<Name extends string | number | symbol, Value>(name: Name, value: Value): Elysia<BasePath, {
        request: Decorators['request'];
        store: Prettify<Decorators['store'] & {
            [name in Name]: Value;
        }>;
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    /**
     * ### state
     * Assign global mutatable state accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .state('counter', 0)
     *     .get('/', (({ counter }) => ++counter)
     * ```
     */
    state<Store extends Record<string, unknown>>(store: Store): Elysia<BasePath, {
        request: Decorators['request'];
        store: Prettify<Decorators['store'] & Store>;
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    state<const NewStore extends Record<string, unknown>>(mapper: (decorators: Decorators['store']) => NewStore): Elysia<BasePath, {
        request: Decorators['request'];
        store: NewStore;
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    /**
     * ### decorate
     * Define custom method to `Context` accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .decorate('getDate', () => Date.now())
     *     .get('/', (({ getDate }) => getDate())
     * ```
     */
    decorate<const Name extends string, const Value>(name: Name, value: Value): Elysia<BasePath, {
        request: Prettify<Decorators['request'] & {
            [name in Name]: Value;
        }>;
        store: Decorators['store'];
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    /**
     * ### decorate
     * Define custom method to `Context` accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .decorate('getDate', () => Date.now())
     *     .get('/', (({ getDate }) => getDate())
     * ```
     */
    decorate<const NewDecorators extends Record<string, unknown>>(decorators: NewDecorators): Elysia<BasePath, {
        request: Prettify<Decorators['request'] & NewDecorators>;
        store: Decorators['store'];
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    decorate<const NewDecorators extends Record<string, unknown>>(mapper: (decorators: Decorators['request']) => NewDecorators): Elysia<BasePath, {
        request: NewDecorators;
        store: Decorators['store'];
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    derive<Derivative extends Object>(transform: (context: Prettify<Context<ParentSchema, Decorators>>) => MaybePromise<Derivative> extends {
        store: any;
    } ? never : Derivative): Elysia<BasePath, {
        request: Decorators['request'];
        store: Decorators['store'];
        derive: Prettify<Decorators['derive'] & Awaited<Derivative>>;
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    model<Name extends string, Model extends TSchema>(name: Name, model: Model): Elysia<BasePath, Decorators, {
        type: Prettify<Definitions['type'] & {
            [name in Name]: Static<Model>;
        }>;
        error: Definitions['error'];
    }, ParentSchema, Macro, Routes, Scoped>;
    model<Recorder extends Record<string, TSchema>>(record: Recorder): Elysia<BasePath, Decorators, {
        type: Prettify<Definitions['type'] & {
            [key in keyof Recorder]: Static<Recorder[key]>;
        }>;
        error: Definitions['error'];
    }, ParentSchema, Macro, Routes, Scoped>;
    model<const NewType extends Record<string, TSchema>>(mapper: (decorators: {
        [type in keyof Definitions['type']]: ReturnType<typeof t.Unsafe<Definitions['type'][type]>>;
    }) => NewType): Elysia<BasePath, Decorators, {
        type: {
            [x in keyof NewType]: Static<NewType[x]>;
        };
        error: Definitions['error'];
    }, ParentSchema, Macro, Routes, Scoped>;
    mapDerive<const NewStore extends Record<string, unknown>>(mapper: (decorators: Decorators['request']) => MaybePromise<NewStore>): Elysia<BasePath, {
        request: Decorators['request'];
        store: NewStore;
        derive: Decorators['derive'];
        resolve: Decorators['resolve'];
    }, Definitions, ParentSchema, Macro, Routes, Scoped>;
    affix<const Base extends 'prefix' | 'suffix', const Type extends 'all' | 'decorator' | 'state' | 'model' | 'error', const Word extends string>(base: Base, type: Type, word: Word): Elysia<BasePath, {
        request: Type extends 'decorator' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Decorators['request']> : AddPrefixCapitalize<Word, Decorators['request']> : AddSuffixCapitalize<Word, Decorators['request']> : Decorators['request'];
        store: Type extends 'state' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Decorators['store']> : AddPrefixCapitalize<Word, Decorators['store']> : AddSuffix<Word, Decorators['store']> : Decorators['store'];
        derive: Type extends 'decorator' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Decorators['derive']> : AddPrefixCapitalize<Word, Decorators['derive']> : AddSuffixCapitalize<Word, Decorators['derive']> : Decorators['derive'];
        resolve: Type extends 'decorator' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Decorators['resolve']> : AddPrefixCapitalize<Word, Decorators['resolve']> : AddSuffixCapitalize<Word, Decorators['resolve']> : Decorators['resolve'];
    }, {
        type: Type extends 'model' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Definitions['type']> : AddPrefixCapitalize<Word, Definitions['type']> : AddSuffixCapitalize<Word, Definitions['type']> : Definitions['type'];
        error: Type extends 'error' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Definitions['error']> : AddPrefixCapitalize<Word, Definitions['error']> : AddSuffixCapitalize<Word, Definitions['error']> : Definitions['error'];
    }, ParentSchema, Macro, Routes, Scoped>;
    prefix<const Type extends 'all' | 'decorator' | 'state' | 'model' | 'error', const Word extends string>(type: Type, word: Word): Elysia<BasePath, {
        request: Type extends "all" | "decorator" ? Word extends `${string}_` | `${string}-` | `${string} ` ? AddPrefix<Word, Decorators["request"]> : AddPrefixCapitalize<Word, Decorators["request"]> : Decorators["request"];
        store: Type extends "all" | "state" ? Word extends `${string}_` | `${string}-` | `${string} ` ? AddPrefix<Word, Decorators["store"]> : AddPrefixCapitalize<Word, Decorators["store"]> : Decorators["store"];
        derive: Type extends "all" | "decorator" ? Word extends `${string}_` | `${string}-` | `${string} ` ? AddPrefix<Word, Decorators["derive"]> : AddPrefixCapitalize<Word, Decorators["derive"]> : Decorators["derive"];
        resolve: Type extends "all" | "decorator" ? Word extends `${string}_` | `${string}-` | `${string} ` ? AddPrefix<Word, Decorators["resolve"]> : AddPrefixCapitalize<Word, Decorators["resolve"]> : Decorators["resolve"];
    }, {
        type: Type extends "all" | "model" ? Word extends `${string}_` | `${string}-` | `${string} ` ? AddPrefix<Word, Definitions["type"]> : AddPrefixCapitalize<Word, Definitions["type"]> : Definitions["type"];
        error: Type extends "error" | "all" ? Word extends `${string}_` | `${string}-` | `${string} ` ? AddPrefix<Word, Definitions["error"]> : AddPrefixCapitalize<Word, Definitions["error"]> : Definitions["error"];
    }, ParentSchema, Macro, Routes, Scoped>;
    suffix<const Type extends 'all' | 'decorator' | 'state' | 'model' | 'error', const Word extends string>(type: Type, word: Word): Elysia<BasePath, {
        request: Type extends "all" | "decorator" ? AddSuffixCapitalize<Word, Decorators["request"]> : Decorators["request"];
        store: Type extends "all" | "state" ? AddSuffix<Word, Decorators["store"]> : Decorators["store"];
        derive: Type extends "all" | "decorator" ? AddSuffixCapitalize<Word, Decorators["derive"]> : Decorators["derive"];
        resolve: Type extends "all" | "decorator" ? AddSuffixCapitalize<Word, Decorators["resolve"]> : Decorators["resolve"];
    }, {
        type: Type extends "all" | "model" ? AddSuffixCapitalize<Word, Definitions["type"]> : Definitions["type"];
        error: Type extends "error" | "all" ? AddSuffixCapitalize<Word, Definitions["error"]> : Definitions["error"];
    }, ParentSchema, Macro, Routes, Scoped>;
    compile(): this;
    handle: (request: Request) => Promise<Response>;
    /**
     * Use handle can be either sync or async to save performance.
     *
     * Beside benchmark purpose, please use 'handle' instead.
     */
    fetch: (request: Request) => MaybePromise<Response>;
    private handleError;
    private outerErrorHandler;
    /**
     * ### listen
     * Assign current instance to port and start serving
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .get("/", () => 'hi')
     *     .listen(8080)
     * ```
     */
    listen: (options: string | number | Partial<Serve>, callback?: ListenCallback) => this;
    /**
     * ### stop
     * Stop server from serving
     *
     * ---
     * @example
     * ```typescript
     * const app = new Elysia()
     *     .get("/", () => 'hi')
     *     .listen(8080)
     *
     * // Sometime later
     * app.stop()
     * ```
     */
    stop: () => Promise<void>;
    /**
     * Wait until all lazy loaded modules all load is fully
     */
    get modules(): Promise<Elysia<any, any, {
        type: {};
        error: {};
    }, {}, {}, {}, false>[]>;
}
export { Elysia };
export { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler';
export { t } from './type-system';
export { Cookie, type CookieOptions } from './cookie';
export { getSchemaValidator, mergeDeep, mergeHook, mergeObjectArray, getResponseSchemaValidator } from './utils';
export { error, ParseError, NotFoundError, ValidationError, InternalServerError, InvalidCookieSignature } from './error';
export type { Context, PreContext } from './context';
export type { ElysiaConfig, DecoratorBase, DefinitionBase, RouteBase, Handler, ComposedHandler, InputSchema, LocalHook, MergeSchema, RouteSchema, UnwrapRoute, InternalRoute, HTTPMethod, SchemaValidator, VoidHandler, PreHandler, BodyHandler, OptionalHandler, ErrorHandler, AfterHandler, LifeCycleEvent, TraceEvent, LifeCycleStore, MaybePromise, ListenCallback, UnwrapSchema, TraceHandler, TraceProcess, TraceReporter, TraceStream, Checksum } from './types';
export type { Static, TSchema } from '@sinclair/typebox';
