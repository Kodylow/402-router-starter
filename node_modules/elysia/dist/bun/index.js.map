{
  "version": 3,
  "sources": ["../../node_modules/eventemitter3/index.js", "../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/fast-querystring/lib/parse.js", "../../node_modules/fast-querystring/lib/internals/querystring.js", "../../node_modules/fast-querystring/lib/stringify.js", "../../node_modules/fast-querystring/lib/index.js", "../../node_modules/memoirist/dist/index.js", "../../node_modules/eventemitter3/index.mjs", "../../node_modules/eventemitter3/index.mjs", "../../src/trace.ts", "../../node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs", "../../node_modules/@sinclair/typebox/build/import/system/policy.mjs", "../../node_modules/@sinclair/typebox/build/import/type/registry/format.mjs", "../../node_modules/@sinclair/typebox/build/import/type/registry/type.mjs", "../../node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs", "../../node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs", "../../node_modules/@sinclair/typebox/build/import/type/error/error.mjs", "../../node_modules/@sinclair/typebox/build/import/system/system.mjs", "../../node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/guard/value.mjs", "../../node_modules/@sinclair/typebox/build/import/type/clone/value.mjs", "../../node_modules/@sinclair/typebox/build/import/type/clone/type.mjs", "../../node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs", "../../node_modules/@sinclair/typebox/build/import/type/array/array.mjs", "../../node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs", "../../node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs", "../../node_modules/@sinclair/typebox/build/import/type/function/function.mjs", "../../node_modules/@sinclair/typebox/build/import/type/never/never.mjs", "../../node_modules/@sinclair/typebox/build/import/type/guard/type.mjs", "../../node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs", "../../node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs", "../../node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs", "../../node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs", "../../node_modules/@sinclair/typebox/build/import/type/union/union.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs", "../../node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs", "../../node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs", "../../node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs", "../../node_modules/@sinclair/typebox/build/import/type/number/number.mjs", "../../node_modules/@sinclair/typebox/build/import/type/string/string.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs", "../../node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs", "../../node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs", "../../node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs", "../../node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs", "../../node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs", "../../node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs", "../../node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs", "../../node_modules/@sinclair/typebox/build/import/type/object/object.mjs", "../../node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs", "../../node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs", "../../node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs", "../../node_modules/@sinclair/typebox/build/import/type/sets/set.mjs", "../../node_modules/@sinclair/typebox/build/import/type/sets/set.mjs", "../../node_modules/@sinclair/typebox/build/import/type/sets/set.mjs", "../../node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs", "../../node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs", "../../node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs", "../../node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs", "../../node_modules/@sinclair/typebox/build/import/errors/function.mjs", "../../node_modules/@sinclair/typebox/build/import/errors/function.mjs", "../../node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs", "../../node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs", "../../node_modules/@sinclair/typebox/build/import/errors/errors.mjs", "../../node_modules/@sinclair/typebox/build/import/type/any/any.mjs", "../../node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs", "../../node_modules/@sinclair/typebox/build/import/value/check/check.mjs", "../../node_modules/@sinclair/typebox/build/import/value/create/create.mjs", "../../node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs", "../../node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs", "../../node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs", "../../node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs", "../../node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs", "../../node_modules/@sinclair/typebox/build/import/value/default/default.mjs", "../../node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs", "../../node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs", "../../node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs", "../../node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs", "../../node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs", "../../node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs", "../../node_modules/@sinclair/typebox/build/import/value/transform/has.mjs", "../../node_modules/@sinclair/typebox/build/import/value/value/value.mjs", "../../node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs", "../../node_modules/@sinclair/typebox/build/import/type/date/date.mjs", "../../node_modules/@sinclair/typebox/build/import/type/null/null.mjs", "../../node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs", "../../node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs", "../../node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs", "../../node_modules/@sinclair/typebox/build/import/type/const/const.mjs", "../../node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs", "../../node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs", "../../node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs", "../../node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs", "../../node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs", "../../node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs", "../../node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs", "../../node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs", "../../node_modules/@sinclair/typebox/build/import/type/not/not.mjs", "../../node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs", "../../node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs", "../../node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs", "../../node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs", "../../node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs", "../../node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs", "../../node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs", "../../node_modules/@sinclair/typebox/build/import/type/record/record.mjs", "../../node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs", "../../node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs", "../../node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs", "../../node_modules/@sinclair/typebox/build/import/type/required/required.mjs", "../../node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs", "../../node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs", "../../node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs", "../../node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs", "../../node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs", "../../node_modules/@sinclair/typebox/build/import/type/void/void.mjs", "../../node_modules/@sinclair/typebox/build/import/type/type/index.mjs", "../../node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs", "../../node_modules/cookie/index.js", "../../src/cookie.ts", "../../src/handler.ts", "../../src/utils.ts", "../../src/utils.ts", "../../src/error.ts", "../../src/ws/index.ts", "../../src/compose.ts", "../../src/compose.ts", "../../src/dynamic-handle.ts", "../../src/dynamic-handle.ts", "../../src/type-system.ts", "../../src/index.ts"],
  "sourcesContent": [
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n",
  "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
  "\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n",
  "// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n",
  "\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n",
  "\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n",
  "let e=(e,t)=>({part:e,store:null,inert:void 0!==t?new Map(t.map(e=>[e.part.charCodeAt(0),e])):null,params:null,wildcardStore:null}),t=(e,t)=>({...e,part:t}),r=e=>({paramName:e,store:null,inert:null});export class Memoirist{root={};history=[];static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g};add(a,l,i){let s;if(\"string\"!=typeof l)throw TypeError(\"Route path must be a string\");\"\"===l?l=\"/\":\"/\"!==l[0]&&(l=`/${l}`),this.history.push([a,l,i]);let n=\"*\"===l[l.length-1];n&&(l=l.slice(0,-1));let o=l.split(Memoirist.regex.static),u=l.match(Memoirist.regex.params)||[];\"\"===o[o.length-1]&&o.pop(),s=this.root[a]?this.root[a]:this.root[a]=e(\"/\");let p=0;for(let a=0;a<o.length;++a){let i=o[a];if(a>0){let t=u[p++].slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);let a=s.params;if(null===a.inert){s=a.inert=e(i);continue}s=a.inert}for(let r=0;;){if(r===i.length){if(r<s.part.length){let a=t(s,s.part.slice(r));Object.assign(s,e(i,[a]))}break}if(r===s.part.length){if(null===s.inert)s.inert=new Map;else if(s.inert.has(i.charCodeAt(r))){s=s.inert.get(i.charCodeAt(r)),i=i.slice(r),r=0;continue}let t=e(i.slice(r));s.inert.set(i.charCodeAt(r),t),s=t;break}if(i[r]!==s.part[r]){let a=t(s,s.part.slice(r)),l=e(i.slice(r));Object.assign(s,e(s.part.slice(0,r),[a,l])),s=l;break}++r}}if(p<u.length){let e=u[p],t=e.slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);return null===s.params.store&&(s.params.store=i),s.params.store}return n?(null===s.wildcardStore&&(s.wildcardStore=i),s.wildcardStore):(null===s.store&&(s.store=i),s.store)}find(e,t){let r=this.root[e];return r?a(t,t.length,r,0):null}}let a=(e,t,r,l)=>{let i=r?.part,s=l+i.length;if(i.length>1){if(s>t)return null;if(i.length<15){for(let t=1,r=l+1;t<i.length;++t,++r)if(i.charCodeAt(t)!==e.charCodeAt(r))return null}else if(e.substring(l,s)!==i)return null}if(s===t)return null!==r.store?{store:r.store,params:{}}:null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":\"\"}}:null;if(null!==r.inert){let l=r.inert.get(e.charCodeAt(s));if(void 0!==l){let r=a(e,t,l,s);if(null!==r)return r}}if(null!==r.params){let l=r.params,i=e.indexOf(\"/\",s);if(i!==s){if(-1===i||i>=t){if(null!==l.store){let r={};return r[l.paramName]=e.substring(s,t),{store:l.store,params:r}}}else if(null!==l.inert){let r=a(e,t,l.inert,i);if(null!==r)return r.params[l.paramName]=e.substring(s,i),r}}}return null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":e.substring(s,t)}}:null};export default Memoirist;",
  "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
  "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
  "import type {\n\tTraceHandler,\n\tTraceProcess,\n\tTraceReporter,\n\tTraceStream\n} from './types'\n\nconst resolver = <T>() => {\n\tlet resolve: (a: T) => any\n\tconst promise = new Promise<T>((r) => {\n\t\tresolve = r\n\t})\n\n\treturn [promise, resolve!] as const\n}\n\ntype TraceResolver = [\n\tstart: (value: TraceProcess<'begin'>) => any,\n\tend: (value: TraceProcess<'end'>) => any\n]\n\nconst createSignal = () => {\n\tconst [start, resolveStart] = resolver<TraceProcess<'begin'>>()\n\tconst [end, resolveEnd] = resolver<TraceProcess<'end'>>()\n\n\tconst children: Promise<TraceProcess<'begin'>>[] = []\n\tconst resolvers: TraceResolver[] = []\n\n\treturn {\n\t\tsignal: start,\n\t\tconsume: (trace: TraceStream) => {\n\t\t\tswitch (trace.type) {\n\t\t\t\tcase 'begin':\n\t\t\t\t\tif (trace.unit && children.length === 0)\n\t\t\t\t\t\tfor (let i = 0; i < trace.unit; i++) {\n\t\t\t\t\t\t\tconst [start, resolveStart] =\n\t\t\t\t\t\t\t\tresolver<TraceProcess<'begin'>>()\n\t\t\t\t\t\t\tconst [end, resolveEnd] =\n\t\t\t\t\t\t\t\tresolver<TraceProcess<'end'>>()\n\n\t\t\t\t\t\t\tchildren.push(start)\n\t\t\t\t\t\t\tresolvers.push([\n\t\t\t\t\t\t\t\t(trace) => {\n\t\t\t\t\t\t\t\t\tresolveStart({\n\t\t\t\t\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(time) => {\n\t\t\t\t\t\t\t\t\tresolveEnd(time)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t}\n\n\t\t\t\t\tresolveStart({\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\tend,\n\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'end':\n\t\t\t\t\tresolveEnd(trace.time)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t},\n\t\tconsumeChild(trace: TraceStream) {\n\t\t\tswitch (trace.type) {\n\t\t\t\tcase 'begin':\n\t\t\t\t\tif (!resolvers[0]) return\n\t\t\t\t\tconst [resolveStart] = resolvers[0]\n\n\t\t\t\t\tresolveStart({\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tend,\n\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'end':\n\t\t\t\t\tconst child = resolvers.shift()\n\t\t\t\t\tif (!child) return\n\n\t\t\t\t\tchild[1](trace.time)\n\t\t\t}\n\t\t},\n\t\tresolve() {\n\t\t\tresolveStart({\n\t\t\t\tchildren: [],\n\t\t\t\tend: new Promise((resolve) => resolve(0)),\n\t\t\t\tname: '',\n\t\t\t\tskip: true,\n\t\t\t\ttime: 0\n\t\t\t})\n\n\t\t\tfor (const [resolveStart, resolveEnd] of resolvers) {\n\t\t\t\tresolveStart({\n\t\t\t\t\tchildren: [],\n\t\t\t\t\tend: new Promise((resolve) => resolve(0)),\n\t\t\t\t\tname: '',\n\t\t\t\t\tskip: true,\n\t\t\t\t\ttime: 0\n\t\t\t\t})\n\n\t\t\t\tresolveEnd(0)\n\t\t\t}\n\n\t\t\tresolveEnd(0)\n\t\t}\n\t}\n}\n\nexport const createTraceListener = (\n\tgetReporter: () => TraceReporter,\n\ttotalListener: number,\n\thandler: TraceHandler<any, any>\n) => {\n\treturn async function trace(trace: TraceStream) {\n\t\tif (trace.event !== 'request' || trace.type !== 'begin') return\n\n\t\tconst id = trace.id\n\t\tconst reporter = getReporter()\n\n\t\tconst request = createSignal()\n\t\tconst parse = createSignal()\n\t\tconst transform = createSignal()\n\t\tconst beforeHandle = createSignal()\n\t\tconst handle = createSignal()\n\t\tconst afterHandle = createSignal()\n\t\tconst error = createSignal()\n\t\tconst response = createSignal()\n\n\t\trequest.consume(trace)\n\n\t\tconst reducer = (event: TraceStream) => {\n\t\t\tif (event.id === id)\n\t\t\t\tswitch (event.event) {\n\t\t\t\t\tcase 'request':\n\t\t\t\t\t\trequest.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'request.unit':\n\t\t\t\t\t\trequest.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'parse':\n\t\t\t\t\t\tparse.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'parse.unit':\n\t\t\t\t\t\tparse.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'transform':\n\t\t\t\t\t\ttransform.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'transform.unit':\n\t\t\t\t\t\ttransform.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\t\tbeforeHandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'beforeHandle.unit':\n\t\t\t\t\t\tbeforeHandle.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'handle':\n\t\t\t\t\t\thandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'afterHandle':\n\t\t\t\t\t\tafterHandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'afterHandle.unit':\n\t\t\t\t\t\tafterHandle.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\terror.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'error.unit':\n\t\t\t\t\t\terror.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'response':\n\t\t\t\t\t\tif (event.type === 'begin') {\n\t\t\t\t\t\t\trequest.resolve()\n\t\t\t\t\t\t\tparse.resolve()\n\t\t\t\t\t\t\ttransform.resolve()\n\t\t\t\t\t\t\tbeforeHandle.resolve()\n\t\t\t\t\t\t\thandle.resolve()\n\t\t\t\t\t\t\tafterHandle.resolve()\n\t\t\t\t\t\t\terror.resolve()\n\t\t\t\t\t\t} else reporter.off('event', reducer)\n\n\t\t\t\t\t\tresponse.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'response.unit':\n\t\t\t\t\t\tresponse.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'exit':\n\t\t\t\t\t\trequest.resolve()\n\t\t\t\t\t\tparse.resolve()\n\t\t\t\t\t\ttransform.resolve()\n\t\t\t\t\t\tbeforeHandle.resolve()\n\t\t\t\t\t\thandle.resolve()\n\t\t\t\t\t\tafterHandle.resolve()\n\t\t\t\t\t\terror.resolve()\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t}\n\n\t\treporter.on('event', reducer)\n\n\t\tawait handler({\n\t\t\tid,\n\t\t\t// @ts-ignore\n\t\t\tcontext: trace.ctx,\n\t\t\t// @ts-ignore\n\t\t\tset: trace.ctx?.set,\n\t\t\t// @ts-ignore\n\t\t\tstore: trace.ctx?.store,\n\t\t\ttime: trace.time,\n\t\t\trequest: request.signal as any,\n\t\t\tparse: parse.signal as any,\n\t\t\ttransform: transform.signal as any,\n\t\t\tbeforeHandle: beforeHandle.signal as any,\n\t\t\thandle: handle.signal as any,\n\t\t\tafterHandle: afterHandle.signal as any,\n\t\t\terror: error.signal,\n\t\t\tresponse: response.signal as any\n\t\t})\n\n\t\treporter.emit(`res${id}.${totalListener}`, undefined)\n\t}\n}\n",
  "// --------------------------------------------------------------------------\n// Iterators\n// --------------------------------------------------------------------------\n/** Returns true if this value is an async iterator */\nexport function IsAsyncIterator(value) {\n    return IsObject(value) && Symbol.asyncIterator in value;\n}\n/** Returns true if this value is an iterator */\nexport function IsIterator(value) {\n    return IsObject(value) && Symbol.iterator in value;\n}\n// --------------------------------------------------------------------------\n// Nominal\n// --------------------------------------------------------------------------\n/** Returns true if this value is a typed array */\nexport function IsTypedArray(value) {\n    return ArrayBuffer.isView(value);\n}\n/** Returns true if this value is a Promise */\nexport function IsPromise(value) {\n    return value instanceof Promise;\n}\n/** Returns true if the value is a Uint8Array */\nexport function IsUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/** Returns true if this value is a Date */\nexport function IsDate(value) {\n    return value instanceof Date && Number.isFinite(value.getTime());\n}\n// --------------------------------------------------------------------------\n// Standard\n// --------------------------------------------------------------------------\n/** Returns true if this value has this property key */\nexport function HasPropertyKey(value, key) {\n    return key in value;\n}\n/** Returns true if this object is not an instance of any other type */\nexport function IsPlainObject(value) {\n    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === 'Object';\n}\n/** Returns true of this value is an object type */\nexport function IsObject(value) {\n    return value !== null && typeof value === 'object';\n}\n/** Returns true if this value is an array, but not a typed array */\nexport function IsArray(value) {\n    return Array.isArray(value) && !ArrayBuffer.isView(value);\n}\n/** Returns true if this value is an undefined */\nexport function IsUndefined(value) {\n    return value === undefined;\n}\n/** Returns true if this value is an null */\nexport function IsNull(value) {\n    return value === null;\n}\n/** Returns true if this value is an boolean */\nexport function IsBoolean(value) {\n    return typeof value === 'boolean';\n}\n/** Returns true if this value is an number */\nexport function IsNumber(value) {\n    return typeof value === 'number';\n}\n/** Returns true if this value is an integer */\nexport function IsInteger(value) {\n    return IsNumber(value) && Number.isInteger(value);\n}\n/** Returns true if this value is bigint */\nexport function IsBigInt(value) {\n    return typeof value === 'bigint';\n}\n/** Returns true if this value is string */\nexport function IsString(value) {\n    return typeof value === 'string';\n}\n/** Returns true if this value is a function */\nexport function IsFunction(value) {\n    return typeof value === 'function';\n}\n/** Returns true if this value is a symbol */\nexport function IsSymbol(value) {\n    return typeof value === 'symbol';\n}\n/** Returns true if this value is a value type such as number, string, boolean */\nexport function IsValueType(value) {\n    // prettier-ignore\n    return (IsBigInt(value) ||\n        IsBoolean(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsUndefined(value));\n}\n",
  "import { IsObject, IsArray, IsNumber, IsUndefined } from '../value/guard/index.mjs';\nexport var TypeSystemPolicy;\n(function (TypeSystemPolicy) {\n    // ------------------------------------------------------------------\n    // TypeSystemPolicy\n    // ------------------------------------------------------------------\n    /** Shared assertion routines used by the value and errors modules */\n    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */\n    TypeSystemPolicy.ExactOptionalPropertyTypes = false;\n    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */\n    TypeSystemPolicy.AllowArrayObject = false;\n    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */\n    TypeSystemPolicy.AllowNaN = false;\n    /** Sets whether `null` should validate for void types. The default is `false` */\n    TypeSystemPolicy.AllowNullVoid = false;\n    /** Asserts this value using the ExactOptionalPropertyTypes policy */\n    function IsExactOptionalProperty(value, key) {\n        return TypeSystemPolicy.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;\n    }\n    TypeSystemPolicy.IsExactOptionalProperty = IsExactOptionalProperty;\n    /** Asserts this value using the AllowArrayObjects policy */\n    function IsObjectLike(value) {\n        const isObject = IsObject(value);\n        return TypeSystemPolicy.AllowArrayObject ? isObject : isObject && !IsArray(value);\n    }\n    TypeSystemPolicy.IsObjectLike = IsObjectLike;\n    /** Asserts this value as a record using the AllowArrayObjects policy */\n    function IsRecordLike(value) {\n        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);\n    }\n    TypeSystemPolicy.IsRecordLike = IsRecordLike;\n    /** Asserts this value using the AllowNaN policy */\n    function IsNumberLike(value) {\n        const isNumber = IsNumber(value);\n        return TypeSystemPolicy.AllowNaN ? isNumber : isNumber && Number.isFinite(value);\n    }\n    TypeSystemPolicy.IsNumberLike = IsNumberLike;\n    /** Asserts this value using the AllowVoidNull policy */\n    function IsVoidLike(value) {\n        const isUndefined = IsUndefined(value);\n        return TypeSystemPolicy.AllowNullVoid ? isUndefined || value === null : isUndefined;\n    }\n    TypeSystemPolicy.IsVoidLike = IsVoidLike;\n})(TypeSystemPolicy || (TypeSystemPolicy = {}));\n",
  "/** A registry for user defined string formats */\nconst map = new Map();\n/** Returns the entries in this registry */\nexport function Entries() {\n    return new Map(map);\n}\n/** Clears all user defined string formats */\nexport function Clear() {\n    return map.clear();\n}\n/** Deletes a registered format */\nexport function Delete(format) {\n    return map.delete(format);\n}\n/** Returns true if the user defined string format exists */\nexport function Has(format) {\n    return map.has(format);\n}\n/** Sets a validation function for a user defined string format */\nexport function Set(format, func) {\n    map.set(format, func);\n}\n/** Gets a validation function for a user defined string format */\nexport function Get(format) {\n    return map.get(format);\n}\n",
  "/** A registry for user defined types */\nconst map = new Map();\n/** Returns the entries in this registry */\nexport function Entries() {\n    return new Map(map);\n}\n/** Clears all user defined types */\nexport function Clear() {\n    return map.clear();\n}\n/** Deletes a registered type */\nexport function Delete(kind) {\n    return map.delete(kind);\n}\n/** Returns true if this registry contains this kind */\nexport function Has(kind) {\n    return map.has(kind);\n}\n/** Sets a validation function for a user defined type */\nexport function Set(kind, func) {\n    map.set(kind, func);\n}\n/** Gets a custom validation function for a user defined type */\nexport function Get(kind) {\n    return map.get(kind);\n}\n",
  "/** Symbol key applied to transform types */\nexport const TransformKind = Symbol.for('TypeBox.Transform');\n/** Symbol key applied to readonly types */\nexport const ReadonlyKind = Symbol.for('TypeBox.Readonly');\n/** Symbol key applied to optional types */\nexport const OptionalKind = Symbol.for('TypeBox.Optional');\n/** Symbol key applied to types */\nexport const Hint = Symbol.for('TypeBox.Hint');\n/** Symbol key applied to types */\nexport const Kind = Symbol.for('TypeBox.Kind');\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\nexport function Unsafe(options = {}) {\n    return {\n        ...options,\n        [Kind]: options[Kind] ?? 'Unsafe',\n    };\n}\n",
  "/** The base Error type thrown for all TypeBox exceptions  */\nexport class TypeBoxError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n",
  "import { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { Unsafe } from '../type/unsafe/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class TypeSystemDuplicateTypeKind extends TypeBoxError {\n    constructor(kind) {\n        super(`Duplicate type kind '${kind}' detected`);\n    }\n}\nexport class TypeSystemDuplicateFormat extends TypeBoxError {\n    constructor(kind) {\n        super(`Duplicate string format '${kind}' detected`);\n    }\n}\n// ------------------------------------------------------------------\n// TypeSystem\n// ------------------------------------------------------------------\n/** Creates user defined types and formats and provides overrides for value checking behaviours */\nexport var TypeSystem;\n(function (TypeSystem) {\n    /** Creates a new type */\n    function Type(kind, check) {\n        if (TypeRegistry.Has(kind))\n            throw new TypeSystemDuplicateTypeKind(kind);\n        TypeRegistry.Set(kind, check);\n        return (options = {}) => Unsafe({ ...options, [Kind]: kind });\n    }\n    TypeSystem.Type = Type;\n    /** Creates a new string format */\n    function Format(format, check) {\n        if (FormatRegistry.Has(format))\n            throw new TypeSystemDuplicateFormat(format);\n        FormatRegistry.Set(format, check);\n        return format;\n    }\n    TypeSystem.Format = Format;\n})(TypeSystem || (TypeSystem = {}));\n",
  "import { Kind } from '../symbols/index.mjs';\n// prettier-ignore\nexport function MappedResult(properties) {\n    return {\n        [Kind]: 'MappedResult',\n        properties\n    };\n}\n",
  "/** Returns true if this value is an async iterator */\nexport function IsAsyncIterator(value) {\n    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;\n}\n/** Returns true if this value is an array */\nexport function IsArray(value) {\n    return Array.isArray(value);\n}\n/** Returns true if this value is bigint */\nexport function IsBigInt(value) {\n    return typeof value === 'bigint';\n}\n/** Returns true if this value is a boolean */\nexport function IsBoolean(value) {\n    return typeof value === 'boolean';\n}\n/** Returns true if this value is a Date object */\nexport function IsDate(value) {\n    return value instanceof globalThis.Date;\n}\n/** Returns true if this value is a function */\nexport function IsFunction(value) {\n    return typeof value === 'function';\n}\n/** Returns true if this value is an iterator */\nexport function IsIterator(value) {\n    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;\n}\n/** Returns true if this value is null */\nexport function IsNull(value) {\n    return value === null;\n}\n/** Returns true if this value is number */\nexport function IsNumber(value) {\n    return typeof value === 'number';\n}\n/** Returns true if this value is an object */\nexport function IsObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/** Returns true if this value is RegExp */\nexport function IsRegExp(value) {\n    return value instanceof globalThis.RegExp;\n}\n/** Returns true if this value is string */\nexport function IsString(value) {\n    return typeof value === 'string';\n}\n/** Returns true if this value is symbol */\nexport function IsSymbol(value) {\n    return typeof value === 'symbol';\n}\n/** Returns true if this value is a Uint8Array */\nexport function IsUint8Array(value) {\n    return value instanceof globalThis.Uint8Array;\n}\n/** Returns true if this value is undefined */\nexport function IsUndefined(value) {\n    return value === undefined;\n}\n",
  "import * as ValueGuard from '../guard/value.mjs';\nfunction ArrayType(value) {\n    return value.map((value) => Visit(value));\n}\nfunction DateType(value) {\n    return new Date(value.getTime());\n}\nfunction Uint8ArrayType(value) {\n    return new Uint8Array(value);\n}\nfunction RegExpType(value) {\n    return new RegExp(value.source, value.flags);\n}\nfunction ObjectType(value) {\n    const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n    const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n    return { ...clonedProperties, ...clonedSymbols };\n}\n// prettier-ignore\nfunction Visit(value) {\n    return (ValueGuard.IsArray(value) ? ArrayType(value) :\n        ValueGuard.IsDate(value) ? DateType(value) :\n            ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) :\n                ValueGuard.IsRegExp(value) ? RegExpType(value) :\n                    ValueGuard.IsObject(value) ? ObjectType(value) :\n                        value);\n}\n/** Clones a value */\nexport function Clone(value) {\n    return Visit(value);\n}\n",
  "import { Clone } from './value.mjs';\n/** Clones a Rest */\nexport function CloneRest(schemas) {\n    return schemas.map((schema) => CloneType(schema));\n}\n/** Clones a Type */\nexport function CloneType(schema, options = {}) {\n    return { ...Clone(schema), ...options };\n}\n",
  "function DiscardKey(value, key) {\n    const { [key]: _, ...rest } = value;\n    return rest;\n}\nexport function Discard(value, keys) {\n    return keys.reduce((acc, key) => DiscardKey(acc, key), value);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n/** `[Json]` Creates an Array type */\nexport function Array(schema, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Array',\n        type: 'array',\n        items: CloneType(schema),\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n/** `[JavaScript]` Creates a AsyncIterator type */\nexport function AsyncIterator(items, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'AsyncIterator',\n        type: 'AsyncIterator',\n        items: CloneType(items),\n    };\n}\n",
  "import { CloneType, CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Constructor type */\nexport function Constructor(parameters, returns, options) {\n    return {\n        ...options,\n        [Kind]: 'Constructor',\n        type: 'Constructor',\n        parameters: CloneRest(parameters),\n        returns: CloneType(returns),\n    };\n}\n",
  "import { CloneType, CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Function type */\nexport function Function(parameters, returns, options) {\n    return {\n        ...options,\n        [Kind]: 'Function',\n        type: 'Function',\n        parameters: CloneRest(parameters),\n        returns: CloneType(returns),\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Never type */\nexport function Never(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Never',\n        not: {},\n    };\n}\n",
  "import * as ValueGuard from './value.mjs';\nimport { Kind, Hint, TransformKind, ReadonlyKind, OptionalKind } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nexport class TypeGuardUnknownTypeError extends TypeBoxError {\n}\nconst KnownTypes = [\n    'Any',\n    'Array',\n    'AsyncIterator',\n    'BigInt',\n    'Boolean',\n    'Constructor',\n    'Date',\n    'Enum',\n    'Function',\n    'Integer',\n    'Intersect',\n    'Iterator',\n    'Literal',\n    'MappedKey',\n    'MappedResult',\n    'Not',\n    'Null',\n    'Number',\n    'Object',\n    'Promise',\n    'Record',\n    'Ref',\n    'RegExp',\n    'String',\n    'Symbol',\n    'TemplateLiteral',\n    'This',\n    'Tuple',\n    'Undefined',\n    'Union',\n    'Uint8Array',\n    'Unknown',\n    'Void',\n];\nfunction IsPattern(value) {\n    try {\n        new RegExp(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction IsControlCharacterFree(value) {\n    if (!ValueGuard.IsString(value))\n        return false;\n    for (let i = 0; i < value.length; i++) {\n        const code = value.charCodeAt(i);\n        if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction IsAdditionalProperties(value) {\n    return IsOptionalBoolean(value) || IsSchema(value);\n}\nfunction IsOptionalBigInt(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n}\nfunction IsOptionalNumber(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n}\nfunction IsOptionalBoolean(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n}\nfunction IsOptionalString(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n}\nfunction IsOptionalPattern(value) {\n    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n}\nfunction IsOptionalFormat(value) {\n    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));\n}\nfunction IsOptionalSchema(value) {\n    return ValueGuard.IsUndefined(value) || IsSchema(value);\n}\n// ------------------------------------------------------------------\n// Modifiers\n// ------------------------------------------------------------------\n/** Returns true if this value has a Readonly symbol */\nexport function IsReadonly(value) {\n    return ValueGuard.IsObject(value) && value[ReadonlyKind] === 'Readonly';\n}\n/** Returns true if this value has a Optional symbol */\nexport function IsOptional(value) {\n    return ValueGuard.IsObject(value) && value[OptionalKind] === 'Optional';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\n/** Returns true if the given value is TAny */\nexport function IsAny(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Any') &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TArray */\nexport function IsArray(value) {\n    return (IsKindOf(value, 'Array') &&\n        value.type === 'array' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items) &&\n        IsOptionalNumber(value.minItems) &&\n        IsOptionalNumber(value.maxItems) &&\n        IsOptionalBoolean(value.uniqueItems) &&\n        IsOptionalSchema(value.contains) &&\n        IsOptionalNumber(value.minContains) &&\n        IsOptionalNumber(value.maxContains));\n}\n/** Returns true if the given value is TAsyncIterator */\nexport function IsAsyncIterator(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'AsyncIterator') &&\n        value.type === 'AsyncIterator' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items));\n}\n/** Returns true if the given value is TBigInt */\nexport function IsBigInt(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'BigInt') &&\n        value.type === 'bigint' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalBigInt(value.exclusiveMaximum) &&\n        IsOptionalBigInt(value.exclusiveMinimum) &&\n        IsOptionalBigInt(value.maximum) &&\n        IsOptionalBigInt(value.minimum) &&\n        IsOptionalBigInt(value.multipleOf));\n}\n/** Returns true if the given value is TBoolean */\nexport function IsBoolean(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Boolean') &&\n        value.type === 'boolean' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TConstructor */\nexport function IsConstructor(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Constructor') &&\n        value.type === 'Constructor' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every(schema => IsSchema(schema)) &&\n        IsSchema(value.returns));\n}\n/** Returns true if the given value is TDate */\nexport function IsDate(value) {\n    return (IsKindOf(value, 'Date') &&\n        value.type === 'Date' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximumTimestamp) &&\n        IsOptionalNumber(value.exclusiveMinimumTimestamp) &&\n        IsOptionalNumber(value.maximumTimestamp) &&\n        IsOptionalNumber(value.minimumTimestamp) &&\n        IsOptionalNumber(value.multipleOfTimestamp));\n}\n/** Returns true if the given value is TFunction */\nexport function IsFunction(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Function') &&\n        value.type === 'Function' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every(schema => IsSchema(schema)) &&\n        IsSchema(value.returns));\n}\n/** Returns true if the given value is TInteger */\nexport function IsInteger(value) {\n    return (IsKindOf(value, 'Integer') &&\n        value.type === 'integer' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximum) &&\n        IsOptionalNumber(value.exclusiveMinimum) &&\n        IsOptionalNumber(value.maximum) &&\n        IsOptionalNumber(value.minimum) &&\n        IsOptionalNumber(value.multipleOf));\n}\n/** Returns true if the given schema is TProperties */\nexport function IsProperties(value) {\n    // prettier-ignore\n    return (ValueGuard.IsObject(value) &&\n        Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema)));\n}\n/** Returns true if the given value is TIntersect */\nexport function IsIntersect(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Intersect') &&\n        (ValueGuard.IsString(value.type) && value.type !== 'object' ? false : true) &&\n        ValueGuard.IsArray(value.allOf) &&\n        value.allOf.every(schema => IsSchema(schema) && !IsTransform(schema)) &&\n        IsOptionalString(value.type) &&\n        (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TIterator */\nexport function IsIterator(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Iterator') &&\n        value.type === 'Iterator' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items));\n}\n/** Returns true if the given value is a TKind with the given name. */\nexport function IsKindOf(value, kind) {\n    return ValueGuard.IsObject(value) && Kind in value && value[Kind] === kind;\n}\n/** Returns true if the given value is TLiteral<string> */\nexport function IsLiteralString(value) {\n    return IsLiteral(value) && ValueGuard.IsString(value.const);\n}\n/** Returns true if the given value is TLiteral<number> */\nexport function IsLiteralNumber(value) {\n    return IsLiteral(value) && ValueGuard.IsNumber(value.const);\n}\n/** Returns true if the given value is TLiteral<boolean> */\nexport function IsLiteralBoolean(value) {\n    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);\n}\n/** Returns true if the given value is TLiteral */\nexport function IsLiteral(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Literal') &&\n        IsOptionalString(value.$id) && IsLiteralValue(value.const));\n}\n/** Returns true if the given value is a TLiteralValue */\nexport function IsLiteralValue(value) {\n    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);\n}\n/** Returns true if the given value is a TMappedKey */\nexport function IsMappedKey(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'MappedKey') &&\n        ValueGuard.IsArray(value.keys) &&\n        value.keys.every(key => ValueGuard.IsNumber(key) || ValueGuard.IsString(key)));\n}\n/** Returns true if the given value is TMappedResult */\nexport function IsMappedResult(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'MappedResult') &&\n        IsProperties(value.properties));\n}\n/** Returns true if the given value is TNever */\nexport function IsNever(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Never') &&\n        ValueGuard.IsObject(value.not) &&\n        Object.getOwnPropertyNames(value.not).length === 0);\n}\n/** Returns true if the given value is TNot */\nexport function IsNot(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Not') &&\n        IsSchema(value.not));\n}\n/** Returns true if the given value is TNull */\nexport function IsNull(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Null') &&\n        value.type === 'null' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TNumber */\nexport function IsNumber(value) {\n    return (IsKindOf(value, 'Number') &&\n        value.type === 'number' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximum) &&\n        IsOptionalNumber(value.exclusiveMinimum) &&\n        IsOptionalNumber(value.maximum) &&\n        IsOptionalNumber(value.minimum) &&\n        IsOptionalNumber(value.multipleOf));\n}\n/** Returns true if the given value is TObject */\nexport function IsObject(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Object') &&\n        value.type === 'object' &&\n        IsOptionalString(value.$id) &&\n        IsProperties(value.properties) &&\n        IsAdditionalProperties(value.additionalProperties) &&\n        IsOptionalNumber(value.minProperties) &&\n        IsOptionalNumber(value.maxProperties));\n}\n/** Returns true if the given value is TPromise */\nexport function IsPromise(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Promise') &&\n        value.type === 'Promise' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.item));\n}\n/** Returns true if the given value is TRecord */\nexport function IsRecord(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Record') &&\n        value.type === 'object' &&\n        IsOptionalString(value.$id) &&\n        IsAdditionalProperties(value.additionalProperties) &&\n        ValueGuard.IsObject(value.patternProperties) &&\n        ((schema) => {\n            const keys = Object.getOwnPropertyNames(schema.patternProperties);\n            return (keys.length === 1 &&\n                IsPattern(keys[0]) &&\n                ValueGuard.IsObject(schema.patternProperties) &&\n                IsSchema(schema.patternProperties[keys[0]]));\n        })(value));\n}\n/** Returns true if this value is TRecursive */\nexport function IsRecursive(value) {\n    return ValueGuard.IsObject(value) && Hint in value && value[Hint] === 'Recursive';\n}\n/** Returns true if the given value is TRef */\nexport function IsRef(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Ref') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.$ref));\n}\n/** Returns true if the given value is TRegExp */\nexport function IsRegExp(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'RegExp') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.source) &&\n        ValueGuard.IsString(value.flags));\n}\n/** Returns true if the given value is TString */\nexport function IsString(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'String') &&\n        value.type === 'string' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.minLength) &&\n        IsOptionalNumber(value.maxLength) &&\n        IsOptionalPattern(value.pattern) &&\n        IsOptionalFormat(value.format));\n}\n/** Returns true if the given value is TSymbol */\nexport function IsSymbol(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Symbol') &&\n        value.type === 'symbol' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TTemplateLiteral */\nexport function IsTemplateLiteral(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'TemplateLiteral') &&\n        value.type === 'string' &&\n        ValueGuard.IsString(value.pattern) &&\n        value.pattern[0] === '^' &&\n        value.pattern[value.pattern.length - 1] === '$');\n}\n/** Returns true if the given value is TThis */\nexport function IsThis(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'This') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.$ref));\n}\n/** Returns true of this value is TTransform */\nexport function IsTransform(value) {\n    return ValueGuard.IsObject(value) && TransformKind in value;\n}\n/** Returns true if the given value is TTuple */\nexport function IsTuple(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Tuple') &&\n        value.type === 'array' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsNumber(value.minItems) &&\n        ValueGuard.IsNumber(value.maxItems) &&\n        value.minItems === value.maxItems &&\n        (( // empty\n        ValueGuard.IsUndefined(value.items) &&\n            ValueGuard.IsUndefined(value.additionalItems) &&\n            value.minItems === 0) || (ValueGuard.IsArray(value.items) &&\n            value.items.every(schema => IsSchema(schema)))));\n}\n/** Returns true if the given value is TUndefined */\nexport function IsUndefined(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Undefined') &&\n        value.type === 'undefined' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TUnion<Literal<string | number>[]> */\nexport function IsUnionLiteral(value) {\n    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));\n}\n/** Returns true if the given value is TUnion */\nexport function IsUnion(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Union') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsObject(value) &&\n        ValueGuard.IsArray(value.anyOf) &&\n        value.anyOf.every(schema => IsSchema(schema)));\n}\n/** Returns true if the given value is TUint8Array */\nexport function IsUint8Array(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Uint8Array') &&\n        value.type === 'Uint8Array' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.minByteLength) &&\n        IsOptionalNumber(value.maxByteLength));\n}\n/** Returns true if the given value is TUnknown */\nexport function IsUnknown(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Unknown') &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is a raw TUnsafe */\nexport function IsUnsafe(value) {\n    return IsKindOf(value, 'Unsafe');\n}\n/** Returns true if the given value is TVoid */\nexport function IsVoid(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Void') &&\n        value.type === 'void' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TKind */\nexport function IsKind(value) {\n    return ValueGuard.IsObject(value) && Kind in value && ValueGuard.IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);\n}\n/** Returns true if the given value is TSchema */\nexport function IsSchema(value) {\n    // prettier-ignore\n    return (ValueGuard.IsObject(value)) && (IsAny(value) ||\n        IsArray(value) ||\n        IsBoolean(value) ||\n        IsBigInt(value) ||\n        IsAsyncIterator(value) ||\n        IsConstructor(value) ||\n        IsDate(value) ||\n        IsFunction(value) ||\n        IsInteger(value) ||\n        IsIntersect(value) ||\n        IsIterator(value) ||\n        IsLiteral(value) ||\n        IsMappedKey(value) ||\n        IsMappedResult(value) ||\n        IsNever(value) ||\n        IsNot(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsObject(value) ||\n        IsPromise(value) ||\n        IsRecord(value) ||\n        IsRef(value) ||\n        IsRegExp(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsTemplateLiteral(value) ||\n        IsThis(value) ||\n        IsTuple(value) ||\n        IsUndefined(value) ||\n        IsUnion(value) ||\n        IsUint8Array(value) ||\n        IsUnknown(value) ||\n        IsUnsafe(value) ||\n        IsVoid(value) ||\n        IsKind(value));\n}\n",
  "import { OptionalKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { OptionalFromMappedResult } from './optional-from-mapped-result.mjs';\nimport { IsMappedResult } from '../guard/type.mjs';\nfunction RemoveOptional(schema) {\n    return Discard(CloneType(schema), [OptionalKind]);\n}\nfunction AddOptional(schema) {\n    return { ...CloneType(schema), [OptionalKind]: 'Optional' };\n}\n// prettier-ignore\nfunction OptionalWithFlag(schema, F) {\n    return (F === false\n        ? RemoveOptional(schema)\n        : AddOptional(schema));\n}\n/** `[Json]` Creates a Optional property */\nexport function Optional(schema, enable) {\n    const F = enable ?? true;\n    return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Optional } from './optional.mjs';\n// prettier-ignore\nfunction FromProperties(P, F) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Optional(P[K2], F) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, F) {\n    return FromProperties(R.properties, F);\n}\n// prettier-ignore\nexport function OptionalFromMappedResult(R, F) {\n    const P = FromMappedResult(R, F);\n    return MappedResult(P);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\nimport { CloneType, CloneRest } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsObject, IsSchema } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// IntersectCreate\n// ------------------------------------------------------------------\n// prettier-ignore\nexport function IntersectCreate(T, options) {\n    const allObjects = T.every((schema) => IsObject(schema));\n    const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties)\n        ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) }\n        : {};\n    return ((options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects\n        ? { ...options, ...clonedUnevaluatedProperties, [Kind]: 'Intersect', type: 'object', allOf: CloneRest(T) }\n        : { ...options, ...clonedUnevaluatedProperties, [Kind]: 'Intersect', allOf: CloneRest(T) }));\n}\n",
  "import { OptionalKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { IntersectCreate } from './intersect-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsOptional, IsTransform, } from '../guard/type.mjs';\n// prettier-ignore\nfunction IsIntersectOptional(T) {\n    return T.every(L => IsOptional(L));\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(T) {\n    return (Discard(T, [OptionalKind]));\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(T) {\n    return T.map(L => IsOptional(L) ? RemoveOptionalFromType(L) : L);\n}\n// prettier-ignore\nfunction ResolveIntersect(T, options) {\n    return (IsIntersectOptional(T)\n        ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options))\n        : IntersectCreate(RemoveOptionalFromRest(T), options));\n}\n/** `[Json]` Creates an evaluated Intersect type */\nexport function IntersectEvaluated(T, options = {}) {\n    if (T.length === 0)\n        return Never(options);\n    if (T.length === 1)\n        return CloneType(T[0], options);\n    if (T.some((schema) => IsTransform(schema)))\n        throw new Error('Cannot intersect transform types');\n    return ResolveIntersect(T, options);\n}\n",
  "import { CloneType } from '../clone/type.mjs';\nimport { Never } from '../never/index.mjs';\nimport { IntersectCreate } from './intersect-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform } from '../guard/type.mjs';\n/** `[Json]` Creates an evaluated Intersect type */\nexport function Intersect(T, options = {}) {\n    if (T.length === 0)\n        return Never(options);\n    if (T.length === 1)\n        return CloneType(T[0], options);\n    if (T.some((schema) => IsTransform(schema)))\n        throw new Error('Cannot intersect transform types');\n    return IntersectCreate(T, options);\n}\n",
  "import { CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\nexport function UnionCreate(T, options) {\n    return { ...options, [Kind]: 'Union', anyOf: CloneRest(T) };\n}\n",
  "import { OptionalKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { UnionCreate } from './union-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional } from '../guard/type.mjs';\n// prettier-ignore\nfunction IsUnionOptional(T) {\n    return T.some(L => IsOptional(L));\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(T) {\n    return T.map(L => IsOptional(L) ? RemoveOptionalFromType(L) : L);\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(T) {\n    return (Discard(T, [OptionalKind]));\n}\n// prettier-ignore\nfunction ResolveUnion(T, options) {\n    return (IsUnionOptional(T)\n        ? Optional(UnionCreate(RemoveOptionalFromRest(T), options))\n        : UnionCreate(RemoveOptionalFromRest(T), options));\n}\n/** `[Json]` Creates an evaluated Union type */\nexport function UnionEvaluated(T, options = {}) {\n    // prettier-ignore\n    return (T.length === 0 ? Never(options) :\n        T.length === 1 ? CloneType(T[0], options) :\n            ResolveUnion(T, options));\n}\n",
  "import { Never } from '../never/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { UnionCreate } from './union-create.mjs';\n/** `[Json]` Creates a Union type */\nexport function Union(T, options = {}) {\n    // prettier-ignore\n    return (T.length === 0 ? Never(options) :\n        T.length === 1 ? CloneType(T[0], options) :\n            UnionCreate(T, options));\n}\n",
  "import { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralParserError\n// ------------------------------------------------------------------\nexport class TemplateLiteralParserError extends TypeBoxError {\n}\n// prettier-ignore\nfunction IsNonEscaped(pattern, index, char) {\n    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n}\n// prettier-ignore\nfunction IsOpenParen(pattern, index) {\n    return IsNonEscaped(pattern, index, '(');\n}\n// prettier-ignore\nfunction IsCloseParen(pattern, index) {\n    return IsNonEscaped(pattern, index, ')');\n}\n// prettier-ignore\nfunction IsSeparator(pattern, index) {\n    return IsNonEscaped(pattern, index, '|');\n}\n// prettier-ignore\nfunction IsGroup(pattern) {\n    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n        return false;\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (count === 0 && index !== pattern.length - 1)\n            return false;\n    }\n    return true;\n}\n// prettier-ignore\nfunction InGroup(pattern) {\n    return pattern.slice(1, pattern.length - 1);\n}\n// prettier-ignore\nfunction IsPrecedenceOr(pattern) {\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (IsSeparator(pattern, index) && count === 0)\n            return true;\n    }\n    return false;\n}\n// prettier-ignore\nfunction IsPrecedenceAnd(pattern) {\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            return true;\n    }\n    return false;\n}\n// prettier-ignore\nfunction Or(pattern) {\n    let [count, start] = [0, 0];\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (IsSeparator(pattern, index) && count === 0) {\n            const range = pattern.slice(start, index);\n            if (range.length > 0)\n                expressions.push(TemplateLiteralParse(range));\n            start = index + 1;\n        }\n    }\n    const range = pattern.slice(start);\n    if (range.length > 0)\n        expressions.push(TemplateLiteralParse(range));\n    if (expressions.length === 0)\n        return { type: 'const', const: '' };\n    if (expressions.length === 1)\n        return expressions[0];\n    return { type: 'or', expr: expressions };\n}\n// prettier-ignore\nfunction And(pattern) {\n    function Group(value, index) {\n        if (!IsOpenParen(value, index))\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n        let count = 0;\n        for (let scan = index; scan < value.length; scan++) {\n            if (IsOpenParen(value, scan))\n                count += 1;\n            if (IsCloseParen(value, scan))\n                count -= 1;\n            if (count === 0)\n                return [index, scan];\n        }\n        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n    }\n    function Range(pattern, index) {\n        for (let scan = index; scan < pattern.length; scan++) {\n            if (IsOpenParen(pattern, scan))\n                return [index, scan];\n        }\n        return [index, pattern.length];\n    }\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index)) {\n            const [start, end] = Group(pattern, index);\n            const range = pattern.slice(start, end + 1);\n            expressions.push(TemplateLiteralParse(range));\n            index = end;\n        }\n        else {\n            const [start, end] = Range(pattern, index);\n            const range = pattern.slice(start, end);\n            if (range.length > 0)\n                expressions.push(TemplateLiteralParse(range));\n            index = end - 1;\n        }\n    }\n    return ((expressions.length === 0) ? { type: 'const', const: '' } :\n        (expressions.length === 1) ? expressions[0] :\n            { type: 'and', expr: expressions });\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParse\n// ------------------------------------------------------------------\n/** Parses a pattern and returns an expression tree */\nexport function TemplateLiteralParse(pattern) {\n    // prettier-ignore\n    return (IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) :\n        IsPrecedenceOr(pattern) ? Or(pattern) :\n            IsPrecedenceAnd(pattern) ? And(pattern) :\n                { type: 'const', const: pattern });\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParseExact\n// ------------------------------------------------------------------\n/** Parses a pattern and strips forward and trailing ^ and $ */\nexport function TemplateLiteralParseExact(pattern) {\n    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));\n}\n",
  "import { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralFiniteError\n// ------------------------------------------------------------------\nexport class TemplateLiteralFiniteError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralFiniteCheck\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsNumberExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === '0' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === '[1-9][0-9]*');\n}\n// prettier-ignore\nfunction IsBooleanExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === 'true' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === 'false');\n}\n// prettier-ignore\nfunction IsStringExpression(expression) {\n    return expression.type === 'const' && expression.const === '.*';\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralExpressionFinite\n// ------------------------------------------------------------------\n// prettier-ignore\nexport function IsTemplateLiteralExpressionFinite(expression) {\n    return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :\n        IsBooleanExpression(expression) ? true :\n            (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                    (expression.type === 'const') ? true :\n                        (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());\n}\n/** Returns true if this TemplateLiteral resolves to a finite set of values */\nexport function IsTemplateLiteralFinite(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    return IsTemplateLiteralExpressionFinite(expression);\n}\n",
  "import { IsTemplateLiteralExpressionFinite } from './finite.mjs';\nimport { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nexport class TemplateLiteralGenerateError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n    if (buffer.length === 1)\n        return yield* buffer[0];\n    for (const left of buffer[0]) {\n        for (const right of GenerateReduce(buffer.slice(1))) {\n            yield `${left}${right}`;\n        }\n    }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n    for (const expr of expression.expr)\n        yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n    return yield expression.const;\n}\nexport function* TemplateLiteralExpressionGenerate(expression) {\n    return expression.type === 'and'\n        ? yield* GenerateAnd(expression)\n        : expression.type === 'or'\n            ? yield* GenerateOr(expression)\n            : expression.type === 'const'\n                ? yield* GenerateConst(expression)\n                : (() => {\n                    throw new TemplateLiteralGenerateError('Unknown expression');\n                })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nexport function TemplateLiteralGenerate(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    // prettier-ignore\n    return (IsTemplateLiteralExpressionFinite(expression)\n        ? [...TemplateLiteralExpressionGenerate(expression)]\n        : []);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Literal type */\nexport function Literal(value, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Literal',\n        const: value,\n        type: typeof value,\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Boolean type */\nexport function Boolean(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Boolean',\n        type: 'boolean',\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a BigInt type */\nexport function BigInt(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'BigInt',\n        type: 'bigint',\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Number type */\nexport function Number(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Number',\n        type: 'number',\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a String type */\nexport function String(options = {}) {\n    return { ...options, [Kind]: 'String', type: 'string' };\n}\n",
  "import { Literal } from '../literal/index.mjs';\nimport { Boolean } from '../boolean/index.mjs';\nimport { BigInt } from '../bigint/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\n// ------------------------------------------------------------------\n// SyntaxParsers\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* FromUnion(syntax) {\n    const trim = syntax.trim().replace(/\"|'/g, '');\n    return (trim === 'boolean' ? yield Boolean() :\n        trim === 'number' ? yield Number() :\n            trim === 'bigint' ? yield BigInt() :\n                trim === 'string' ? yield String() :\n                    yield (() => {\n                        const literals = trim.split('|').map((literal) => Literal(literal.trim()));\n                        return (literals.length === 0 ? Never() :\n                            literals.length === 1 ? literals[0] :\n                                UnionEvaluated(literals));\n                    })());\n}\n// prettier-ignore\nfunction* FromTerminal(syntax) {\n    if (syntax[1] !== '{') {\n        const L = Literal('$');\n        const R = FromSyntax(syntax.slice(1));\n        return yield* [L, ...R];\n    }\n    for (let i = 2; i < syntax.length; i++) {\n        if (syntax[i] === '}') {\n            const L = FromUnion(syntax.slice(2, i));\n            const R = FromSyntax(syntax.slice(i + 1));\n            return yield* [...L, ...R];\n        }\n    }\n    yield Literal(syntax);\n}\n// prettier-ignore\nfunction* FromSyntax(syntax) {\n    for (let i = 0; i < syntax.length; i++) {\n        if (syntax[i] === '$') {\n            const L = Literal(syntax.slice(0, i));\n            const R = FromTerminal(syntax.slice(i));\n            return yield* [L, ...R];\n        }\n    }\n    yield Literal(syntax);\n}\n/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */\nexport function TemplateLiteralSyntax(syntax) {\n    return [...FromSyntax(syntax)];\n}\n",
  "export const PatternBoolean = '(true|false)';\nexport const PatternNumber = '(0|[1-9][0-9]*)';\nexport const PatternString = '(.*)';\nexport const PatternBooleanExact = `^${PatternBoolean}$`;\nexport const PatternNumberExact = `^${PatternNumber}$`;\nexport const PatternStringExact = `^${PatternString}$`;\n",
  "export const PatternBoolean = '(true|false)';\nexport const PatternNumber = '(0|[1-9][0-9]*)';\nexport const PatternString = '(.*)';\nexport const PatternBooleanExact = `^${PatternBoolean}$`;\nexport const PatternNumberExact = `^${PatternNumber}$`;\nexport const PatternStringExact = `^${PatternString}$`;\n",
  "import { PatternNumber, PatternString, PatternBoolean } from '../patterns/index.mjs';\nimport { Kind } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsTemplateLiteral, IsUnion, IsNumber, IsInteger, IsBigInt, IsString, IsLiteral, IsBoolean } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralPatternError\n// ------------------------------------------------------------------\nexport class TemplateLiteralPatternError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralPattern\n// ------------------------------------------------------------------\nfunction Escape(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n// prettier-ignore\nfunction Visit(schema, acc) {\n    return (IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :\n        IsUnion(schema) ? `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})` :\n            IsNumber(schema) ? `${acc}${PatternNumber}` :\n                IsInteger(schema) ? `${acc}${PatternNumber}` :\n                    IsBigInt(schema) ? `${acc}${PatternNumber}` :\n                        IsString(schema) ? `${acc}${PatternString}` :\n                            IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` :\n                                IsBoolean(schema) ? `${acc}${PatternBoolean}` :\n                                    (() => { throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`); })());\n}\nexport function TemplateLiteralPattern(kinds) {\n    return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n}\n",
  "import { Union } from '../union/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { TemplateLiteralGenerate } from './generate.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralToUnion\n// ------------------------------------------------------------------\n/** Returns a Union from the given TemplateLiteral */\nexport function TemplateLiteralToUnion(schema) {\n    const R = TemplateLiteralGenerate(schema);\n    const L = R.map((S) => Literal(S));\n    return Union(L);\n}\n",
  "import { TemplateLiteralSyntax } from './syntax.mjs';\nimport { TemplateLiteralPattern } from './pattern.mjs';\nimport { IsString } from '../guard/value.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a TemplateLiteral type */\n// prettier-ignore\nexport function TemplateLiteral(unresolved, options = {}) {\n    const pattern = IsString(unresolved)\n        ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))\n        : TemplateLiteralPattern(unresolved);\n    return { ...options, [Kind]: 'TemplateLiteral', type: 'string', pattern };\n}\n",
  "import { TemplateLiteralGenerate } from '../template-literal/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTemplateLiteral, IsUnion, IsLiteral, IsNumber, IsInteger } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromTemplateLiteral(T) {\n    const R = TemplateLiteralGenerate(T);\n    return R.map(S => S.toString());\n}\n// prettier-ignore\nfunction FromUnion(T) {\n    return T.reduce((Acc, L) => {\n        return [...Acc, ...IndexPropertyKeys(L)];\n    }, []);\n}\n// prettier-ignore\nfunction FromLiteral(T) {\n    return ([T.toString()] // TS 5.4 observes TLiteralValue as not having a toString()\n    );\n}\n/** Returns a tuple of PropertyKeys derived from the given TSchema */\n// prettier-ignore\nexport function IndexPropertyKeys(T) {\n    return [...new Set((IsTemplateLiteral(T) ? FromTemplateLiteral(T) :\n            IsUnion(T) ? FromUnion(T.anyOf) :\n                IsLiteral(T) ? FromLiteral(T.const) :\n                    IsNumber(T) ? ['[number]'] :\n                        IsInteger(T) ? ['[number]'] :\n                            []))];\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { IndexPropertyKeys } from './indexed-property-keys.mjs';\nimport { Index } from './index.mjs';\n// prettier-ignore\nfunction FromProperties(T, P, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(T, R, options) {\n    return FromProperties(T, R.properties, options);\n}\n// prettier-ignore\nexport function IndexFromMappedResult(T, R, options) {\n    const P = FromMappedResult(T, R, options);\n    return MappedResult(P);\n}\n",
  "import { Never } from '../never/index.mjs';\nimport { IntersectEvaluated } from '../intersect/index.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { IndexPropertyKeys } from './indexed-property-keys.mjs';\nimport { IndexFromMappedKey } from './indexed-from-mapped-key.mjs';\nimport { IndexFromMappedResult } from './indexed-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsIntersect, IsObject, IsMappedKey, IsMappedResult, IsNever, IsSchema, IsTuple, IsUnion } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T, K) {\n    return T.map(L => FromKey(L, K));\n}\n// prettier-ignore\nfunction FromIntersectRest(T) {\n    return T.filter(L => !IsNever(L));\n}\n// prettier-ignore\nfunction FromIntersect(T, K) {\n    return (IntersectEvaluated(FromIntersectRest(FromRest(T, K))));\n}\n// prettier-ignore\nfunction FromUnionRest(T) {\n    return T; // review this\n}\n// prettier-ignore\nfunction FromUnion(T, K) {\n    return (UnionEvaluated(FromUnionRest(FromRest(T, K))));\n}\n// prettier-ignore\nfunction FromTuple(T, K) {\n    return (K in T ? T[K] :\n        K === '[number]' ? UnionEvaluated(T) :\n            Never());\n}\n// prettier-ignore\nfunction FromArray(T, K) {\n    return (K === '[number]'\n        ? T\n        : Never());\n}\n// prettier-ignore\nfunction FromProperty(T, K) {\n    return (K in T ? T[K] : Never());\n}\n// prettier-ignore\nfunction FromKey(T, K) {\n    return (IsIntersect(T) ? FromIntersect(T.allOf, K) :\n        IsUnion(T) ? FromUnion(T.anyOf, K) :\n            IsTuple(T) ? FromTuple(T.items ?? [], K) :\n                IsArray(T) ? FromArray(T.items, K) :\n                    IsObject(T) ? FromProperty(T.properties, K) :\n                        Never());\n}\n// prettier-ignore\nfunction FromKeys(T, K) {\n    return K.map(L => FromKey(T, L));\n}\n// prettier-ignore\nfunction FromSchema(T, K) {\n    return (UnionEvaluated(FromKeys(T, K)));\n}\n/** `[Json]` Returns an Indexed property type for the given keys */\nexport function Index(T, K, options = {}) {\n    // prettier-ignore\n    return (IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) :\n        IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) :\n            IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) :\n                CloneType(FromSchema(T, K), options));\n}\n",
  "import { Index } from './indexed.mjs';\nimport { MappedResult } from '../mapped/index.mjs';\n// prettier-ignore\nfunction MappedIndexPropertyKey(T, K, options) {\n    return { [K]: Index(T, [K], options) };\n}\n// prettier-ignore\nfunction MappedIndexPropertyKeys(T, K, options) {\n    return K.reduce((Acc, L) => {\n        return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };\n    }, {});\n}\n// prettier-ignore\nfunction MappedIndexProperties(T, K, options) {\n    return MappedIndexPropertyKeys(T, K.keys, options);\n}\n// prettier-ignore\nexport function IndexFromMappedKey(T, K, options) {\n    const P = MappedIndexProperties(T, K, options);\n    return MappedResult(P);\n}\n",
  "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates an Iterator type */\nexport function Iterator(items, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Iterator',\n        type: 'Iterator',\n        items: CloneType(items),\n    };\n}\n",
  "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional, IsSchema } from '../guard/type.mjs';\n/** `[Json]` Creates an Object type */\nexport function _Object(properties, options = {}) {\n    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n    const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));\n    const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n    const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};\n    const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});\n    return (requiredKeys.length > 0\n        ? { ...options, ...clonedAdditionalProperties, [Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys }\n        : { ...options, ...clonedAdditionalProperties, [Kind]: 'Object', type: 'object', properties: clonedProperties });\n}\n/** `[Json]` Creates an Object type */\nexport const Object = _Object;\n",
  "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Promise type */\nexport function Promise(item, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Promise',\n        type: 'Promise',\n        item: CloneType(item),\n    };\n}\n",
  "import { ReadonlyKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { ReadonlyFromMappedResult } from './readonly-from-mapped-result.mjs';\nimport { IsMappedResult } from '../guard/type.mjs';\nfunction RemoveReadonly(schema) {\n    return Discard(CloneType(schema), [ReadonlyKind]);\n}\nfunction AddReadonly(schema) {\n    return { ...CloneType(schema), [ReadonlyKind]: 'Readonly' };\n}\n// prettier-ignore\nfunction ReadonlyWithFlag(schema, F) {\n    return (F === false\n        ? RemoveReadonly(schema)\n        : AddReadonly(schema));\n}\n/** `[Json]` Creates a Readonly property */\nexport function Readonly(schema, enable) {\n    const F = enable ?? true;\n    return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Readonly } from './readonly.mjs';\n// prettier-ignore\nfunction FromProperties(K, F) {\n    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Readonly(K[K2], F) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, F) {\n    return FromProperties(R.properties, F);\n}\n// prettier-ignore\nexport function ReadonlyFromMappedResult(R, F) {\n    const P = FromMappedResult(R, F);\n    return MappedResult(P);\n}\n",
  "import { CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Tuple type */\nexport function Tuple(items, options = {}) {\n    // return TupleResolver.Resolve(T)\n    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n    // prettier-ignore\n    return (items.length > 0 ?\n        { ...options, [Kind]: 'Tuple', type: 'array', items: CloneRest(items), additionalItems, minItems, maxItems } :\n        { ...options, [Kind]: 'Tuple', type: 'array', minItems, maxItems });\n}\n",
  "/** Returns true if element S is in the set of T */\n// prettier-ignore\nexport function SetIncludes(T, S) {\n    return T.includes(S);\n}\n/** Returns true if T is a subset of S */\nexport function SetIsSubset(T, S) {\n    return T.every((L) => SetIncludes(S, L));\n}\n/** Returns a distinct set of elements */\nexport function SetDistinct(T) {\n    return [...new Set(T)];\n}\n/** Returns the Intersect of the given sets */\nexport function SetIntersect(T, S) {\n    return T.filter((L) => S.includes(L));\n}\n/** Returns the Union of the given sets */\nexport function SetUnion(T, S) {\n    return [...T, ...S];\n}\n/** Returns the Complement by omitting elements in T that are in S */\n// prettier-ignore\nexport function SetComplement(T, S) {\n    return T.filter(L => !S.includes(L));\n}\n/** Returns the Intersect of multiple sets */\n// prettier-ignore\nexport function SetIntersectMany(T) {\n    return (T.length === 1 ? T[0] : T.reduce((Acc, L) => [...SetIntersect(Acc, L)], []));\n}\n/** Returns the Union of multiple sets */\nexport function SetUnionMany(T) {\n    return T.reduce((Acc, L) => [...Acc, ...L], []);\n}\n",
  "/** Returns true if element S is in the set of T */\n// prettier-ignore\nexport function SetIncludes(T, S) {\n    return T.includes(S);\n}\n/** Returns true if T is a subset of S */\nexport function SetIsSubset(T, S) {\n    return T.every((L) => SetIncludes(S, L));\n}\n/** Returns a distinct set of elements */\nexport function SetDistinct(T) {\n    return [...new Set(T)];\n}\n/** Returns the Intersect of the given sets */\nexport function SetIntersect(T, S) {\n    return T.filter((L) => S.includes(L));\n}\n/** Returns the Union of the given sets */\nexport function SetUnion(T, S) {\n    return [...T, ...S];\n}\n/** Returns the Complement by omitting elements in T that are in S */\n// prettier-ignore\nexport function SetComplement(T, S) {\n    return T.filter(L => !S.includes(L));\n}\n/** Returns the Intersect of multiple sets */\n// prettier-ignore\nexport function SetIntersectMany(T) {\n    return (T.length === 1 ? T[0] : T.reduce((Acc, L) => [...SetIntersect(Acc, L)], []));\n}\n/** Returns the Union of multiple sets */\nexport function SetUnionMany(T) {\n    return T.reduce((Acc, L) => [...Acc, ...L], []);\n}\n",
  "/** Returns true if element S is in the set of T */\n// prettier-ignore\nexport function SetIncludes(T, S) {\n    return T.includes(S);\n}\n/** Returns true if T is a subset of S */\nexport function SetIsSubset(T, S) {\n    return T.every((L) => SetIncludes(S, L));\n}\n/** Returns a distinct set of elements */\nexport function SetDistinct(T) {\n    return [...new Set(T)];\n}\n/** Returns the Intersect of the given sets */\nexport function SetIntersect(T, S) {\n    return T.filter((L) => S.includes(L));\n}\n/** Returns the Union of the given sets */\nexport function SetUnion(T, S) {\n    return [...T, ...S];\n}\n/** Returns the Complement by omitting elements in T that are in S */\n// prettier-ignore\nexport function SetComplement(T, S) {\n    return T.filter(L => !S.includes(L));\n}\n/** Returns the Intersect of multiple sets */\n// prettier-ignore\nexport function SetIntersectMany(T) {\n    return (T.length === 1 ? T[0] : T.reduce((Acc, L) => [...SetIntersect(Acc, L)], []));\n}\n/** Returns the Union of multiple sets */\nexport function SetUnionMany(T) {\n    return T.reduce((Acc, L) => [...Acc, ...L], []);\n}\n",
  "import { Kind, OptionalKind, ReadonlyKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\n// evaluation types\nimport { Array } from '../array/index.mjs';\nimport { AsyncIterator } from '../async-iterator/index.mjs';\nimport { Constructor } from '../constructor/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Iterator } from '../iterator/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { Promise } from '../promise/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Union } from '../union/index.mjs';\n// operator\nimport { SetIncludes } from '../sets/index.mjs';\n// mapping types\nimport { MappedResult } from './mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsArray, IsAsyncIterator, IsConstructor, IsFunction, IsIntersect, IsIterator, IsReadonly, IsMappedResult, IsMappedKey, IsObject, IsOptional, IsPromise, IsSchema, IsTuple, IsUnion, } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromMappedResult(K, P) {\n    return (K in P\n        ? FromSchemaType(K, P[K])\n        : MappedResult(P));\n}\n// prettier-ignore\nfunction MappedKeyToKnownMappedResultProperties(K) {\n    return { [K]: Literal(K) };\n}\n// prettier-ignore\nfunction MappedKeyToUnknownMappedResultProperties(P) {\n    return P.reduce((Acc, L) => {\n        return { ...Acc, [L]: Literal(L) };\n    }, {});\n}\n// prettier-ignore\nfunction MappedKeyToMappedResultProperties(K, P) {\n    return (SetIncludes(P, K)\n        ? MappedKeyToKnownMappedResultProperties(K)\n        : MappedKeyToUnknownMappedResultProperties(P));\n}\n// prettier-ignore\nfunction FromMappedKey(K, P) {\n    const R = MappedKeyToMappedResultProperties(K, P);\n    return FromMappedResult(K, R);\n}\n// prettier-ignore\nfunction FromRest(K, T) {\n    return T.map(L => FromSchemaType(K, L));\n}\n// prettier-ignore\nfunction FromProperties(K, T) {\n    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };\n    }, {});\n}\n// prettier-ignore\nfunction FromSchemaType(K, T) {\n    return (\n    // unevaluated modifier types\n    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) :\n        IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) :\n            // unevaluated mapped types\n            IsMappedResult(T) ? FromMappedResult(K, T.properties) :\n                IsMappedKey(T) ? FromMappedKey(K, T.keys) :\n                    // unevaluated types\n                    IsConstructor(T) ? Constructor(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) :\n                        IsFunction(T) ? FunctionType(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) :\n                            IsAsyncIterator(T) ? AsyncIterator(FromSchemaType(K, T.items)) :\n                                IsIterator(T) ? Iterator(FromSchemaType(K, T.items)) :\n                                    IsIntersect(T) ? Intersect(FromRest(K, T.allOf)) :\n                                        IsUnion(T) ? Union(FromRest(K, T.anyOf)) :\n                                            IsTuple(T) ? Tuple(FromRest(K, T.items ?? [])) :\n                                                IsObject(T) ? Object(FromProperties(K, T.properties)) :\n                                                    IsArray(T) ? Array(FromSchemaType(K, T.items)) :\n                                                        IsPromise(T) ? Promise(FromSchemaType(K, T.item)) :\n                                                            T);\n}\n// prettier-ignore\nfunction FromMappedFunctionReturnType(K, T, Acc = {}) {\n    return K.reduce((Acc, L) => {\n        return { ...Acc, [L]: FromSchemaType(L, T) };\n    }, {});\n}\n/** `[Json]` Creates a Mapped object type */\nexport function Mapped(key, map, options = {}) {\n    const K = IsSchema(key) ? IndexPropertyKeys(key) : key;\n    const RT = map({ [Kind]: 'MappedKey', keys: K });\n    const R = FromMappedFunctionReturnType(K, RT);\n    return CloneType(Object(R), options);\n}\n",
  "import { SetUnionMany, SetIntersectMany } from '../sets/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsTuple, IsArray, IsObject, IsRecord } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T) {\n    return T.reduce((Acc, L) => {\n        return [...Acc, KeyOfPropertyKeys(L)];\n    }, []);\n}\n// prettier-ignore\nfunction FromIntersect(T) {\n    const C = FromRest(T);\n    const R = SetUnionMany(C);\n    return R;\n}\n// prettier-ignore\nfunction FromUnion(T) {\n    const C = FromRest(T);\n    const R = SetIntersectMany(C);\n    return R;\n}\n// prettier-ignore\nfunction FromTuple(T) {\n    return T.map((_, I) => I.toString());\n}\n// prettier-ignore\nfunction FromArray(_) {\n    return (['[number]']);\n}\n// prettier-ignore\nfunction FromProperties(T) {\n    return (globalThis.Object.getOwnPropertyNames(T));\n}\n// ------------------------------------------------------------------\n// FromPatternProperties\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPatternProperties(patternProperties) {\n    if (!includePatternProperties)\n        return [];\n    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);\n    return patternPropertyKeys.map(key => {\n        return (key[0] === '^' && key[key.length - 1] === '$')\n            ? key.slice(1, key.length - 1)\n            : key;\n    });\n}\n/** Returns a tuple of PropertyKeys derived from the given TSchema. */\n// prettier-ignore\nexport function KeyOfPropertyKeys(T) {\n    return (IsIntersect(T) ? FromIntersect(T.allOf) :\n        IsUnion(T) ? FromUnion(T.anyOf) :\n            IsTuple(T) ? FromTuple(T.items ?? []) :\n                IsArray(T) ? FromArray(T.items) :\n                    IsObject(T) ? FromProperties(T.properties) :\n                        IsRecord(T) ? FromPatternProperties(T.patternProperties) :\n                            []);\n}\n// ----------------------------------------------------------------\n// KeyOfPattern\n// ----------------------------------------------------------------\nlet includePatternProperties = false;\n/** Returns a regular expression pattern derived from the given TSchema */\nexport function KeyOfPattern(schema) {\n    includePatternProperties = true;\n    const keys = KeyOfPropertyKeys(schema);\n    includePatternProperties = false;\n    const pattern = keys.map((key) => `(${key})`);\n    return `^(${pattern.join('|')})$`;\n}\n",
  "import { Literal } from '../literal/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { KeyOfPropertyKeys } from './keyof-property-keys.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { KeyOfFromMappedResult } from './keyof-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromPropertyKeys(T) {\n    return T.map(L => L === '[number]' ? Number() : Literal(L));\n}\n/** `[Json]` Creates a KeyOf type */\nexport function KeyOf(T, options = {}) {\n    if (IsMappedResult(T)) {\n        return KeyOfFromMappedResult(T, options);\n    }\n    else {\n        const K = KeyOfPropertyKeys(T);\n        const S = FromPropertyKeys(K);\n        const U = UnionEvaluated(S);\n        return CloneType(U, options);\n    }\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { KeyOf } from './keyof.mjs';\n// prettier-ignore\nfunction FromProperties(K, options) {\n    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: KeyOf(K[K2], options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, options) {\n    return FromProperties(R.properties, options);\n}\n// prettier-ignore\nexport function KeyOfFromMappedResult(R, options) {\n    const P = FromMappedResult(R, options);\n    return MappedResult(P);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** Fast undefined check used for properties of type undefined */\nfunction Intersect(schema) {\n    return schema.allOf.every((schema) => ExtendsUndefinedCheck(schema));\n}\nfunction Union(schema) {\n    return schema.anyOf.some((schema) => ExtendsUndefinedCheck(schema));\n}\nfunction Not(schema) {\n    return !ExtendsUndefinedCheck(schema.not);\n}\n/** Fast undefined check used for properties of type undefined */\n// prettier-ignore\nexport function ExtendsUndefinedCheck(schema) {\n    return (schema[Kind] === 'Intersect' ? Intersect(schema) :\n        schema[Kind] === 'Union' ? Union(schema) :\n            schema[Kind] === 'Not' ? Not(schema) :\n                schema[Kind] === 'Undefined' ? true :\n                    false);\n}\n",
  "import { Kind } from '../type/symbols/index.mjs';\nimport { ValueErrorType } from './errors.mjs';\n/** Creates an error message using en-US as the default locale */\nexport function DefaultErrorFunction(error) {\n    switch (error.errorType) {\n        case ValueErrorType.ArrayContains:\n            return 'Expected array to contain at least one matching value';\n        case ValueErrorType.ArrayMaxContains:\n            return `Expected array to contain no more than ${error.schema.maxContains} matching values`;\n        case ValueErrorType.ArrayMinContains:\n            return `Expected array to contain at least ${error.schema.minContains} matching values`;\n        case ValueErrorType.ArrayMaxItems:\n            return `Expected array length to be less or equal to ${error.schema.maxItems}`;\n        case ValueErrorType.ArrayMinItems:\n            return `Expected array length to be greater or equal to ${error.schema.minItems}`;\n        case ValueErrorType.ArrayUniqueItems:\n            return 'Expected array elements to be unique';\n        case ValueErrorType.Array:\n            return 'Expected array';\n        case ValueErrorType.AsyncIterator:\n            return 'Expected AsyncIterator';\n        case ValueErrorType.BigIntExclusiveMaximum:\n            return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.BigIntExclusiveMinimum:\n            return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.BigIntMaximum:\n            return `Expected bigint to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.BigIntMinimum:\n            return `Expected bigint to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.BigIntMultipleOf:\n            return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.BigInt:\n            return 'Expected bigint';\n        case ValueErrorType.Boolean:\n            return 'Expected boolean';\n        case ValueErrorType.DateExclusiveMinimumTimestamp:\n            return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;\n        case ValueErrorType.DateExclusiveMaximumTimestamp:\n            return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;\n        case ValueErrorType.DateMinimumTimestamp:\n            return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;\n        case ValueErrorType.DateMaximumTimestamp:\n            return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;\n        case ValueErrorType.DateMultipleOfTimestamp:\n            return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;\n        case ValueErrorType.Date:\n            return 'Expected Date';\n        case ValueErrorType.Function:\n            return 'Expected function';\n        case ValueErrorType.IntegerExclusiveMaximum:\n            return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.IntegerExclusiveMinimum:\n            return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.IntegerMaximum:\n            return `Expected integer to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.IntegerMinimum:\n            return `Expected integer to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.IntegerMultipleOf:\n            return `Expected integer to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.Integer:\n            return 'Expected integer';\n        case ValueErrorType.IntersectUnevaluatedProperties:\n            return 'Unexpected property';\n        case ValueErrorType.Intersect:\n            return 'Expected all values to match';\n        case ValueErrorType.Iterator:\n            return 'Expected Iterator';\n        case ValueErrorType.Literal:\n            return `Expected ${typeof error.schema.const === 'string' ? `'${error.schema.const}'` : error.schema.const}`;\n        case ValueErrorType.Never:\n            return 'Never';\n        case ValueErrorType.Not:\n            return 'Value should not match';\n        case ValueErrorType.Null:\n            return 'Expected null';\n        case ValueErrorType.NumberExclusiveMaximum:\n            return `Expected number to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.NumberExclusiveMinimum:\n            return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.NumberMaximum:\n            return `Expected number to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.NumberMinimum:\n            return `Expected number to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.NumberMultipleOf:\n            return `Expected number to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.Number:\n            return 'Expected number';\n        case ValueErrorType.Object:\n            return 'Expected object';\n        case ValueErrorType.ObjectAdditionalProperties:\n            return 'Unexpected property';\n        case ValueErrorType.ObjectMaxProperties:\n            return `Expected object to have no more than ${error.schema.maxProperties} properties`;\n        case ValueErrorType.ObjectMinProperties:\n            return `Expected object to have at least ${error.schema.minProperties} properties`;\n        case ValueErrorType.ObjectRequiredProperty:\n            return 'Required property';\n        case ValueErrorType.Promise:\n            return 'Expected Promise';\n        case ValueErrorType.RegExp:\n            return 'Expected string to match regular expression';\n        case ValueErrorType.StringFormatUnknown:\n            return `Unknown format '${error.schema.format}'`;\n        case ValueErrorType.StringFormat:\n            return `Expected string to match '${error.schema.format}' format`;\n        case ValueErrorType.StringMaxLength:\n            return `Expected string length less or equal to ${error.schema.maxLength}`;\n        case ValueErrorType.StringMinLength:\n            return `Expected string length greater or equal to ${error.schema.minLength}`;\n        case ValueErrorType.StringPattern:\n            return `Expected string to match '${error.schema.pattern}'`;\n        case ValueErrorType.String:\n            return 'Expected string';\n        case ValueErrorType.Symbol:\n            return 'Expected symbol';\n        case ValueErrorType.TupleLength:\n            return `Expected tuple to have ${error.schema.maxItems || 0} elements`;\n        case ValueErrorType.Tuple:\n            return 'Expected tuple';\n        case ValueErrorType.Uint8ArrayMaxByteLength:\n            return `Expected byte length less or equal to ${error.schema.maxByteLength}`;\n        case ValueErrorType.Uint8ArrayMinByteLength:\n            return `Expected byte length greater or equal to ${error.schema.minByteLength}`;\n        case ValueErrorType.Uint8Array:\n            return 'Expected Uint8Array';\n        case ValueErrorType.Undefined:\n            return 'Expected undefined';\n        case ValueErrorType.Union:\n            return 'Expected union value';\n        case ValueErrorType.Void:\n            return 'Expected void';\n        case ValueErrorType.Kind:\n            return `Expected kind '${error.schema[Kind]}'`;\n        default:\n            return 'Unknown error type';\n    }\n}\n/** Manages error message providers */\nlet errorFunction = DefaultErrorFunction;\n/** Sets the error function used to generate error messages. */\nexport function SetErrorFunction(callback) {\n    errorFunction = callback;\n}\n/** Gets the error function used to generate error messages */\nexport function GetErrorFunction() {\n    return errorFunction;\n}\n",
  "import { Kind } from '../type/symbols/index.mjs';\nimport { ValueErrorType } from './errors.mjs';\n/** Creates an error message using en-US as the default locale */\nexport function DefaultErrorFunction(error) {\n    switch (error.errorType) {\n        case ValueErrorType.ArrayContains:\n            return 'Expected array to contain at least one matching value';\n        case ValueErrorType.ArrayMaxContains:\n            return `Expected array to contain no more than ${error.schema.maxContains} matching values`;\n        case ValueErrorType.ArrayMinContains:\n            return `Expected array to contain at least ${error.schema.minContains} matching values`;\n        case ValueErrorType.ArrayMaxItems:\n            return `Expected array length to be less or equal to ${error.schema.maxItems}`;\n        case ValueErrorType.ArrayMinItems:\n            return `Expected array length to be greater or equal to ${error.schema.minItems}`;\n        case ValueErrorType.ArrayUniqueItems:\n            return 'Expected array elements to be unique';\n        case ValueErrorType.Array:\n            return 'Expected array';\n        case ValueErrorType.AsyncIterator:\n            return 'Expected AsyncIterator';\n        case ValueErrorType.BigIntExclusiveMaximum:\n            return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.BigIntExclusiveMinimum:\n            return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.BigIntMaximum:\n            return `Expected bigint to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.BigIntMinimum:\n            return `Expected bigint to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.BigIntMultipleOf:\n            return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.BigInt:\n            return 'Expected bigint';\n        case ValueErrorType.Boolean:\n            return 'Expected boolean';\n        case ValueErrorType.DateExclusiveMinimumTimestamp:\n            return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;\n        case ValueErrorType.DateExclusiveMaximumTimestamp:\n            return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;\n        case ValueErrorType.DateMinimumTimestamp:\n            return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;\n        case ValueErrorType.DateMaximumTimestamp:\n            return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;\n        case ValueErrorType.DateMultipleOfTimestamp:\n            return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;\n        case ValueErrorType.Date:\n            return 'Expected Date';\n        case ValueErrorType.Function:\n            return 'Expected function';\n        case ValueErrorType.IntegerExclusiveMaximum:\n            return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.IntegerExclusiveMinimum:\n            return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.IntegerMaximum:\n            return `Expected integer to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.IntegerMinimum:\n            return `Expected integer to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.IntegerMultipleOf:\n            return `Expected integer to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.Integer:\n            return 'Expected integer';\n        case ValueErrorType.IntersectUnevaluatedProperties:\n            return 'Unexpected property';\n        case ValueErrorType.Intersect:\n            return 'Expected all values to match';\n        case ValueErrorType.Iterator:\n            return 'Expected Iterator';\n        case ValueErrorType.Literal:\n            return `Expected ${typeof error.schema.const === 'string' ? `'${error.schema.const}'` : error.schema.const}`;\n        case ValueErrorType.Never:\n            return 'Never';\n        case ValueErrorType.Not:\n            return 'Value should not match';\n        case ValueErrorType.Null:\n            return 'Expected null';\n        case ValueErrorType.NumberExclusiveMaximum:\n            return `Expected number to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.NumberExclusiveMinimum:\n            return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.NumberMaximum:\n            return `Expected number to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.NumberMinimum:\n            return `Expected number to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.NumberMultipleOf:\n            return `Expected number to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.Number:\n            return 'Expected number';\n        case ValueErrorType.Object:\n            return 'Expected object';\n        case ValueErrorType.ObjectAdditionalProperties:\n            return 'Unexpected property';\n        case ValueErrorType.ObjectMaxProperties:\n            return `Expected object to have no more than ${error.schema.maxProperties} properties`;\n        case ValueErrorType.ObjectMinProperties:\n            return `Expected object to have at least ${error.schema.minProperties} properties`;\n        case ValueErrorType.ObjectRequiredProperty:\n            return 'Required property';\n        case ValueErrorType.Promise:\n            return 'Expected Promise';\n        case ValueErrorType.RegExp:\n            return 'Expected string to match regular expression';\n        case ValueErrorType.StringFormatUnknown:\n            return `Unknown format '${error.schema.format}'`;\n        case ValueErrorType.StringFormat:\n            return `Expected string to match '${error.schema.format}' format`;\n        case ValueErrorType.StringMaxLength:\n            return `Expected string length less or equal to ${error.schema.maxLength}`;\n        case ValueErrorType.StringMinLength:\n            return `Expected string length greater or equal to ${error.schema.minLength}`;\n        case ValueErrorType.StringPattern:\n            return `Expected string to match '${error.schema.pattern}'`;\n        case ValueErrorType.String:\n            return 'Expected string';\n        case ValueErrorType.Symbol:\n            return 'Expected symbol';\n        case ValueErrorType.TupleLength:\n            return `Expected tuple to have ${error.schema.maxItems || 0} elements`;\n        case ValueErrorType.Tuple:\n            return 'Expected tuple';\n        case ValueErrorType.Uint8ArrayMaxByteLength:\n            return `Expected byte length less or equal to ${error.schema.maxByteLength}`;\n        case ValueErrorType.Uint8ArrayMinByteLength:\n            return `Expected byte length greater or equal to ${error.schema.minByteLength}`;\n        case ValueErrorType.Uint8Array:\n            return 'Expected Uint8Array';\n        case ValueErrorType.Undefined:\n            return 'Expected undefined';\n        case ValueErrorType.Union:\n            return 'Expected union value';\n        case ValueErrorType.Void:\n            return 'Expected void';\n        case ValueErrorType.Kind:\n            return `Expected kind '${error.schema[Kind]}'`;\n        default:\n            return 'Unknown error type';\n    }\n}\n/** Manages error message providers */\nlet errorFunction = DefaultErrorFunction;\n/** Sets the error function used to generate error messages. */\nexport function SetErrorFunction(callback) {\n    errorFunction = callback;\n}\n/** Gets the error function used to generate error messages */\nexport function GetErrorFunction() {\n    return errorFunction;\n}\n",
  "import { TypeBoxError } from '../../type/error/index.mjs';\nexport class TypeDereferenceError extends TypeBoxError {\n    schema;\n    constructor(schema) {\n        super(`Unable to dereference schema with $id '${schema.$id}'`);\n        this.schema = schema;\n    }\n}\n/** Dereferences a schema from the references array or throws if not found */\nexport function Deref(schema, references) {\n    const index = references.findIndex((target) => target.$id === schema.$ref);\n    if (index === -1)\n        throw new TypeDereferenceError(schema);\n    return references[index];\n}\n",
  "import { IsArray, IsBoolean, IsBigInt, IsDate, IsNull, IsNumber, IsPlainObject, IsString, IsSymbol, IsUint8Array, IsUndefined } from '../guard/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueHashError extends TypeBoxError {\n    value;\n    constructor(value) {\n        super(`Unable to hash value`);\n        this.value = value;\n    }\n}\n// ------------------------------------------------------------------\n// ByteMarker\n// ------------------------------------------------------------------\nvar ByteMarker;\n(function (ByteMarker) {\n    ByteMarker[ByteMarker[\"Undefined\"] = 0] = \"Undefined\";\n    ByteMarker[ByteMarker[\"Null\"] = 1] = \"Null\";\n    ByteMarker[ByteMarker[\"Boolean\"] = 2] = \"Boolean\";\n    ByteMarker[ByteMarker[\"Number\"] = 3] = \"Number\";\n    ByteMarker[ByteMarker[\"String\"] = 4] = \"String\";\n    ByteMarker[ByteMarker[\"Object\"] = 5] = \"Object\";\n    ByteMarker[ByteMarker[\"Array\"] = 6] = \"Array\";\n    ByteMarker[ByteMarker[\"Date\"] = 7] = \"Date\";\n    ByteMarker[ByteMarker[\"Uint8Array\"] = 8] = \"Uint8Array\";\n    ByteMarker[ByteMarker[\"Symbol\"] = 9] = \"Symbol\";\n    ByteMarker[ByteMarker[\"BigInt\"] = 10] = \"BigInt\";\n})(ByteMarker || (ByteMarker = {}));\n// ------------------------------------------------------------------\n// State\n// ------------------------------------------------------------------\nlet Accumulator = BigInt('14695981039346656037');\nconst [Prime, Size] = [BigInt('1099511628211'), BigInt('2') ** BigInt('64')];\nconst Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));\nconst F64 = new Float64Array(1);\nconst F64In = new DataView(F64.buffer);\nconst F64Out = new Uint8Array(F64.buffer);\n// ------------------------------------------------------------------\n// NumberToBytes\n// ------------------------------------------------------------------\nfunction* NumberToBytes(value) {\n    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);\n    for (let i = 0; i < byteCount; i++) {\n        yield (value >> (8 * (byteCount - 1 - i))) & 0xff;\n    }\n}\n// ------------------------------------------------------------------\n// Hashing Functions\n// ------------------------------------------------------------------\nfunction ArrayType(value) {\n    FNV1A64(ByteMarker.Array);\n    for (const item of value) {\n        Visit(item);\n    }\n}\nfunction BooleanType(value) {\n    FNV1A64(ByteMarker.Boolean);\n    FNV1A64(value ? 1 : 0);\n}\nfunction BigIntType(value) {\n    FNV1A64(ByteMarker.BigInt);\n    F64In.setBigInt64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction DateType(value) {\n    FNV1A64(ByteMarker.Date);\n    Visit(value.getTime());\n}\nfunction NullType(value) {\n    FNV1A64(ByteMarker.Null);\n}\nfunction NumberType(value) {\n    FNV1A64(ByteMarker.Number);\n    F64In.setFloat64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction ObjectType(value) {\n    FNV1A64(ByteMarker.Object);\n    for (const key of globalThis.Object.keys(value).sort()) {\n        Visit(key);\n        Visit(value[key]);\n    }\n}\nfunction StringType(value) {\n    FNV1A64(ByteMarker.String);\n    for (let i = 0; i < value.length; i++) {\n        for (const byte of NumberToBytes(value.charCodeAt(i))) {\n            FNV1A64(byte);\n        }\n    }\n}\nfunction SymbolType(value) {\n    FNV1A64(ByteMarker.Symbol);\n    Visit(value.description);\n}\nfunction Uint8ArrayType(value) {\n    FNV1A64(ByteMarker.Uint8Array);\n    for (let i = 0; i < value.length; i++) {\n        FNV1A64(value[i]);\n    }\n}\nfunction UndefinedType(value) {\n    return FNV1A64(ByteMarker.Undefined);\n}\nfunction Visit(value) {\n    if (IsArray(value))\n        return ArrayType(value);\n    if (IsBoolean(value))\n        return BooleanType(value);\n    if (IsBigInt(value))\n        return BigIntType(value);\n    if (IsDate(value))\n        return DateType(value);\n    if (IsNull(value))\n        return NullType(value);\n    if (IsNumber(value))\n        return NumberType(value);\n    if (IsPlainObject(value))\n        return ObjectType(value);\n    if (IsString(value))\n        return StringType(value);\n    if (IsSymbol(value))\n        return SymbolType(value);\n    if (IsUint8Array(value))\n        return Uint8ArrayType(value);\n    if (IsUndefined(value))\n        return UndefinedType(value);\n    throw new ValueHashError(value);\n}\nfunction FNV1A64(byte) {\n    Accumulator = Accumulator ^ Bytes[byte];\n    Accumulator = (Accumulator * Prime) % Size;\n}\n// ------------------------------------------------------------------\n// Hash\n// ------------------------------------------------------------------\n/** Creates a FNV1A-64 non cryptographic hash of the given value */\nexport function Hash(value) {\n    Accumulator = BigInt('14695981039346656037');\n    Visit(value);\n    return Accumulator;\n}\n",
  "import { TypeSystemPolicy } from '../system/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { GetErrorFunction } from './function.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { Never } from '../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nexport var ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nexport class ValueErrorsUnknownTypeError extends TypeBoxError {\n    schema;\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nexport class ValueErrorIterator {\n    iterator;\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value) {\n    return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) { }\nfunction* FromArray(schema, references, path, value) {\n    if (!IsArray(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n    if (!IsAsyncIterator(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n    if (!IsBigInt(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* FromBoolean(schema, references, path, value) {\n    if (!IsBoolean(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n    if (!IsDate(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* FromFunction(schema, references, path, value) {\n    if (!IsFunction(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n    if (!IsInteger(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* FromIntersect(schema, references, path, value) {\n    for (const inner of schema.allOf) {\n        const next = Visit(inner, references, path, value).next();\n        if (!next.done) {\n            yield Create(ValueErrorType.Intersect, schema, path, value);\n            yield next.value;\n        }\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* FromIterator(schema, references, path, value) {\n    if (!IsIterator(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n    if (!IsNull(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* FromObject(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* FromPromise(schema, references, path, value) {\n    if (!IsPromise(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* FromRef(schema, references, path, value) {\n    yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n    const regex = new RegExp(schema.source, schema.flags);\n    if (!regex.test(value)) {\n        return yield Create(ValueErrorType.RegExp, schema, path, value);\n    }\n}\nfunction* FromString(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if (IsString(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if (IsString(schema.format)) {\n        if (!FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* FromSymbol(schema, references, path, value) {\n    if (!IsSymbol(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* FromThis(schema, references, path, value) {\n    yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n    if (!IsArray(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* FromUndefined(schema, references, path, value) {\n    if (!IsUndefined(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n    let count = 0;\n    for (const subschema of schema.anyOf) {\n        const errors = [...Visit(subschema, references, path, value)];\n        if (errors.length === 0)\n            return; // matched\n        count += errors.length;\n    }\n    if (count > 0) {\n        yield Create(ValueErrorType.Union, schema, path, value);\n    }\n}\nfunction* FromUint8Array(schema, references, path, value) {\n    if (!IsUint8Array(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* FromUnknown(schema, references, path, value) { }\nfunction* FromVoid(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n    const check = TypeRegistry.Get(schema[Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return yield* FromAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* FromArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* FromAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* FromBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* FromBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* FromConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* FromDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* FromFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* FromInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* FromIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* FromIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* FromLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* FromNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* FromNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* FromNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* FromNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* FromObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* FromPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* FromRef(schema_, references_, path, value);\n        case 'RegExp':\n            return yield* FromRegExp(schema_, references_, path, value);\n        case 'String':\n            return yield* FromString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* FromSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* FromTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* FromTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* FromUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* FromUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* FromUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* FromUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* FromVoid(schema_, references_, path, value);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* FromKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nexport function Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Any type */\nexport function Any(options = {}) {\n    return { ...options, [Kind]: 'Any' };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Unknown type */\nexport function Unknown(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Unknown',\n    };\n}\n",
  "import { Any } from '../any/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { PatternNumberExact, PatternStringExact } from '../patterns/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nimport { TypeGuard, ValueGuard } from '../guard/index.mjs';\nexport class ExtendsResolverError extends TypeBoxError {\n}\nexport var ExtendsResult;\n(function (ExtendsResult) {\n    ExtendsResult[ExtendsResult[\"Union\"] = 0] = \"Union\";\n    ExtendsResult[ExtendsResult[\"True\"] = 1] = \"True\";\n    ExtendsResult[ExtendsResult[\"False\"] = 2] = \"False\";\n})(ExtendsResult || (ExtendsResult = {}));\n// ------------------------------------------------------------------\n// IntoBooleanResult\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IntoBooleanResult(result) {\n    return result === ExtendsResult.False ? result : ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Throw\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Throw(message) {\n    throw new ExtendsResolverError(message);\n}\n// ------------------------------------------------------------------\n// StructuralRight\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsStructuralRight(right) {\n    return (TypeGuard.IsNever(right) ||\n        TypeGuard.IsIntersect(right) ||\n        TypeGuard.IsUnion(right) ||\n        TypeGuard.IsUnknown(right) ||\n        TypeGuard.IsAny(right));\n}\n// prettier-ignore\nfunction StructuralRight(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                    TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                        Throw('StructuralRight'));\n}\n// ------------------------------------------------------------------\n// Any\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAnyRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromAny(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        (TypeGuard.IsUnion(right) && right.anyOf.some((schema) => TypeGuard.IsAny(schema) || TypeGuard.IsUnknown(schema))) ? ExtendsResult.True :\n            TypeGuard.IsUnion(right) ? ExtendsResult.Union :\n                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                    TypeGuard.IsAny(right) ? ExtendsResult.True :\n                        ExtendsResult.Union);\n}\n// ------------------------------------------------------------------\n// Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromArrayRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union :\n            TypeGuard.IsNever(left) ? ExtendsResult.True :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromArray(left, right) {\n    return (TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.IsArray(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// AsyncIterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAsyncIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// BigInt\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBigInt(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBigInt(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Boolean\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBooleanRight(left, right) {\n    return (TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True :\n        TypeGuard.IsBoolean(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromBoolean(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBoolean(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Constructor\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromConstructor(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsConstructor(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Date\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromDate(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsDate(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Function\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromFunction(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsFunction(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Integer\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntegerRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsNumber(left.const) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromInteger(left, right) {\n    return (TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Intersect\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntersectRight(left, right) {\n    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromIntersect(left, right) {\n    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Iterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// Literal\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromLiteral(left, right) {\n    return (TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Never\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNeverRight(left, right) {\n    return ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromNever(left, right) {\n    return ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Not\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction UnwrapTNot(schema) {\n    let [current, depth] = [schema, 0];\n    while (true) {\n        if (!TypeGuard.IsNot(current))\n            break;\n        current = current.not;\n        depth += 1;\n    }\n    return depth % 2 === 0 ? current : Unknown();\n}\n// prettier-ignore\nfunction FromNot(left, right) {\n    // TypeScript has no concept of negated types, and attempts to correctly check the negated\n    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n    // the type. Instead we unwrap to either unknown or T and continue evaluating.\n    // prettier-ignore\n    return (TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) :\n        TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) :\n            Throw('Invalid fallthrough for Not'));\n}\n// ------------------------------------------------------------------\n// Null\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNull(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsNull(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Number\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNumberRight(left, right) {\n    return (TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromNumber(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Object\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsObjectPropertyCount(schema, count) {\n    return Object.getOwnPropertyNames(schema.properties).length === count;\n}\n// prettier-ignore\nfunction IsObjectStringLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectSymbolLike(schema) {\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.IsString(schema.properties.description.anyOf[0]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.IsString(schema.properties.description.anyOf[1]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[0]))));\n}\n// prettier-ignore\nfunction IsObjectNumberLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBooleanLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBigIntLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectDateLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectUint8ArrayLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectFunctionLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectConstructorLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectArrayLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectPromiseLike(schema) {\n    const then = FunctionType([Any()], Any());\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True);\n}\n// ------------------------------------------------------------------\n// Property\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Property(left, right) {\n    return (Visit(left, right) === ExtendsResult.False ? ExtendsResult.False :\n        TypeGuard.IsOptional(left) && !TypeGuard.IsOptional(right) ? ExtendsResult.False :\n            ExtendsResult.True);\n}\n// prettier-ignore\nfunction FromObjectRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union : (TypeGuard.IsNever(left) ||\n            (TypeGuard.IsLiteralString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right)) ||\n            (TypeGuard.IsString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsInteger(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||\n            (TypeGuard.IsDate(left) && IsObjectDateLike(right)) ||\n            (TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right)) ||\n            (TypeGuard.IsFunction(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :\n            (TypeGuard.IsRecord(left) && TypeGuard.IsString(RecordKey(left))) ? (() => {\n                // When expressing a Record with literal key values, the Record is converted into a Object with\n                // the Hint assigned as `Record`. This is used to invert the extends logic.\n                return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;\n            })() :\n                (TypeGuard.IsRecord(left) && TypeGuard.IsNumber(RecordKey(left))) ? (() => {\n                    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;\n                })() :\n                    ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromObject(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n            !TypeGuard.IsObject(right) ? ExtendsResult.False :\n                (() => {\n                    for (const key of Object.getOwnPropertyNames(right.properties)) {\n                        if (!(key in left.properties) && !TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.False;\n                        }\n                        if (TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.True;\n                        }\n                        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {\n                            return ExtendsResult.False;\n                        }\n                    }\n                    return ExtendsResult.True;\n                })());\n}\n// ------------------------------------------------------------------\n// Promise\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPromise(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :\n            !TypeGuard.IsPromise(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.item, right.item)));\n}\n// ------------------------------------------------------------------\n// Record\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordKey(schema) {\n    return (PatternNumberExact in schema.patternProperties ? Number() :\n        PatternStringExact in schema.patternProperties ? String() :\n            Throw('Unknown record key pattern'));\n}\n// prettier-ignore\nfunction RecordValue(schema) {\n    return (PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] :\n        PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] :\n            Throw('Unable to get record value schema'));\n}\n// prettier-ignore\nfunction FromRecordRight(left, right) {\n    const [Key, Value] = [RecordKey(right), RecordValue(right)];\n    return ((TypeGuard.IsLiteralString(left) && TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :\n        TypeGuard.IsUint8Array(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n            TypeGuard.IsString(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                TypeGuard.IsArray(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                    TypeGuard.IsObject(left) ? (() => {\n                        for (const key of Object.getOwnPropertyNames(left.properties)) {\n                            if (Property(Value, left.properties[key]) === ExtendsResult.False) {\n                                return ExtendsResult.False;\n                            }\n                        }\n                        return ExtendsResult.True;\n                    })() :\n                        ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromRecord(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsRecord(right) ? ExtendsResult.False :\n                Visit(RecordValue(left), RecordValue(right)));\n}\n// ------------------------------------------------------------------\n// RegExp\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromRegExp(left, right) {\n    // Note: RegExp types evaluate as strings, not RegExp objects.\n    // Here we remap either into string and continue evaluating.\n    const L = TypeGuard.IsRegExp(left) ? String() : left;\n    const R = TypeGuard.IsRegExp(right) ? String() : right;\n    return Visit(L, R);\n}\n// ------------------------------------------------------------------\n// String\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromStringRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsString(left.const) ? ExtendsResult.True :\n        TypeGuard.IsString(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromString(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsString(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Symbol\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromSymbol(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsSymbol(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// TemplateLiteral\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromTemplateLiteral(left, right) {\n    // TemplateLiteral types are resolved to either unions for finite expressions or string\n    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n    // either type and continue evaluating.\n    return (TypeGuard.IsTemplateLiteral(left) ? Visit(TemplateLiteralToUnion(left), right) :\n        TypeGuard.IsTemplateLiteral(right) ? Visit(left, TemplateLiteralToUnion(right)) :\n            Throw('Invalid fallthrough for TemplateLiteral'));\n}\n// ------------------------------------------------------------------\n// Tuple\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsArrayOfTuple(left, right) {\n    return (TypeGuard.IsArray(right) &&\n        left.items !== undefined &&\n        left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True));\n}\n// prettier-ignore\nfunction FromTupleRight(left, right) {\n    return (TypeGuard.IsNever(left) ? ExtendsResult.True :\n        TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n            TypeGuard.IsAny(left) ? ExtendsResult.Union :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromTuple(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n            TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :\n                !TypeGuard.IsTuple(right) ? ExtendsResult.False :\n                    (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)) ? ExtendsResult.False :\n                        (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) ? ExtendsResult.True :\n                            left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :\n                                ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Uint8Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUint8Array(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsUint8Array(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Undefined\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUndefined(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsVoid(right) ? FromVoidRight(left, right) :\n                    TypeGuard.IsUndefined(right) ? ExtendsResult.True :\n                        ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Union\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnionRight(left, right) {\n    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromUnion(left, right) {\n    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Unknown\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnknownRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromUnknown(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    TypeGuard.IsArray(right) ? FromArrayRight(left, right) :\n                                        TypeGuard.IsTuple(right) ? FromTupleRight(left, right) :\n                                            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                                                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Void\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromVoidRight(left, right) {\n    return (TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n        TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromVoid(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n            TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                        TypeGuard.IsVoid(right) ? ExtendsResult.True :\n                            ExtendsResult.False);\n}\n// prettier-ignore\nfunction Visit(left, right) {\n    return (\n    // resolvable\n    (TypeGuard.IsTemplateLiteral(left) || TypeGuard.IsTemplateLiteral(right)) ? FromTemplateLiteral(left, right) :\n        (TypeGuard.IsRegExp(left) || TypeGuard.IsRegExp(right)) ? FromRegExp(left, right) :\n            (TypeGuard.IsNot(left) || TypeGuard.IsNot(right)) ? FromNot(left, right) :\n                // standard\n                TypeGuard.IsAny(left) ? FromAny(left, right) :\n                    TypeGuard.IsArray(left) ? FromArray(left, right) :\n                        TypeGuard.IsBigInt(left) ? FromBigInt(left, right) :\n                            TypeGuard.IsBoolean(left) ? FromBoolean(left, right) :\n                                TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) :\n                                    TypeGuard.IsConstructor(left) ? FromConstructor(left, right) :\n                                        TypeGuard.IsDate(left) ? FromDate(left, right) :\n                                            TypeGuard.IsFunction(left) ? FromFunction(left, right) :\n                                                TypeGuard.IsInteger(left) ? FromInteger(left, right) :\n                                                    TypeGuard.IsIntersect(left) ? FromIntersect(left, right) :\n                                                        TypeGuard.IsIterator(left) ? FromIterator(left, right) :\n                                                            TypeGuard.IsLiteral(left) ? FromLiteral(left, right) :\n                                                                TypeGuard.IsNever(left) ? FromNever(left, right) :\n                                                                    TypeGuard.IsNull(left) ? FromNull(left, right) :\n                                                                        TypeGuard.IsNumber(left) ? FromNumber(left, right) :\n                                                                            TypeGuard.IsObject(left) ? FromObject(left, right) :\n                                                                                TypeGuard.IsRecord(left) ? FromRecord(left, right) :\n                                                                                    TypeGuard.IsString(left) ? FromString(left, right) :\n                                                                                        TypeGuard.IsSymbol(left) ? FromSymbol(left, right) :\n                                                                                            TypeGuard.IsTuple(left) ? FromTuple(left, right) :\n                                                                                                TypeGuard.IsPromise(left) ? FromPromise(left, right) :\n                                                                                                    TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) :\n                                                                                                        TypeGuard.IsUndefined(left) ? FromUndefined(left, right) :\n                                                                                                            TypeGuard.IsUnion(left) ? FromUnion(left, right) :\n                                                                                                                TypeGuard.IsUnknown(left) ? FromUnknown(left, right) :\n                                                                                                                    TypeGuard.IsVoid(left) ? FromVoid(left, right) :\n                                                                                                                        Throw(`Unknown left type operand '${left[Kind]}'`));\n}\nexport function ExtendsCheck(left, right) {\n    return Visit(left, right);\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Extends } from './extends.mjs';\n// prettier-ignore\nfunction FromProperties(P, Right, True, False, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(Left, Right, True, False, options) {\n    return FromProperties(Left.properties, Right, True, False, options);\n}\n// prettier-ignore\nexport function ExtendsFromMappedResult(Left, Right, True, False, options) {\n    const P = FromMappedResult(Left, Right, True, False, options);\n    return MappedResult(P);\n}\n",
  "import { Union } from '../union/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from './extends-check.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { ExtendsFromMappedKey } from './extends-from-mapped-key.mjs';\nimport { ExtendsFromMappedResult } from './extends-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsMappedResult } from '../guard/type.mjs';\n// prettier-ignore\nfunction ExtendsResolve(left, right, trueType, falseType) {\n    const R = ExtendsCheck(left, right);\n    return (R === ExtendsResult.Union ? Union([trueType, falseType]) :\n        R === ExtendsResult.True ? trueType :\n            falseType);\n}\n/** `[Json]` Creates a Conditional type */\nexport function Extends(L, R, T, F, options = {}) {\n    // prettier-ignore\n    return (IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) :\n        IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) :\n            CloneType(ExtendsResolve(L, R, T, F), options));\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Extends } from './extends.mjs';\n// prettier-ignore\nfunction FromPropertyKey(K, U, L, R, options) {\n    return {\n        [K]: Extends(Literal(K), U, L, R, options)\n    };\n}\n// prettier-ignore\nfunction FromPropertyKeys(K, U, L, R, options) {\n    return K.reduce((Acc, LK) => {\n        return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(K, U, L, R, options) {\n    return FromPropertyKeys(K.keys, U, L, R, options);\n}\n// prettier-ignore\nexport function ExtendsFromMappedKey(T, U, L, R, options) {\n    const P = FromMappedKey(T, U, L, R, options);\n    return MappedResult(P);\n}\n",
  "import { TypeSystemPolicy } from '../../system/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Hash } from '../hash/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { KeyOfPattern } from '../../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../../type/extends/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../../type/registry/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Never } from '../../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCheckUnknownTypeError extends TypeBoxError {\n    schema;\n    constructor(schema) {\n        super(`Unknown type`);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// TypeGuards\n// ------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n    return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromAny(schema, references, value) {\n    return true;\n}\nfunction FromArray(schema, references, value) {\n    if (!IsArray(value))\n        return false;\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        return false;\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        return false;\n    }\n    if (!value.every((value) => Visit(schema.items, references, value))) {\n        return false;\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        return false;\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {\n        return true; // exit\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n    const containsCount = value.reduce((acc, value) => (Visit(containsSchema, references, value) ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        return false;\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        return false;\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        return false;\n    }\n    return true;\n}\nfunction FromAsyncIterator(schema, references, value) {\n    return IsAsyncIterator(value);\n}\nfunction FromBigInt(schema, references, value) {\n    if (!IsBigInt(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        return false;\n    }\n    return true;\n}\nfunction FromBoolean(schema, references, value) {\n    return IsBoolean(value);\n}\nfunction FromConstructor(schema, references, value) {\n    return Visit(schema.returns, references, value.prototype);\n}\nfunction FromDate(schema, references, value) {\n    if (!IsDate(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromFunction(schema, references, value) {\n    return IsFunction(value);\n}\nfunction FromInteger(schema, references, value) {\n    if (!IsInteger(value)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromIntersect(schema, references, value) {\n    const check1 = schema.allOf.every((schema) => Visit(schema, references, value));\n    if (schema.unevaluatedProperties === false) {\n        const keyPattern = new RegExp(KeyOfPattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));\n        return check1 && check2;\n    }\n    else if (IsSchema(schema.unevaluatedProperties)) {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n        return check1 && check2;\n    }\n    else {\n        return check1;\n    }\n}\nfunction FromIterator(schema, references, value) {\n    return IsIterator(value);\n}\nfunction FromLiteral(schema, references, value) {\n    return value === schema.const;\n}\nfunction FromNever(schema, references, value) {\n    return false;\n}\nfunction FromNot(schema, references, value) {\n    return !Visit(schema.not, references, value);\n}\nfunction FromNull(schema, references, value) {\n    return IsNull(value);\n}\nfunction FromNumber(schema, references, value) {\n    if (!TypeSystemPolicy.IsNumberLike(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromObject(schema, references, value) {\n    if (!TypeSystemPolicy.IsObjectLike(value))\n        return false;\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            if (!Visit(property, references, value[knownKey])) {\n                return false;\n            }\n            if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n                return false;\n            }\n        }\n        else {\n            if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n                return false;\n            }\n        }\n    }\n    if (schema.additionalProperties === false) {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        // optimization: value is valid if schemaKey length matches the valueKey length\n        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n            return true;\n        }\n        else {\n            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));\n        }\n    }\n    else if (typeof schema.additionalProperties === 'object') {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n    }\n    else {\n        return true;\n    }\n}\nfunction FromPromise(schema, references, value) {\n    return IsPromise(value);\n}\nfunction FromRecord(schema, references, value) {\n    if (!TypeSystemPolicy.IsRecordLike(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    // prettier-ignore\n    const check1 = Object.entries(value).every(([key, value]) => {\n        return (regex.test(key)) ? Visit(patternSchema, references, value) : true;\n    });\n    // prettier-ignore\n    const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {\n        return (!regex.test(key)) ? Visit(schema.additionalProperties, references, value) : true;\n    }) : true;\n    const check3 = schema.additionalProperties === false\n        ? Object.getOwnPropertyNames(value).every((key) => {\n            return regex.test(key);\n        })\n        : true;\n    return check1 && check2 && check3;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromRegExp(schema, references, value) {\n    const regex = new RegExp(schema.source, schema.flags);\n    return regex.test(value);\n}\nfunction FromString(schema, references, value) {\n    if (!IsString(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    if (IsDefined(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value))\n            return false;\n    }\n    if (IsDefined(schema.format)) {\n        if (!FormatRegistry.Has(schema.format))\n            return false;\n        const func = FormatRegistry.Get(schema.format);\n        return func(value);\n    }\n    return true;\n}\nfunction FromSymbol(schema, references, value) {\n    return IsSymbol(value);\n}\nfunction FromTemplateLiteral(schema, references, value) {\n    return IsString(value) && new RegExp(schema.pattern).test(value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (!IsArray(value)) {\n        return false;\n    }\n    if (schema.items === undefined && !(value.length === 0)) {\n        return false;\n    }\n    if (!(value.length === schema.maxItems)) {\n        return false;\n    }\n    if (!schema.items) {\n        return true;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        if (!Visit(schema.items[i], references, value[i]))\n            return false;\n    }\n    return true;\n}\nfunction FromUndefined(schema, references, value) {\n    return IsUndefined(value);\n}\nfunction FromUnion(schema, references, value) {\n    return schema.anyOf.some((inner) => Visit(inner, references, value));\n}\nfunction FromUint8Array(schema, references, value) {\n    if (!IsUint8Array(value)) {\n        return false;\n    }\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        return false;\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        return false;\n    }\n    return true;\n}\nfunction FromUnknown(schema, references, value) {\n    return true;\n}\nfunction FromVoid(schema, references, value) {\n    return TypeSystemPolicy.IsVoidLike(value);\n}\nfunction FromKind(schema, references, value) {\n    if (!TypeRegistry.Has(schema[Kind]))\n        return false;\n    const func = TypeRegistry.Get(schema[Kind]);\n    return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return FromAny(schema_, references_, value);\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return FromBigInt(schema_, references_, value);\n        case 'Boolean':\n            return FromBoolean(schema_, references_, value);\n        case 'Constructor':\n            return FromConstructor(schema_, references_, value);\n        case 'Date':\n            return FromDate(schema_, references_, value);\n        case 'Function':\n            return FromFunction(schema_, references_, value);\n        case 'Integer':\n            return FromInteger(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Iterator':\n            return FromIterator(schema_, references_, value);\n        case 'Literal':\n            return FromLiteral(schema_, references_, value);\n        case 'Never':\n            return FromNever(schema_, references_, value);\n        case 'Not':\n            return FromNot(schema_, references_, value);\n        case 'Null':\n            return FromNull(schema_, references_, value);\n        case 'Number':\n            return FromNumber(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Promise':\n            return FromPromise(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'RegExp':\n            return FromRegExp(schema_, references_, value);\n        case 'String':\n            return FromString(schema_, references_, value);\n        case 'Symbol':\n            return FromSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return FromTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Undefined':\n            return FromUndefined(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return FromUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return FromUnknown(schema_, references_, value);\n        case 'Void':\n            return FromVoid(schema_, references_, value);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueCheckUnknownTypeError(schema_);\n            return FromKind(schema_, references_, value);\n    }\n}\n/** Returns true if the value matches the given type. */\nexport function Check(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n",
  "import { HasPropertyKey, IsString } from '../guard/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { TemplateLiteralGenerate, IsTemplateLiteralFinite } from '../../type/template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact } from '../../type/patterns/index.mjs';\nimport { TypeRegistry } from '../../type/registry/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCreateError extends TypeBoxError {\n    schema;\n    constructor(schema, message) {\n        super(message);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// Create\n// ------------------------------------------------------------------\nfunction FromAny(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return {};\n    }\n}\nfunction FromArray(schema, references) {\n    if (schema.uniqueItems === true && !HasPropertyKey(schema, 'default')) {\n        throw new ValueCreateError(schema, 'Array with the uniqueItems constraint requires a default value');\n    }\n    else if ('contains' in schema && !HasPropertyKey(schema, 'default')) {\n        throw new ValueCreateError(schema, 'Array with the contains constraint requires a default value');\n    }\n    else if ('default' in schema) {\n        return schema.default;\n    }\n    else if (schema.minItems !== undefined) {\n        return Array.from({ length: schema.minItems }).map((item) => {\n            return Visit(schema.items, references);\n        });\n    }\n    else {\n        return [];\n    }\n}\nfunction FromAsyncIterator(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return (async function* () { })();\n    }\n}\nfunction FromBigInt(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return BigInt(0);\n    }\n}\nfunction FromBoolean(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return false;\n    }\n}\nfunction FromConstructor(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const value = Visit(schema.returns, references);\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            return class {\n                constructor() {\n                    for (const [key, val] of Object.entries(value)) {\n                        const self = this;\n                        self[key] = val;\n                    }\n                }\n            };\n        }\n        else {\n            return class {\n            };\n        }\n    }\n}\nfunction FromDate(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimumTimestamp !== undefined) {\n        return new Date(schema.minimumTimestamp);\n    }\n    else {\n        return new Date();\n    }\n}\nfunction FromFunction(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return () => Visit(schema.returns, references);\n    }\n}\nfunction FromInteger(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction FromIntersect(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        // --------------------------------------------------------------\n        // Note: The best we can do here is attempt to instance each\n        // sub type and apply through object assign. For non-object\n        // sub types, we just escape the assignment and just return\n        // the value. In the latter case, this is typically going to\n        // be a consequence of an illogical intersection.\n        // --------------------------------------------------------------\n        const value = schema.allOf.reduce((acc, schema) => {\n            const next = Visit(schema, references);\n            return typeof next === 'object' ? { ...acc, ...next } : next;\n        }, {});\n        if (!Check(schema, references, value))\n            throw new ValueCreateError(schema, 'Intersect produced invalid value. Consider using a default value.');\n        return value;\n    }\n}\nfunction FromIterator(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return (function* () { })();\n    }\n}\nfunction FromLiteral(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return schema.const;\n    }\n}\nfunction FromNever(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new ValueCreateError(schema, 'Never types cannot be created. Consider using a default value.');\n    }\n}\nfunction FromNot(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new ValueCreateError(schema, 'Not types must have a default value');\n    }\n}\nfunction FromNull(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return null;\n    }\n}\nfunction FromNumber(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction FromObject(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const required = new Set(schema.required);\n        return (schema.default ||\n            Object.entries(schema.properties).reduce((acc, [key, schema]) => {\n                return required.has(key) ? { ...acc, [key]: Visit(schema, references) } : { ...acc };\n            }, {}));\n    }\n}\nfunction FromPromise(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Promise.resolve(Visit(schema.item, references));\n    }\n}\nfunction FromRecord(schema, references) {\n    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {\n        const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split('|');\n        return propertyKeys.reduce((acc, key) => {\n            return { ...acc, [key]: Visit(valueSchema, references) };\n        }, {});\n    }\n    else {\n        return {};\n    }\n}\nfunction FromRef(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Visit(Deref(schema, references), references);\n    }\n}\nfunction FromRegExp(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new ValueCreateError(schema, 'RegExp types cannot be created. Consider using a default value.');\n    }\n}\nfunction FromString(schema, references) {\n    if (schema.pattern !== undefined) {\n        if (!HasPropertyKey(schema, 'default')) {\n            throw new ValueCreateError(schema, 'String types with patterns must specify a default value');\n        }\n        else {\n            return schema.default;\n        }\n    }\n    else if (schema.format !== undefined) {\n        if (!HasPropertyKey(schema, 'default')) {\n            throw new ValueCreateError(schema, 'String types with formats must specify a default value');\n        }\n        else {\n            return schema.default;\n        }\n    }\n    else {\n        if (HasPropertyKey(schema, 'default')) {\n            return schema.default;\n        }\n        else if (schema.minLength !== undefined) {\n            // prettier-ignore\n            return Array.from({ length: schema.minLength }).map(() => ' ').join('');\n        }\n        else {\n            return '';\n        }\n    }\n}\nfunction FromSymbol(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if ('value' in schema) {\n        return Symbol.for(schema.value);\n    }\n    else {\n        return Symbol();\n    }\n}\nfunction FromTemplateLiteral(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    if (!IsTemplateLiteralFinite(schema))\n        throw new ValueCreateError(schema, 'Can only create template literals that produce a finite variants. Consider using a default value.');\n    const generated = TemplateLiteralGenerate(schema);\n    return generated[0];\n}\nfunction FromThis(schema, references) {\n    if (recursiveDepth++ > recursiveMaxDepth)\n        throw new ValueCreateError(schema, 'Cannot create recursive type as it appears possibly infinite. Consider using a default.');\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Visit(Deref(schema, references), references);\n    }\n}\nfunction FromTuple(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    if (schema.items === undefined) {\n        return [];\n    }\n    else {\n        return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));\n    }\n}\nfunction FromUndefined(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction FromUnion(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.anyOf.length === 0) {\n        throw new Error('ValueCreate.Union: Cannot create Union with zero variants');\n    }\n    else {\n        return Visit(schema.anyOf[0], references);\n    }\n}\nfunction FromUint8Array(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minByteLength !== undefined) {\n        return new Uint8Array(schema.minByteLength);\n    }\n    else {\n        return new Uint8Array(0);\n    }\n}\nfunction FromUnknown(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return {};\n    }\n}\nfunction FromVoid(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction FromKind(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new Error('User defined types must specify a default value');\n    }\n}\nfunction Visit(schema, references) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return FromAny(schema_, references_);\n        case 'Array':\n            return FromArray(schema_, references_);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_);\n        case 'BigInt':\n            return FromBigInt(schema_, references_);\n        case 'Boolean':\n            return FromBoolean(schema_, references_);\n        case 'Constructor':\n            return FromConstructor(schema_, references_);\n        case 'Date':\n            return FromDate(schema_, references_);\n        case 'Function':\n            return FromFunction(schema_, references_);\n        case 'Integer':\n            return FromInteger(schema_, references_);\n        case 'Intersect':\n            return FromIntersect(schema_, references_);\n        case 'Iterator':\n            return FromIterator(schema_, references_);\n        case 'Literal':\n            return FromLiteral(schema_, references_);\n        case 'Never':\n            return FromNever(schema_, references_);\n        case 'Not':\n            return FromNot(schema_, references_);\n        case 'Null':\n            return FromNull(schema_, references_);\n        case 'Number':\n            return FromNumber(schema_, references_);\n        case 'Object':\n            return FromObject(schema_, references_);\n        case 'Promise':\n            return FromPromise(schema_, references_);\n        case 'Record':\n            return FromRecord(schema_, references_);\n        case 'Ref':\n            return FromRef(schema_, references_);\n        case 'RegExp':\n            return FromRegExp(schema_, references_);\n        case 'String':\n            return FromString(schema_, references_);\n        case 'Symbol':\n            return FromSymbol(schema_, references_);\n        case 'TemplateLiteral':\n            return FromTemplateLiteral(schema_, references_);\n        case 'This':\n            return FromThis(schema_, references_);\n        case 'Tuple':\n            return FromTuple(schema_, references_);\n        case 'Undefined':\n            return FromUndefined(schema_, references_);\n        case 'Union':\n            return FromUnion(schema_, references_);\n        case 'Uint8Array':\n            return FromUint8Array(schema_, references_);\n        case 'Unknown':\n            return FromUnknown(schema_, references_);\n        case 'Void':\n            return FromVoid(schema_, references_);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueCreateError(schema_, 'Unknown type');\n            return FromKind(schema_, references_);\n    }\n}\n// ------------------------------------------------------------------\n// State\n// ------------------------------------------------------------------\nconst recursiveMaxDepth = 512;\nlet recursiveDepth = 0;\n/** Creates a value from the given schema */\nexport function Create(...args) {\n    recursiveDepth = 0;\n    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);\n}\n",
  "// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsDate, IsPlainObject, IsTypedArray, IsValueType } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Clonable\n// ------------------------------------------------------------------\nfunction ObjectType(value) {\n    const keys = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];\n    return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});\n}\nfunction ArrayType(value) {\n    return value.map((element) => Clone(element));\n}\nfunction TypedArrayType(value) {\n    return value.slice();\n}\nfunction DateType(value) {\n    return new Date(value.toISOString());\n}\nfunction ValueType(value) {\n    return value;\n}\n// ------------------------------------------------------------------\n// Clone\n// ------------------------------------------------------------------\n/** Returns a clone of the given value */\nexport function Clone(value) {\n    if (IsArray(value))\n        return ArrayType(value);\n    if (IsDate(value))\n        return DateType(value);\n    if (IsPlainObject(value))\n        return ObjectType(value);\n    if (IsTypedArray(value))\n        return TypedArrayType(value);\n    if (IsValueType(value))\n        return ValueType(value);\n    throw new Error('ValueClone: Unable to clone value');\n}\n",
  "import { IsPlainObject, IsArray, IsString, IsNumber, IsNull } from '../guard/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { Create } from '../create/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref } from '../deref/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCastError extends TypeBoxError {\n    schema;\n    constructor(schema, message) {\n        super(message);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// The following will score a schema against a value. For objects,\n// the score is the tally of points awarded for each property of\n// the value. Property points are (1.0 / propertyCount) to prevent\n// large property counts biasing results. Properties that match\n// literal values are maximally awarded as literals are typically\n// used as union discriminator fields.\n// ------------------------------------------------------------------\nfunction ScoreUnion(schema, references, value) {\n    if (schema[Kind] === 'Object' && typeof value === 'object' && !IsNull(value)) {\n        const object = schema;\n        const keys = Object.getOwnPropertyNames(value);\n        const entries = Object.entries(object.properties);\n        const [point, max] = [1 / entries.length, entries.length];\n        return entries.reduce((acc, [key, schema]) => {\n            const literal = schema[Kind] === 'Literal' && schema.const === value[key] ? max : 0;\n            const checks = Check(schema, references, value[key]) ? point : 0;\n            const exists = keys.includes(key) ? point : 0;\n            return acc + (literal + checks + exists);\n        }, 0);\n    }\n    else {\n        return Check(schema, references, value) ? 1 : 0;\n    }\n}\nfunction SelectUnion(union, references, value) {\n    let [select, best] = [union.anyOf[0], 0];\n    for (const schema of union.anyOf) {\n        const score = ScoreUnion(schema, references, value);\n        if (score > best) {\n            select = schema;\n            best = score;\n        }\n    }\n    return select;\n}\nfunction CastUnion(union, references, value) {\n    if ('default' in union) {\n        return union.default;\n    }\n    else {\n        const schema = SelectUnion(union, references, value);\n        return Cast(schema, references, value);\n    }\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction DefaultClone(schema, references, value) {\n    return Check(schema, references, value) ? Clone(value) : Create(schema, references);\n}\nfunction Default(schema, references, value) {\n    return Check(schema, references, value) ? value : Create(schema, references);\n}\n// ------------------------------------------------------------------\n// Cast\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    if (Check(schema, references, value))\n        return Clone(value);\n    const created = IsArray(value) ? Clone(value) : Create(schema, references);\n    const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;\n    const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;\n    const casted = maximum.map((value) => Visit(schema.items, references, value));\n    if (schema.uniqueItems !== true)\n        return casted;\n    const unique = [...new Set(casted)];\n    if (!Check(schema, references, unique))\n        throw new ValueCastError(schema, 'Array cast produced invalid data due to uniqueItems constraint');\n    return unique;\n}\nfunction FromConstructor(schema, references, value) {\n    if (Check(schema, references, value))\n        return Create(schema, references);\n    const required = new Set(schema.returns.required || []);\n    const result = function () { };\n    for (const [key, property] of Object.entries(schema.returns.properties)) {\n        if (!required.has(key) && value.prototype[key] === undefined)\n            continue;\n        result.prototype[key] = Visit(property, references, value.prototype[key]);\n    }\n    return result;\n}\nfunction FromIntersect(schema, references, value) {\n    const created = Create(schema, references);\n    const mapped = IsPlainObject(created) && IsPlainObject(value) ? { ...created, ...value } : value;\n    return Check(schema, references, mapped) ? mapped : Create(schema, references);\n}\nfunction FromNever(schema, references, value) {\n    throw new ValueCastError(schema, 'Never types cannot be cast');\n}\nfunction FromObject(schema, references, value) {\n    if (Check(schema, references, value))\n        return value;\n    if (value === null || typeof value !== 'object')\n        return Create(schema, references);\n    const required = new Set(schema.required || []);\n    const result = {};\n    for (const [key, property] of Object.entries(schema.properties)) {\n        if (!required.has(key) && value[key] === undefined)\n            continue;\n        result[key] = Visit(property, references, value[key]);\n    }\n    // additional schema properties\n    if (typeof schema.additionalProperties === 'object') {\n        const propertyNames = Object.getOwnPropertyNames(schema.properties);\n        for (const propertyName of Object.getOwnPropertyNames(value)) {\n            if (propertyNames.includes(propertyName))\n                continue;\n            result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);\n        }\n    }\n    return result;\n}\nfunction FromRecord(schema, references, value) {\n    if (Check(schema, references, value))\n        return Clone(value);\n    if (value === null || typeof value !== 'object' || Array.isArray(value) || value instanceof Date)\n        return Create(schema, references);\n    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const subschema = schema.patternProperties[subschemaPropertyName];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(subschema, references, propValue);\n    }\n    return result;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (Check(schema, references, value))\n        return Clone(value);\n    if (!IsArray(value))\n        return Create(schema, references);\n    if (schema.items === undefined)\n        return [];\n    return schema.items.map((schema, index) => Visit(schema, references, value[index]));\n}\nfunction FromUnion(schema, references, value) {\n    return Check(schema, references, value) ? Clone(value) : CastUnion(schema, references, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        // --------------------------------------------------------------\n        // Structural\n        // --------------------------------------------------------------\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Constructor':\n            return FromConstructor(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Never':\n            return FromNever(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        // --------------------------------------------------------------\n        // DefaultClone\n        // --------------------------------------------------------------\n        case 'Date':\n        case 'Symbol':\n        case 'Uint8Array':\n            return DefaultClone(schema, references, value);\n        // --------------------------------------------------------------\n        // Default\n        // --------------------------------------------------------------\n        default:\n            return Default(schema_, references_, value);\n    }\n}\n/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\nexport function Cast(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n",
  "import { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsString, IsObject, IsArray, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// IsCheckable\n// ------------------------------------------------------------------\nfunction IsCheckable(schema) {\n    return IsSchema(schema) && schema[Kind] !== 'Unsafe';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    if (!IsArray(value))\n        return value;\n    return value.map((value) => Visit(schema.items, references, value));\n}\nfunction FromIntersect(schema, references, value) {\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const intersections = schema.allOf.map((schema) => Visit(schema, references, Clone(value)));\n    const composite = intersections.reduce((acc, value) => (IsObject(value) ? { ...acc, ...value } : value), {});\n    if (!IsObject(value) || !IsObject(composite) || !IsSchema(unevaluatedProperties))\n        return composite;\n    const knownkeys = KeyOfPropertyKeys(schema);\n    for (const key of Object.getOwnPropertyNames(value)) {\n        if (knownkeys.includes(key))\n            continue;\n        if (Check(unevaluatedProperties, references, value[key])) {\n            composite[key] = Visit(unevaluatedProperties, references, value[key]);\n        }\n    }\n    return composite;\n}\nfunction FromObject(schema, references, value) {\n    if (!IsObject(value) || IsArray(value))\n        return value; // Check IsArray for AllowArrayObject configuration\n    const additionalProperties = schema.additionalProperties;\n    for (const key of Object.getOwnPropertyNames(value)) {\n        if (key in schema.properties) {\n            value[key] = Visit(schema.properties[key], references, value[key]);\n            continue;\n        }\n        if (IsSchema(additionalProperties) && Check(additionalProperties, references, value[key])) {\n            value[key] = Visit(additionalProperties, references, value[key]);\n            continue;\n        }\n        delete value[key];\n    }\n    return value;\n}\nfunction FromRecord(schema, references, value) {\n    if (!IsObject(value))\n        return value;\n    const additionalProperties = schema.additionalProperties;\n    const propertyKeys = Object.keys(value);\n    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];\n    const propertyKeyTest = new RegExp(propertyKey);\n    for (const key of propertyKeys) {\n        if (propertyKeyTest.test(key)) {\n            value[key] = Visit(propertySchema, references, value[key]);\n            continue;\n        }\n        if (IsSchema(additionalProperties) && Check(additionalProperties, references, value[key])) {\n            value[key] = Visit(additionalProperties, references, value[key]);\n            continue;\n        }\n        delete value[key];\n    }\n    return value;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (!IsArray(value))\n        return value;\n    if (IsUndefined(schema.items))\n        return [];\n    const length = Math.min(value.length, schema.items.length);\n    for (let i = 0; i < length; i++) {\n        value[i] = Visit(schema.items[i], references, value[i]);\n    }\n    // prettier-ignore\n    return value.length > length\n        ? value.slice(0, length)\n        : value;\n}\nfunction FromUnion(schema, references, value) {\n    for (const inner of schema.anyOf) {\n        if (IsCheckable(inner) && Check(inner, value)) {\n            return Visit(inner, references, value);\n        }\n    }\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return value;\n    }\n}\n/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Clean(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n",
  "import { Object } from '../object/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Index } from '../indexed/index.mjs';\nimport { KeyOfPropertyKeys } from '../keyof/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nfunction CompositeResolve(T) {\n    const intersect = Intersect(T, {});\n    const keys = KeyOfPropertyKeys(intersect);\n    const properties = keys.reduce((acc, key) => ({ ...acc, [key]: Index(intersect, [key]) }), {});\n    return Object(properties);\n}\n/** `[Json]` Creates a Composite object type */\nexport function Composite(T, options) {\n    return CloneType(CompositeResolve(T), options);\n}\n",
  "import { Clone } from '../clone/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { IsObject as IsObjectType } from '../../type/guard/type.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { Composite } from '../../type/composite/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsObject, IsDate, IsUndefined, IsString, IsNumber, IsBoolean, IsBigInt, IsSymbol } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Conversions\n// ------------------------------------------------------------------\nfunction IsStringNumeric(value) {\n    return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));\n}\nfunction IsValueToString(value) {\n    return IsBigInt(value) || IsBoolean(value) || IsNumber(value);\n}\nfunction IsValueTrue(value) {\n    return value === true || (IsNumber(value) && value === 1) || (IsBigInt(value) && value === BigInt('1')) || (IsString(value) && (value.toLowerCase() === 'true' || value === '1'));\n}\nfunction IsValueFalse(value) {\n    return value === false || (IsNumber(value) && (value === 0 || Object.is(value, -0))) || (IsBigInt(value) && value === BigInt('0')) || (IsString(value) && (value.toLowerCase() === 'false' || value === '0' || value === '-0'));\n}\nfunction IsTimeStringWithTimeZone(value) {\n    return IsString(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsTimeStringWithoutTimeZone(value) {\n    return IsString(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateTimeStringWithTimeZone(value) {\n    return IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsDateTimeStringWithoutTimeZone(value) {\n    return IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateString(value) {\n    return IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value);\n}\n// ------------------------------------------------------------------\n// Convert\n// ------------------------------------------------------------------\nfunction TryConvertLiteralString(value, target) {\n    const conversion = TryConvertString(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralNumber(value, target) {\n    const conversion = TryConvertNumber(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralBoolean(value, target) {\n    const conversion = TryConvertBoolean(value);\n    return conversion === target ? conversion : value;\n}\n// prettier-ignore\nfunction TryConvertLiteral(schema, value) {\n    return (IsString(schema.const) ? TryConvertLiteralString(value, schema.const) :\n        IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) :\n            IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) :\n                Clone(value));\n}\nfunction TryConvertBoolean(value) {\n    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;\n}\nfunction TryConvertBigInt(value) {\n    return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;\n}\nfunction TryConvertString(value) {\n    return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;\n}\nfunction TryConvertNumber(value) {\n    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertInteger(value) {\n    return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertNull(value) {\n    return IsString(value) && value.toLowerCase() === 'null' ? null : value;\n}\nfunction TryConvertUndefined(value) {\n    return IsString(value) && value === 'undefined' ? undefined : value;\n}\n// ------------------------------------------------------------------\n// note: this function may return an invalid dates for the regex\n// tests above. Invalid dates will however be checked during the\n// casting function and will return a epoch date if invalid.\n// Consider better string parsing for the iso dates in future\n// revisions.\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction TryConvertDate(value) {\n    return (IsDate(value) ? value :\n        IsNumber(value) ? new Date(value) :\n            IsValueTrue(value) ? new Date(1) :\n                IsValueFalse(value) ? new Date(0) :\n                    IsStringNumeric(value) ? new Date(parseInt(value)) :\n                        IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) :\n                            IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) :\n                                IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) :\n                                    IsDateTimeStringWithTimeZone(value) ? new Date(value) :\n                                        IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) :\n                                            value);\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction Default(value) {\n    return value;\n}\n// ------------------------------------------------------------------\n// Convert\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    if (IsArray(value)) {\n        return value.map((value) => Visit(schema.items, references, value));\n    }\n    return value;\n}\nfunction FromBigInt(schema, references, value) {\n    return TryConvertBigInt(value);\n}\nfunction FromBoolean(schema, references, value) {\n    return TryConvertBoolean(value);\n}\nfunction FromDate(schema, references, value) {\n    return TryConvertDate(value);\n}\nfunction FromInteger(schema, references, value) {\n    return TryConvertInteger(value);\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, value) {\n    const allObjects = schema.allOf.every(schema => IsObjectType(schema));\n    if (allObjects)\n        return Visit(Composite(schema.allOf), references, value);\n    return Visit(schema.allOf[0], references, value); // todo: fix this\n}\nfunction FromLiteral(schema, references, value) {\n    return TryConvertLiteral(schema, value);\n}\nfunction FromNull(schema, references, value) {\n    return TryConvertNull(value);\n}\nfunction FromNumber(schema, references, value) {\n    return TryConvertNumber(value);\n}\n// prettier-ignore\nfunction FromObject(schema, references, value) {\n    const isConvertable = IsObject(value);\n    if (!isConvertable)\n        return value;\n    return Object.getOwnPropertyNames(schema.properties).reduce((value, key) => {\n        return !IsUndefined(value[key])\n            ? ({ ...value, [key]: Visit(schema.properties[key], references, value[key]) })\n            : ({ ...value });\n    }, value);\n}\nfunction FromRecord(schema, references, value) {\n    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[propertyKey];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(property, references, propValue);\n    }\n    return result;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromString(schema, references, value) {\n    return TryConvertString(value);\n}\nfunction FromSymbol(schema, references, value) {\n    return IsString(value) || IsNumber(value) ? Symbol(value) : value;\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\n// prettier-ignore\nfunction FromTuple(schema, references, value) {\n    const isConvertable = IsArray(value) && !IsUndefined(schema.items);\n    if (!isConvertable)\n        return value;\n    return value.map((value, index) => {\n        return (index < schema.items.length)\n            ? Visit(schema.items[index], references, value)\n            : value;\n    });\n}\nfunction FromUndefined(schema, references, value) {\n    return TryConvertUndefined(value);\n}\nfunction FromUnion(schema, references, value) {\n    for (const subschema of schema.anyOf) {\n        const converted = Visit(subschema, references, value);\n        if (Check(subschema, references, converted)) {\n            return converted;\n        }\n    }\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'BigInt':\n            return FromBigInt(schema_, references_, value);\n        case 'Boolean':\n            return FromBoolean(schema_, references_, value);\n        case 'Date':\n            return FromDate(schema_, references_, value);\n        case 'Integer':\n            return FromInteger(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Literal':\n            return FromLiteral(schema_, references_, value);\n        case 'Null':\n            return FromNull(schema_, references_, value);\n        case 'Number':\n            return FromNumber(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'String':\n            return FromString(schema_, references_, value);\n        case 'Symbol':\n            return FromSymbol(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Undefined':\n            return FromUndefined(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return Default(value);\n    }\n}\n/** Converts any type mismatched values to their target type if a reasonable conversion is possible. */\n// prettier-ignore\nexport function Convert(...args) {\n    return args.length === 3\n        ? Visit(args[0], args[1], args[2])\n        : Visit(args[0], [], args[1]);\n}\n",
  "import { Check } from '../check/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsString, IsObject, IsArray, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// ValueOrDefault\n// ------------------------------------------------------------------\nfunction ValueOrDefault(schema, value) {\n    return !(value === undefined) || !('default' in schema) ? value : schema.default;\n}\n// ------------------------------------------------------------------\n// IsCheckable\n// ------------------------------------------------------------------\nfunction IsCheckable(schema) {\n    return IsSchema(schema) && schema[Kind] !== 'Unsafe';\n}\n// ------------------------------------------------------------------\n// IsDefaultSchema\n// ------------------------------------------------------------------\nfunction IsDefaultSchema(value) {\n    return IsSchema(value) && 'default' in value;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsArray(defaulted))\n        return defaulted;\n    for (let i = 0; i < defaulted.length; i++) {\n        defaulted[i] = Visit(schema.items, references, defaulted[i]);\n    }\n    return defaulted;\n}\nfunction FromIntersect(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    return schema.allOf.reduce((acc, schema) => {\n        const next = Visit(schema, references, defaulted);\n        return IsObject(next) ? { ...acc, ...next } : next;\n    }, {});\n}\nfunction FromObject(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsObject(defaulted))\n        return defaulted;\n    const additionalPropertiesSchema = schema.additionalProperties;\n    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);\n    // properties\n    for (const key of knownPropertyKeys) {\n        if (!IsDefaultSchema(schema.properties[key]))\n            continue;\n        defaulted[key] = Visit(schema.properties[key], references, defaulted[key]);\n    }\n    // return if not additional properties\n    if (!IsDefaultSchema(additionalPropertiesSchema))\n        return defaulted;\n    // additional properties\n    for (const key of Object.getOwnPropertyNames(defaulted)) {\n        if (knownPropertyKeys.includes(key))\n            continue;\n        defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);\n    }\n    return defaulted;\n}\nfunction FromRecord(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsObject(defaulted))\n        return defaulted;\n    const additionalPropertiesSchema = schema.additionalProperties;\n    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];\n    const knownPropertyKey = new RegExp(propertyKeyPattern);\n    // properties\n    for (const key of Object.getOwnPropertyNames(defaulted)) {\n        if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))\n            continue;\n        defaulted[key] = Visit(propertySchema, references, defaulted[key]);\n    }\n    // return if not additional properties\n    if (!IsDefaultSchema(additionalPropertiesSchema))\n        return defaulted;\n    // additional properties\n    for (const key of Object.getOwnPropertyNames(defaulted)) {\n        if (knownPropertyKey.test(key))\n            continue;\n        defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);\n    }\n    return defaulted;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, ValueOrDefault(schema, value));\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsArray(defaulted) || IsUndefined(schema.items))\n        return defaulted;\n    const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];\n    for (let i = 0; i < max; i++) {\n        if (i < items.length)\n            defaulted[i] = Visit(items[i], references, defaulted[i]);\n    }\n    return defaulted;\n}\nfunction FromUnion(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    for (const inner of schema.anyOf) {\n        const result = Visit(inner, references, defaulted);\n        if (IsCheckable(inner) && Check(inner, result)) {\n            return result;\n        }\n    }\n    return defaulted;\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return ValueOrDefault(schema_, value);\n    }\n}\n/** `[Mutable]` Generates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Default(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n",
  "import { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValuePointerRootSetError extends TypeBoxError {\n    value;\n    path;\n    update;\n    constructor(value, path, update) {\n        super('Cannot set root value');\n        this.value = value;\n        this.path = path;\n        this.update = update;\n    }\n}\nexport class ValuePointerRootDeleteError extends TypeBoxError {\n    value;\n    path;\n    constructor(value, path) {\n        super('Cannot delete root value');\n        this.value = value;\n        this.path = path;\n    }\n}\n// ------------------------------------------------------------------\n// ValuePointer\n// ------------------------------------------------------------------\n/** Provides functionality to update values through RFC6901 string pointers */\n// prettier-ignore\nfunction Escape(component) {\n    return component.indexOf('~') === -1 ? component : component.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Formats the given pointer into navigable key components */\n// prettier-ignore\nexport function* Format(pointer) {\n    if (pointer === '')\n        return;\n    let [start, end] = [0, 0];\n    for (let i = 0; i < pointer.length; i++) {\n        const char = pointer.charAt(i);\n        if (char === '/') {\n            if (i === 0) {\n                start = i + 1;\n            }\n            else {\n                end = i;\n                yield Escape(pointer.slice(start, end));\n                start = i + 1;\n            }\n        }\n        else {\n            end = i;\n        }\n    }\n    yield Escape(pointer.slice(start));\n}\n/** Sets the value at the given pointer. If the value at the pointer does not exist it is created */\n// prettier-ignore\nexport function Set(value, pointer, update) {\n    if (pointer === '')\n        throw new ValuePointerRootSetError(value, pointer, update);\n    let [owner, next, key] = [null, value, ''];\n    for (const component of Format(pointer)) {\n        if (next[component] === undefined)\n            next[component] = {};\n        owner = next;\n        next = next[component];\n        key = component;\n    }\n    owner[key] = update;\n}\n/** Deletes a value at the given pointer */\n// prettier-ignore\nexport function Delete(value, pointer) {\n    if (pointer === '')\n        throw new ValuePointerRootDeleteError(value, pointer);\n    let [owner, next, key] = [null, value, ''];\n    for (const component of Format(pointer)) {\n        if (next[component] === undefined || next[component] === null)\n            return;\n        owner = next;\n        next = next[component];\n        key = component;\n    }\n    if (Array.isArray(owner)) {\n        const index = parseInt(key);\n        owner.splice(index, 1);\n    }\n    else {\n        delete owner[key];\n    }\n}\n/** Returns true if a value exists at the given pointer */\n// prettier-ignore\nexport function Has(value, pointer) {\n    if (pointer === '')\n        return true;\n    let [owner, next, key] = [null, value, ''];\n    for (const component of Format(pointer)) {\n        if (next[component] === undefined)\n            return false;\n        owner = next;\n        next = next[component];\n        key = component;\n    }\n    return Object.getOwnPropertyNames(owner).includes(key);\n}\n/** Gets the value at the given pointer */\n// prettier-ignore\nexport function Get(value, pointer) {\n    if (pointer === '')\n        return value;\n    let current = value;\n    for (const component of Format(pointer)) {\n        if (current[component] === undefined)\n            return undefined;\n        current = current[component];\n    }\n    return current;\n}\n",
  "import { IsPlainObject, IsArray, IsTypedArray, IsValueType, IsSymbol, IsUndefined } from '../guard/index.mjs';\nimport { ValuePointer } from '../pointer/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Literal as CreateLiteral } from '../../type/literal/index.mjs';\nimport { Object as CreateObject } from '../../type/object/index.mjs';\nimport { String as CreateString } from '../../type/string/index.mjs';\nimport { Unknown as CreateUnknown } from '../../type/unknown/index.mjs';\nimport { Union as CreateUnion } from '../../type/union/index.mjs';\nexport const Insert = CreateObject({\n    type: CreateLiteral('insert'),\n    path: CreateString(),\n    value: CreateUnknown(),\n});\nexport const Update = CreateObject({\n    type: CreateLiteral('update'),\n    path: CreateString(),\n    value: CreateUnknown(),\n});\nexport const Delete = CreateObject({\n    type: CreateLiteral('delete'),\n    path: CreateString(),\n});\nexport const Edit = CreateUnion([Insert, Update, Delete]);\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueDeltaError extends TypeBoxError {\n    value;\n    constructor(value, message) {\n        super(message);\n        this.value = value;\n    }\n}\nexport class ValueDeltaSymbolError extends ValueDeltaError {\n    value;\n    constructor(value) {\n        super(value, 'Cannot diff objects with symbol keys');\n        this.value = value;\n    }\n}\n// ------------------------------------------------------------------\n// Command Factory\n// ------------------------------------------------------------------\nfunction CreateUpdate(path, value) {\n    return { type: 'update', path, value };\n}\nfunction CreateInsert(path, value) {\n    return { type: 'insert', path, value };\n}\nfunction CreateDelete(path) {\n    return { type: 'delete', path };\n}\n// ------------------------------------------------------------------\n// Diffing Generators\n// ------------------------------------------------------------------\nfunction* ObjectType(path, current, next) {\n    if (!IsPlainObject(next))\n        return yield CreateUpdate(path, next);\n    const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];\n    const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];\n    for (const key of currentKeys) {\n        if (IsSymbol(key))\n            throw new ValueDeltaSymbolError(key);\n        if (IsUndefined(next[key]) && nextKeys.includes(key))\n            yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);\n    }\n    for (const key of nextKeys) {\n        if (IsUndefined(current[key]) || IsUndefined(next[key]))\n            continue;\n        if (IsSymbol(key))\n            throw new ValueDeltaSymbolError(key);\n        yield* Visit(`${path}/${globalThis.String(key)}`, current[key], next[key]);\n    }\n    for (const key of nextKeys) {\n        if (IsSymbol(key))\n            throw new ValueDeltaSymbolError(key);\n        if (IsUndefined(current[key]))\n            yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);\n    }\n    for (const key of currentKeys.reverse()) {\n        if (IsSymbol(key))\n            throw new ValueDeltaSymbolError(key);\n        if (IsUndefined(next[key]) && !nextKeys.includes(key))\n            yield CreateDelete(`${path}/${globalThis.String(key)}`);\n    }\n}\nfunction* ArrayType(path, current, next) {\n    if (!IsArray(next))\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n    for (let i = 0; i < next.length; i++) {\n        if (i < current.length)\n            continue;\n        yield CreateInsert(`${path}/${i}`, next[i]);\n    }\n    for (let i = current.length - 1; i >= 0; i--) {\n        if (i < next.length)\n            continue;\n        yield CreateDelete(`${path}/${i}`);\n    }\n}\nfunction* TypedArrayType(path, current, next) {\n    if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n}\nfunction* ValueType(path, current, next) {\n    if (current === next)\n        return;\n    yield CreateUpdate(path, next);\n}\nfunction* Visit(path, current, next) {\n    if (IsPlainObject(current))\n        return yield* ObjectType(path, current, next);\n    if (IsArray(current))\n        return yield* ArrayType(path, current, next);\n    if (IsTypedArray(current))\n        return yield* TypedArrayType(path, current, next);\n    if (IsValueType(current))\n        return yield* ValueType(path, current, next);\n    throw new ValueDeltaError(current, 'Unable to create diff edits for unknown value');\n}\n// ------------------------------------------------------------------\n// Diff\n// ------------------------------------------------------------------\nexport function Diff(current, next) {\n    return [...Visit('', current, next)];\n}\n// ------------------------------------------------------------------\n// Patch\n// ------------------------------------------------------------------\nfunction IsRootUpdate(edits) {\n    return edits.length > 0 && edits[0].path === '' && edits[0].type === 'update';\n}\nfunction IsIdentity(edits) {\n    return edits.length === 0;\n}\nexport function Patch(current, edits) {\n    if (IsRootUpdate(edits)) {\n        return Clone(edits[0].value);\n    }\n    if (IsIdentity(edits)) {\n        return Clone(current);\n    }\n    const clone = Clone(current);\n    for (const edit of edits) {\n        switch (edit.type) {\n            case 'insert': {\n                ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'update': {\n                ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'delete': {\n                ValuePointer.Delete(clone, edit.path);\n                break;\n            }\n        }\n    }\n    return clone;\n}\n",
  "import { IsPlainObject, IsDate, IsArray, IsTypedArray, IsValueType } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Equality Checks\n// ------------------------------------------------------------------\nfunction ObjectType(left, right) {\n    if (!IsPlainObject(right))\n        return false;\n    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];\n    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];\n    if (leftKeys.length !== rightKeys.length)\n        return false;\n    return leftKeys.every((key) => Equal(left[key], right[key]));\n}\nfunction DateType(left, right) {\n    return IsDate(right) && left.getTime() === right.getTime();\n}\nfunction ArrayType(left, right) {\n    if (!IsArray(right) || left.length !== right.length)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction TypedArrayType(left, right) {\n    if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction ValueType(left, right) {\n    return left === right;\n}\n// ------------------------------------------------------------------\n// Equal\n// ------------------------------------------------------------------\n/** Returns true if the left value deep-equals the right */\nexport function Equal(left, right) {\n    if (IsPlainObject(left))\n        return ObjectType(left, right);\n    if (IsDate(left))\n        return DateType(left, right);\n    if (IsTypedArray(left))\n        return TypedArrayType(left, right);\n    if (IsArray(left))\n        return ArrayType(left, right);\n    if (IsValueType(left))\n        return ValueType(left, right);\n    throw new Error('ValueEquals: Unable to compare value');\n}\n",
  "import { IsPlainObject, IsArray, IsTypedArray, IsValueType } from '../guard/index.mjs';\nimport { ValuePointer } from '../pointer/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueMutateError extends TypeBoxError {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction ObjectType(root, path, current, next) {\n    if (!IsPlainObject(current)) {\n        ValuePointer.Set(root, path, Clone(next));\n    }\n    else {\n        const currentKeys = Object.keys(current);\n        const nextKeys = Object.keys(next);\n        for (const currentKey of currentKeys) {\n            if (!nextKeys.includes(currentKey)) {\n                delete current[currentKey];\n            }\n        }\n        for (const nextKey of nextKeys) {\n            if (!currentKeys.includes(nextKey)) {\n                current[nextKey] = null;\n            }\n        }\n        for (const nextKey of nextKeys) {\n            Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);\n        }\n    }\n}\nfunction ArrayType(root, path, current, next) {\n    if (!IsArray(current)) {\n        ValuePointer.Set(root, path, Clone(next));\n    }\n    else {\n        for (let index = 0; index < next.length; index++) {\n            Visit(root, `${path}/${index}`, current[index], next[index]);\n        }\n        current.splice(next.length);\n    }\n}\nfunction TypedArrayType(root, path, current, next) {\n    if (IsTypedArray(current) && current.length === next.length) {\n        for (let i = 0; i < current.length; i++) {\n            current[i] = next[i];\n        }\n    }\n    else {\n        ValuePointer.Set(root, path, Clone(next));\n    }\n}\nfunction ValueType(root, path, current, next) {\n    if (current === next)\n        return;\n    ValuePointer.Set(root, path, next);\n}\nfunction Visit(root, path, current, next) {\n    if (IsArray(next))\n        return ArrayType(root, path, current, next);\n    if (IsTypedArray(next))\n        return TypedArrayType(root, path, current, next);\n    if (IsPlainObject(next))\n        return ObjectType(root, path, current, next);\n    if (IsValueType(next))\n        return ValueType(root, path, current, next);\n}\n// ------------------------------------------------------------------\n// IsNonMutableValue\n// ------------------------------------------------------------------\nfunction IsNonMutableValue(value) {\n    return IsTypedArray(value) || IsValueType(value);\n}\nfunction IsMismatchedValue(current, next) {\n    // prettier-ignore\n    return ((IsPlainObject(current) && IsArray(next)) ||\n        (IsArray(current) && IsPlainObject(next)));\n}\n// ------------------------------------------------------------------\n// Mutate\n// ------------------------------------------------------------------\n/** `[Mutable]` Performs a deep mutable value assignment while retaining internal references */\nexport function Mutate(current, next) {\n    if (IsNonMutableValue(current) || IsNonMutableValue(next))\n        throw new ValueMutateError('Only object and array types can be mutated at the root level');\n    if (IsMismatchedValue(current, next))\n        throw new ValueMutateError('Cannot assign due type mismatch of assignable values');\n    Visit(current, '', current, next);\n}\n",
  "import { Kind, TransformKind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';\nimport { Index } from '../../type/indexed/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Check } from '../check/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsPlainObject, IsArray, IsValueType } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n// thrown externally\nexport class TransformDecodeCheckError extends TypeBoxError {\n    schema;\n    value;\n    error;\n    constructor(schema, value, error) {\n        super(`Unable to decode due to invalid value`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\nexport class TransformDecodeError extends TypeBoxError {\n    schema;\n    value;\n    constructor(schema, value, error) {\n        super(`${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.schema = schema;\n        this.value = value;\n    }\n}\n// ------------------------------------------------------------------\n// Decode\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Default(schema, value) {\n    try {\n        return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;\n    }\n    catch (error) {\n        throw new TransformDecodeError(schema, value, error);\n    }\n}\n// prettier-ignore\nfunction FromArray(schema, references, value) {\n    return (IsArray(value))\n        ? Default(schema, value.map((value) => Visit(schema.items, references, value)))\n        : Default(schema, value);\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, value) {\n    if (!IsPlainObject(value) || IsValueType(value))\n        return Default(schema, value);\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = knownKeys.reduce((value, key) => {\n        return (key in value)\n            ? { ...value, [key]: Visit(Index(schema, [key]), references, value[key]) }\n            : value;\n    }, value);\n    if (!IsTransform(schema.unevaluatedProperties)) {\n        return Default(schema, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const unknownProperties = unknownKeys.reduce((value, key) => {\n        return !knownKeys.includes(key)\n            ? { ...value, [key]: Default(unevaluatedProperties, value[key]) }\n            : value;\n    }, knownProperties);\n    return Default(schema, unknownProperties);\n}\nfunction FromNot(schema, references, value) {\n    return Default(schema, Visit(schema.not, references, value));\n}\n// prettier-ignore\nfunction FromObject(schema, references, value) {\n    if (!IsPlainObject(value))\n        return Default(schema, value);\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = knownKeys.reduce((value, key) => {\n        return (key in value)\n            ? { ...value, [key]: Visit(schema.properties[key], references, value[key]) }\n            : value;\n    }, value);\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const unknownProperties = unknownKeys.reduce((value, key) => {\n        return !knownKeys.includes(key)\n            ? { ...value, [key]: Default(additionalProperties, value[key]) }\n            : value;\n    }, knownProperties);\n    return Default(schema, unknownProperties);\n}\n// prettier-ignore\nfunction FromRecord(schema, references, value) {\n    if (!IsPlainObject(value))\n        return Default(schema, value);\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const knownKeys = new RegExp(pattern);\n    const knownProperties = Object.getOwnPropertyNames(value).reduce((value, key) => {\n        return knownKeys.test(key)\n            ? { ...value, [key]: Visit(schema.patternProperties[pattern], references, value[key]) }\n            : value;\n    }, value);\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const unknownProperties = unknownKeys.reduce((value, key) => {\n        return !knownKeys.test(key)\n            ? { ...value, [key]: Default(additionalProperties, value[key]) }\n            : value;\n    }, knownProperties);\n    return Default(schema, unknownProperties);\n}\n// prettier-ignore\nfunction FromRef(schema, references, value) {\n    const target = Deref(schema, references);\n    return Default(schema, Visit(target, references, value));\n}\n// prettier-ignore\nfunction FromThis(schema, references, value) {\n    const target = Deref(schema, references);\n    return Default(schema, Visit(target, references, value));\n}\n// prettier-ignore\nfunction FromTuple(schema, references, value) {\n    return (IsArray(value) && IsArray(schema.items))\n        ? Default(schema, schema.items.map((schema, index) => Visit(schema, references, value[index])))\n        : Default(schema, value);\n}\n// prettier-ignore\nfunction FromUnion(schema, references, value) {\n    for (const subschema of schema.anyOf) {\n        if (!Check(subschema, references, value))\n            continue;\n        // note: ensure interior is decoded first\n        const decoded = Visit(subschema, references, value);\n        return Default(schema, decoded);\n    }\n    return Default(schema, value);\n}\n// prettier-ignore\nfunction Visit(schema, references, value) {\n    const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Not':\n            return FromNot(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'Symbol':\n            return Default(schema_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return Default(schema_, value);\n    }\n}\n/**\n * `[Internal]` Decodes the value and returns the result. This function requires that\n * the caller `Check` the value before use. Passing unchecked values may result in\n * undefined behavior. Refer to the `Value.Decode()` for implementation details.\n */\nexport function TransformDecode(schema, references, value) {\n    return Visit(schema, references, value);\n}\n",
  "import { Kind, TransformKind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';\nimport { Index } from '../../type/indexed/index.mjs';\nimport { Deref } from '../deref/index.mjs';\nimport { Check } from '../check/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsPlainObject, IsArray, IsValueType } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class TransformEncodeCheckError extends TypeBoxError {\n    schema;\n    value;\n    error;\n    constructor(schema, value, error) {\n        super(`Unable to encode due to invalid value`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\nexport class TransformEncodeError extends TypeBoxError {\n    schema;\n    value;\n    constructor(schema, value, error) {\n        super(`${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.schema = schema;\n        this.value = value;\n    }\n}\n// ------------------------------------------------------------------\n// Encode\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Default(schema, value) {\n    try {\n        return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;\n    }\n    catch (error) {\n        throw new TransformEncodeError(schema, value, error);\n    }\n}\n// prettier-ignore\nfunction FromArray(schema, references, value) {\n    const defaulted = Default(schema, value);\n    return IsArray(defaulted)\n        ? defaulted.map((value) => Visit(schema.items, references, value))\n        : defaulted;\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, value) {\n    const defaulted = Default(schema, value);\n    if (!IsPlainObject(value) || IsValueType(value))\n        return defaulted;\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = knownKeys.reduce((value, key) => {\n        return key in defaulted\n            ? { ...value, [key]: Visit(Index(schema, [key]), references, value[key]) }\n            : value;\n    }, defaulted);\n    if (!IsTransform(schema.unevaluatedProperties)) {\n        return Default(schema, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    return unknownKeys.reduce((value, key) => {\n        return !knownKeys.includes(key)\n            ? { ...value, [key]: Default(unevaluatedProperties, value[key]) }\n            : value;\n    }, knownProperties);\n}\n// prettier-ignore\nfunction FromNot(schema, references, value) {\n    return Default(schema.not, Default(schema, value));\n}\n// prettier-ignore\nfunction FromObject(schema, references, value) {\n    const defaulted = Default(schema, value);\n    if (!IsPlainObject(value))\n        return defaulted;\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = knownKeys.reduce((value, key) => {\n        return key in value\n            ? { ...value, [key]: Visit(schema.properties[key], references, value[key]) }\n            : value;\n    }, defaulted);\n    if (!IsSchema(schema.additionalProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    return unknownKeys.reduce((value, key) => {\n        return !knownKeys.includes(key)\n            ? { ...value, [key]: Default(additionalProperties, value[key]) }\n            : value;\n    }, knownProperties);\n}\n// prettier-ignore\nfunction FromRecord(schema, references, value) {\n    const defaulted = Default(schema, value);\n    if (!IsPlainObject(value))\n        return defaulted;\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const knownKeys = new RegExp(pattern);\n    const knownProperties = Object.getOwnPropertyNames(value).reduce((value, key) => {\n        return knownKeys.test(key)\n            ? { ...value, [key]: Visit(schema.patternProperties[pattern], references, value[key]) }\n            : value;\n    }, defaulted);\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    return unknownKeys.reduce((value, key) => {\n        return !knownKeys.test(key)\n            ? { ...value, [key]: Default(additionalProperties, value[key]) }\n            : value;\n    }, knownProperties);\n}\n// prettier-ignore\nfunction FromRef(schema, references, value) {\n    const target = Deref(schema, references);\n    const resolved = Visit(target, references, value);\n    return Default(schema, resolved);\n}\n// prettier-ignore\nfunction FromThis(schema, references, value) {\n    const target = Deref(schema, references);\n    const resolved = Visit(target, references, value);\n    return Default(schema, resolved);\n}\n// prettier-ignore\nfunction FromTuple(schema, references, value) {\n    const value1 = Default(schema, value);\n    return IsArray(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, value1[index])) : [];\n}\n// prettier-ignore\nfunction FromUnion(schema, references, value) {\n    // test value against union variants\n    for (const subschema of schema.anyOf) {\n        if (!Check(subschema, references, value))\n            continue;\n        const value1 = Visit(subschema, references, value);\n        return Default(schema, value1);\n    }\n    // test transformed value against union variants\n    for (const subschema of schema.anyOf) {\n        const value1 = Visit(subschema, references, value);\n        if (!Check(schema, references, value1))\n            continue;\n        return Default(schema, value1);\n    }\n    return Default(schema, value);\n}\n// prettier-ignore\nfunction Visit(schema, references, value) {\n    const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Not':\n            return FromNot(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return Default(schema_, value);\n    }\n}\n/**\n * `[Internal]` Encodes the value and returns the result. This function expects the\n * caller to pass a statically checked value. This function does not check the encoded\n * result, meaning the result should be passed to `Check` before use. Refer to the\n * `Value.Encode()` function for implementation details.\n */\nexport function TransformEncode(schema, references, value) {\n    return Visit(schema, references, value);\n}\n",
  "import { Deref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema } from '../../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsString, IsUndefined } from '../guard/index.mjs';\n// prettier-ignore\nfunction FromArray(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromAsyncIterator(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromConstructor(schema, references) {\n    return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromFunction(schema, references) {\n    return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromIntersect(schema, references) {\n    return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromIterator(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromNot(schema, references) {\n    return IsTransform(schema) || Visit(schema.not, references);\n}\n// prettier-ignore\nfunction FromObject(schema, references) {\n    return (IsTransform(schema) ||\n        Object.values(schema.properties).some((schema) => Visit(schema, references)) ||\n        (IsSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references)));\n}\n// prettier-ignore\nfunction FromPromise(schema, references) {\n    return IsTransform(schema) || Visit(schema.item, references);\n}\n// prettier-ignore\nfunction FromRecord(schema, references) {\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[pattern];\n    return IsTransform(schema) || Visit(property, references) || (IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties));\n}\n// prettier-ignore\nfunction FromRef(schema, references) {\n    if (IsTransform(schema))\n        return true;\n    return Visit(Deref(schema, references), references);\n}\n// prettier-ignore\nfunction FromThis(schema, references) {\n    if (IsTransform(schema))\n        return true;\n    return Visit(Deref(schema, references), references);\n}\n// prettier-ignore\nfunction FromTuple(schema, references) {\n    return IsTransform(schema) || (!IsUndefined(schema.items) && schema.items.some((schema) => Visit(schema, references)));\n}\n// prettier-ignore\nfunction FromUnion(schema, references) {\n    return IsTransform(schema) || schema.anyOf.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction Visit(schema, references) {\n    const references_ = IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    if (schema.$id && visited.has(schema.$id))\n        return false;\n    if (schema.$id)\n        visited.add(schema.$id);\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_);\n        case 'Constructor':\n            return FromConstructor(schema_, references_);\n        case 'Function':\n            return FromFunction(schema_, references_);\n        case 'Intersect':\n            return FromIntersect(schema_, references_);\n        case 'Iterator':\n            return FromIterator(schema_, references_);\n        case 'Not':\n            return FromNot(schema_, references_);\n        case 'Object':\n            return FromObject(schema_, references_);\n        case 'Promise':\n            return FromPromise(schema_, references_);\n        case 'Record':\n            return FromRecord(schema_, references_);\n        case 'Ref':\n            return FromRef(schema_, references_);\n        case 'This':\n            return FromThis(schema_, references_);\n        case 'Tuple':\n            return FromTuple(schema_, references_);\n        case 'Union':\n            return FromUnion(schema_, references_);\n        default:\n            return IsTransform(schema);\n    }\n}\nconst visited = new Set();\n/** Returns true if this schema contains a transform codec */\nexport function HasTransform(schema, references) {\n    visited.clear();\n    return Visit(schema, references);\n}\n",
  "import { TransformDecode, TransformEncode, TransformDecodeCheckError, TransformEncodeCheckError } from '../transform/index.mjs';\nimport { Mutate as MutateValue } from '../mutate/index.mjs';\nimport { Hash as HashValue } from '../hash/index.mjs';\nimport { Equal as EqualValue } from '../equal/index.mjs';\nimport { Cast as CastValue } from '../cast/index.mjs';\nimport { Clone as CloneValue } from '../clone/index.mjs';\nimport { Convert as ConvertValue } from '../convert/index.mjs';\nimport { Create as CreateValue } from '../create/index.mjs';\nimport { Clean as CleanValue } from '../clean/index.mjs';\nimport { Check as CheckValue } from '../check/index.mjs';\nimport { Default as DefaultValue } from '../default/index.mjs';\nimport { Diff as DiffValue, Patch as PatchValue } from '../delta/index.mjs';\nimport { Errors as ValueErrors } from '../../errors/index.mjs';\n/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\nexport function Cast(...args) {\n    return CastValue.apply(CastValue, args);\n}\n/** Creates a value from the given type */\nexport function Create(...args) {\n    return CreateValue.apply(CreateValue, args);\n}\n/** Returns true if the value matches the given type */\nexport function Check(...args) {\n    return CheckValue.apply(CheckValue, args);\n}\n/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Clean(...args) {\n    return CleanValue.apply(CleanValue, args);\n}\n/** Converts any type mismatched values to their target type if a reasonable conversion is possible */\nexport function Convert(...args) {\n    return ConvertValue.apply(ConvertValue, args);\n}\n/** Returns a structural clone of the given value */\nexport function Clone(value) {\n    return CloneValue(value);\n}\n/** Decodes a value or throws if error */\nexport function Decode(...args) {\n    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n    if (!Check(schema, references, value))\n        throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());\n    return TransformDecode(schema, references, value);\n}\n/** `[Mutable]` Generates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Default(...args) {\n    return DefaultValue.apply(DefaultValue, args);\n}\n/** Encodes a value or throws if error */\nexport function Encode(...args) {\n    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n    const encoded = TransformEncode(schema, references, value);\n    if (!Check(schema, references, encoded))\n        throw new TransformEncodeCheckError(schema, value, Errors(schema, references, value).First());\n    return encoded;\n}\n/** Returns an iterator for each error in this value. */\nexport function Errors(...args) {\n    return ValueErrors.apply(ValueErrors, args);\n}\n/** Returns true if left and right values are structurally equal */\nexport function Equal(left, right) {\n    return EqualValue(left, right);\n}\n/** Returns edits to transform the current value into the next value */\nexport function Diff(current, next) {\n    return DiffValue(current, next);\n}\n/** Returns a FNV1A-64 non cryptographic hash of the given value */\nexport function Hash(value) {\n    return HashValue(value);\n}\n/** Returns a new value with edits applied to the given value */\nexport function Patch(current, edits) {\n    return PatchValue(current, edits);\n}\n/** `[Mutable]` Performs a deep mutable value assignment while retaining internal references. */\nexport function Mutate(current, next) {\n    MutateValue(current, next);\n}\n",
  "import { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsPromise } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T) {\n    return T.map(L => FromSchema(L));\n}\n// prettier-ignore\nfunction FromIntersect(T) {\n    return Intersect(FromRest(T));\n}\n// prettier-ignore\nfunction FromUnion(T) {\n    return Union(FromRest(T));\n}\n// prettier-ignore\nfunction FromPromise(T) {\n    return FromSchema(T);\n}\n// prettier-ignore\nfunction FromSchema(T) {\n    return (IsIntersect(T) ? FromIntersect(T.allOf) :\n        IsUnion(T) ? FromUnion(T.anyOf) :\n            IsPromise(T) ? FromPromise(T.item) :\n                T);\n}\n/** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\nexport function Awaited(T, options = {}) {\n    return CloneType(FromSchema(T), options);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Date type */\nexport function Date(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Date',\n        type: 'Date',\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Null type */\nexport function Null(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Null',\n        type: 'null',\n    };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Symbol type */\nexport function Symbol(options) {\n    return { ...options, [Kind]: 'Symbol', type: 'symbol' };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Undefined type */\nexport function Undefined(options = {}) {\n    return { ...options, [Kind]: 'Undefined', type: 'undefined' };\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Uint8Array type */\nexport function Uint8Array(options = {}) {\n    return { ...options, [Kind]: 'Uint8Array', type: 'Uint8Array' };\n}\n",
  "import { Any } from '../any/index.mjs';\nimport { BigInt } from '../bigint/index.mjs';\nimport { Date } from '../date/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Null } from '../null/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Symbol } from '../symbol/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { Undefined } from '../undefined/index.mjs';\nimport { Uint8Array } from '../uint8array/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { TypeClone } from '../clone/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsNumber, IsBigInt, IsUint8Array, IsDate, IsIterator, IsObject, IsAsyncIterator, IsFunction, IsUndefined, IsNull, IsSymbol, IsBoolean, IsString } from '../guard/value.mjs';\n// prettier-ignore\nfunction FromArray(T) {\n    return T.map(L => FromValue(L, false));\n}\n// prettier-ignore\nfunction FromProperties(value) {\n    return globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {\n        return { ...acc, [key]: Readonly(FromValue(value[key], false)) };\n    }, {});\n}\nfunction ConditionalReadonly(T, root) {\n    return (root === true ? T : Readonly(T));\n}\n// prettier-ignore\nfunction FromValue(value, root) {\n    return (IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) :\n        IsIterator(value) ? ConditionalReadonly(Any(), root) :\n            IsArray(value) ? Readonly(Tuple(FromArray(value))) :\n                IsUint8Array(value) ? Uint8Array() :\n                    IsDate(value) ? Date() :\n                        IsObject(value) ? ConditionalReadonly(Object(FromProperties(value)), root) :\n                            IsFunction(value) ? ConditionalReadonly(FunctionType([], Unknown()), root) :\n                                IsUndefined(value) ? Undefined() :\n                                    IsNull(value) ? Null() :\n                                        IsSymbol(value) ? Symbol() :\n                                            IsBigInt(value) ? BigInt() :\n                                                IsNumber(value) ? Literal(value) :\n                                                    IsBoolean(value) ? Literal(value) :\n                                                        IsString(value) ? Literal(value) :\n                                                            Object({}));\n}\n/** `[JavaScript]` Creates a readonly const type from the given value. */\nexport function Const(T, options = {}) {\n    return TypeClone.CloneType(FromValue(T, true), options);\n}\n",
  "import { Tuple } from '../tuple/index.mjs';\nimport { CloneRest } from '../clone/type.mjs';\n/** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\nexport function ConstructorParameters(schema, options = {}) {\n    return Tuple(CloneRest(schema.parameters), { ...options });\n}\n",
  "import { CloneType, CloneRest } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { IsUndefined } from '../guard/value.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsConstructor, IsFunction, IsIntersect, IsUnion, IsTuple, IsArray, IsObject, IsPromise, IsAsyncIterator, IsIterator, IsRef } from '../guard/type.mjs';\nfunction FromRest(schema, references) {\n    return schema.map((schema) => Deref(schema, references));\n}\n// prettier-ignore\nfunction FromProperties(properties, references) {\n    return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {\n        return { ...acc, [key]: Deref(properties[key], references) };\n    }, {});\n}\n// prettier-ignore\nfunction FromConstructor(schema, references) {\n    schema.parameters = FromRest(schema.parameters, references);\n    schema.returns = Deref(schema.returns, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromFunction(schema, references) {\n    schema.parameters = FromRest(schema.parameters, references);\n    schema.returns = Deref(schema.returns, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromIntersect(schema, references) {\n    schema.allOf = FromRest(schema.allOf, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromUnion(schema, references) {\n    schema.anyOf = FromRest(schema.anyOf, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromTuple(schema, references) {\n    if (IsUndefined(schema.items))\n        return schema;\n    schema.items = FromRest(schema.items, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromArray(schema, references) {\n    schema.items = Deref(schema.items, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromObject(schema, references) {\n    schema.properties = FromProperties(schema.properties, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromPromise(schema, references) {\n    schema.item = Deref(schema.item, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromAsyncIterator(schema, references) {\n    schema.items = Deref(schema.items, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromIterator(schema, references) {\n    schema.items = Deref(schema.items, references);\n    return schema;\n}\n// prettier-ignore\nfunction FromRef(schema, references) {\n    const target = references.find(remote => remote.$id === schema.$ref);\n    if (target === undefined)\n        throw Error(`Unable to dereference schema with $id ${schema.$ref}`);\n    const discard = Discard(target, ['$id']);\n    return Deref(discard, references);\n}\n// prettier-ignore\nexport function DerefResolve(schema, references) {\n    return (IsConstructor(schema) ? FromConstructor(schema, references) :\n        IsFunction(schema) ? FromFunction(schema, references) :\n            IsIntersect(schema) ? FromIntersect(schema, references) :\n                IsUnion(schema) ? FromUnion(schema, references) :\n                    IsTuple(schema) ? FromTuple(schema, references) :\n                        IsArray(schema) ? FromArray(schema, references) :\n                            IsObject(schema) ? FromObject(schema, references) :\n                                IsPromise(schema) ? FromPromise(schema, references) :\n                                    IsAsyncIterator(schema) ? FromAsyncIterator(schema, references) :\n                                        IsIterator(schema) ? FromIterator(schema, references) :\n                                            IsRef(schema) ? FromRef(schema, references) :\n                                                schema);\n}\n/** `[Json]` Creates a dereferenced type */\nexport function Deref(schema, references) {\n    return DerefResolve(CloneType(schema), CloneRest(references));\n}\n",
  "import { Literal } from '../literal/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/value.mjs';\n/** `[Json]` Creates a Enum type */\nexport function Enum(item, options = {}) {\n    if (IsUndefined(item))\n        throw new Error('Enum undefined or empty');\n    const values1 = globalThis.Object.getOwnPropertyNames(item)\n        .filter((key) => isNaN(key))\n        .map((key) => item[key]);\n    const values2 = [...new Set(values1)];\n    const anyOf = values2.map((value) => Literal(value));\n    return Union(anyOf, { ...options, [Hint]: 'Enum' });\n}\n",
  "import { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from '../extends/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { ExcludeFromMappedResult } from './exclude-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsTemplateLiteral, IsUnion } from '../guard/type.mjs';\n// prettier-ignore\nfunction ExcludeResolve(L, R) {\n    return (IsTemplateLiteral(L) ? ExcludeResolve(TemplateLiteralToUnion(L), R) :\n        IsTemplateLiteral(R) ? ExcludeResolve(L, TemplateLiteralToUnion(R)) :\n            IsUnion(L) ? (() => {\n                const narrowed = L.anyOf.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);\n                return (narrowed.length === 1 ? narrowed[0] : Union(narrowed));\n            })() :\n                ExtendsCheck(L, R) !== ExtendsResult.False ? Never() :\n                    L);\n}\n/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\nexport function Exclude(unionType, excludedMembers, options = {}) {\n    if (IsMappedResult(unionType)) {\n        return ExcludeFromMappedResult(unionType, excludedMembers, options);\n    }\n    else {\n        const E = ExcludeResolve(unionType, excludedMembers);\n        return CloneType(E, options);\n    }\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Exclude } from './exclude.mjs';\n// prettier-ignore\nfunction FromProperties(P, U, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Exclude(P[K2], U, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, T, options) {\n    return FromProperties(R.properties, T, options);\n}\n// prettier-ignore\nexport function ExcludeFromMappedResult(R, T, options) {\n    const P = FromMappedResult(R, T, options);\n    return MappedResult(P);\n}\n",
  "import { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from '../extends/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { ExtractFromMappedResult } from './extract-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsTemplateLiteral, IsUnion } from '../guard/type.mjs';\n// prettier-ignore\nfunction ExtractResolve(L, R) {\n    return (IsTemplateLiteral(L) ? ExtractResolve(TemplateLiteralToUnion(L), R) :\n        IsTemplateLiteral(R) ? ExtractResolve(L, TemplateLiteralToUnion(R)) :\n            IsUnion(L) ? (() => {\n                const narrowed = L.anyOf.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);\n                return (narrowed.length === 1 ? narrowed[0] : Union(narrowed));\n            })() :\n                ExtendsCheck(L, R) !== ExtendsResult.False ? L :\n                    Never());\n}\n/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\nexport function Extract(type, union, options = {}) {\n    if (IsMappedResult(type)) {\n        return ExtractFromMappedResult(type, union, options);\n    }\n    else {\n        const E = ExtractResolve(type, union);\n        return CloneType(E, options);\n    }\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Extract } from './extract.mjs';\n// prettier-ignore\nfunction FromProperties(P, T, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Extract(P[K2], T, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, T, options) {\n    return FromProperties(R.properties, T, options);\n}\n// prettier-ignore\nexport function ExtractFromMappedResult(R, T, options) {\n    const P = FromMappedResult(R, T, options);\n    return MappedResult(P);\n}\n",
  "import { CloneType } from '../clone/type.mjs';\n/** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\nexport function InstanceType(schema, options = {}) {\n    return CloneType(schema.returns, options);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Integer type */\nexport function Integer(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Integer',\n        type: 'integer',\n    };\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Intrinsic } from './intrinsic.mjs';\nimport { Literal } from '../literal/index.mjs';\n// prettier-ignore\nfunction MappedIntrinsicPropertyKey(K, M, options) {\n    return {\n        [K]: Intrinsic(Literal(K), M, options)\n    };\n}\n// prettier-ignore\nfunction MappedIntrinsicPropertyKeys(K, M, options) {\n    return K.reduce((Acc, L) => {\n        return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };\n    }, {});\n}\n// prettier-ignore\nfunction MappedIntrinsicProperties(T, M, options) {\n    return MappedIntrinsicPropertyKeys(T['keys'], M, options);\n}\n// prettier-ignore\nexport function IntrinsicFromMappedKey(T, M, options) {\n    const P = MappedIntrinsicProperties(T, M, options);\n    return MappedResult(P);\n}\n",
  "import { TemplateLiteral, TemplateLiteralParseExact, IsTemplateLiteralExpressionFinite, TemplateLiteralExpressionGenerate } from '../template-literal/index.mjs';\nimport { IntrinsicFromMappedKey } from './intrinsic-from-mapped-key.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsTemplateLiteral, IsUnion, IsLiteral } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// Apply\n// ------------------------------------------------------------------\nfunction ApplyUncapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return [first.toLowerCase(), rest].join('');\n}\nfunction ApplyCapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return [first.toUpperCase(), rest].join('');\n}\nfunction ApplyUppercase(value) {\n    return value.toUpperCase();\n}\nfunction ApplyLowercase(value) {\n    return value.toLowerCase();\n}\nfunction FromTemplateLiteral(schema, mode, options) {\n    // note: template literals require special runtime handling as they are encoded in string patterns.\n    // This diverges from the mapped type which would otherwise map on the template literal kind.\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    const finite = IsTemplateLiteralExpressionFinite(expression);\n    if (!finite)\n        return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };\n    const strings = [...TemplateLiteralExpressionGenerate(expression)];\n    const literals = strings.map((value) => Literal(value));\n    const mapped = FromRest(literals, mode);\n    const union = Union(mapped);\n    return TemplateLiteral([union], options);\n}\n// prettier-ignore\nfunction FromLiteralValue(value, mode) {\n    return (typeof value === 'string' ? (mode === 'Uncapitalize' ? ApplyUncapitalize(value) :\n        mode === 'Capitalize' ? ApplyCapitalize(value) :\n            mode === 'Uppercase' ? ApplyUppercase(value) :\n                mode === 'Lowercase' ? ApplyLowercase(value) :\n                    value) : value.toString());\n}\n// prettier-ignore\nfunction FromRest(T, M) {\n    return T.map(L => Intrinsic(L, M));\n}\n/** Applies an intrinsic string manipulation to the given type. */\nexport function Intrinsic(schema, mode, options = {}) {\n    // prettier-ignore\n    return (\n    // Intrinsic-Mapped-Inference\n    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) :\n        // Standard-Inference\n        IsTemplateLiteral(schema) ? FromTemplateLiteral(schema, mode, schema) :\n            IsUnion(schema) ? Union(FromRest(schema.anyOf, mode), options) :\n                IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) :\n                    schema);\n}\n",
  "import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Capitalize LiteralString types */\nexport function Capitalize(T, options = {}) {\n    return Intrinsic(T, 'Capitalize', options);\n}\n",
  "import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Lowercase LiteralString types */\nexport function Lowercase(T, options = {}) {\n    return Intrinsic(T, 'Lowercase', options);\n}\n",
  "import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\nexport function Uncapitalize(T, options = {}) {\n    return Intrinsic(T, 'Uncapitalize', options);\n}\n",
  "import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Uppercase LiteralString types */\nexport function Uppercase(T, options = {}) {\n    return Intrinsic(T, 'Uppercase', options);\n}\n",
  "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Not type */\nexport function Not(schema, options) {\n    return {\n        ...options,\n        [Kind]: 'Not',\n        not: CloneType(schema),\n    };\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Omit } from './omit.mjs';\n// prettier-ignore\nfunction FromProperties(P, K, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Omit(P[K2], K, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, K, options) {\n    return FromProperties(R.properties, K, options);\n}\n// prettier-ignore\nexport function OmitFromMappedResult(R, K, options) {\n    const P = FromMappedResult(R, K, options);\n    return MappedResult(P);\n}\n",
  "import { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { TransformKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { OmitFromMappedKey } from './omit-from-mapped-key.mjs';\nimport { OmitFromMappedResult } from './omit-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsIntersect, IsUnion, IsObject, IsSchema, IsMappedResult } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromIntersect(T, K) {\n    return T.map((T) => OmitResolve(T, K));\n}\n// prettier-ignore\nfunction FromUnion(T, K) {\n    return T.map((T) => OmitResolve(T, K));\n}\n// ------------------------------------------------------------------\n// FromProperty\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromProperty(T, K) {\n    const { [K]: _, ...R } = T;\n    return R;\n}\n// prettier-ignore\nfunction FromProperties(T, K) {\n    return K.reduce((T, K2) => {\n        return FromProperty(T, K2);\n    }, T);\n}\n// prettier-ignore\nexport function OmitResolve(T, K) {\n    return (IsIntersect(T) ? Intersect(FromIntersect(T.allOf, K)) :\n        IsUnion(T) ? Union(FromUnion(T.anyOf, K)) :\n            IsObject(T) ? Object(FromProperties(T.properties, K)) :\n                Object({}));\n}\nexport function Omit(T, K, options = {}) {\n    // mapped\n    if (IsMappedKey(K))\n        return OmitFromMappedKey(T, K, options);\n    if (IsMappedResult(T))\n        return OmitFromMappedResult(T, K, options);\n    // non-mapped\n    const I = IsSchema(K) ? IndexPropertyKeys(K) : K;\n    const D = Discard(T, [TransformKind, '$id', 'required']);\n    const R = CloneType(OmitResolve(T, I), options);\n    return { ...D, ...R };\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Omit } from './omit.mjs';\n// prettier-ignore\nfunction FromPropertyKey(T, K, options) {\n    return {\n        [K]: Omit(T, [K], options)\n    };\n}\n// prettier-ignore\nfunction FromPropertyKeys(T, K, options) {\n    return K.reduce((Acc, LK) => {\n        return { ...Acc, ...FromPropertyKey(T, LK, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(T, K, options) {\n    return FromPropertyKeys(T, K.keys, options);\n}\n// prettier-ignore\nexport function OmitFromMappedKey(T, K, options) {\n    const P = FromMappedKey(T, K, options);\n    return MappedResult(P);\n}\n",
  "import { Tuple } from '../tuple/index.mjs';\nimport { CloneRest } from '../clone/type.mjs';\n/** `[JavaScript]` Extracts the Parameters from the given Function type */\nexport function Parameters(schema, options = {}) {\n    return Tuple(CloneRest(schema.parameters), { ...options });\n}\n",
  "import { Optional } from '../optional/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { TransformKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { PartialFromMappedResult } from './partial-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsIntersect, IsUnion, IsObject } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T) {\n    return T.map(L => PartialResolve(L));\n}\n// prettier-ignore\nfunction FromProperties(T) {\n    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {\n        return { ...Acc, [K]: Optional(T[K]) };\n    }, {});\n}\n// prettier-ignore\nfunction PartialResolve(T) {\n    return (IsIntersect(T) ? Intersect(FromRest(T.allOf)) :\n        IsUnion(T) ? Union(FromRest(T.anyOf)) :\n            IsObject(T) ? Object(FromProperties(T.properties)) :\n                Object({}));\n}\n/** `[Json]` Constructs a type where all properties are optional */\nexport function Partial(T, options = {}) {\n    if (IsMappedResult(T))\n        return PartialFromMappedResult(T, options);\n    const D = Discard(T, [TransformKind, '$id', 'required']);\n    const R = CloneType(PartialResolve(T), options);\n    return { ...D, ...R };\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Partial } from './partial.mjs';\n// prettier-ignore\nfunction FromProperties(K, options) {\n    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Partial(K[K2], options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, options) {\n    return FromProperties(R.properties, options);\n}\n// prettier-ignore\nexport function PartialFromMappedResult(R, options) {\n    const P = FromMappedResult(R, options);\n    return MappedResult(P);\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Pick } from './pick.mjs';\n// prettier-ignore\nfunction FromProperties(P, K, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Pick(P[K2], K, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, K, options) {\n    return FromProperties(R.properties, K, options);\n}\n// prettier-ignore\nexport function PickFromMappedResult(R, K, options) {\n    const P = FromMappedResult(R, K, options);\n    return MappedResult(P);\n}\n",
  "import { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { TransformKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { PickFromMappedKey } from './pick-from-mapped-key.mjs';\nimport { PickFromMappedResult } from './pick-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsMappedResult, IsIntersect, IsUnion, IsObject, IsSchema } from '../guard/type.mjs';\nfunction FromIntersect(T, K) {\n    return T.map((T) => PickResolve(T, K));\n}\n// prettier-ignore\nfunction FromUnion(T, K) {\n    return T.map((T) => PickResolve(T, K));\n}\n// prettier-ignore\nfunction FromProperties(T, K) {\n    return K.reduce((Acc, K) => {\n        return K in T ? { ...Acc, [K]: T[K] } : Acc;\n    }, {});\n}\n// prettier-ignore\nexport function PickResolve(T, K) {\n    return (IsIntersect(T) ? Intersect(FromIntersect(T.allOf, K)) :\n        IsUnion(T) ? Union(FromUnion(T.anyOf, K)) :\n            IsObject(T) ? Object(FromProperties(T.properties, K)) :\n                Object({}));\n}\nexport function Pick(T, K, options = {}) {\n    // mapped\n    if (IsMappedKey(K))\n        return PickFromMappedKey(T, K, options);\n    if (IsMappedResult(T))\n        return PickFromMappedResult(T, K, options);\n    // non-mapped\n    const I = IsSchema(K) ? IndexPropertyKeys(K) : K;\n    const D = Discard(T, [TransformKind, '$id', 'required']);\n    const R = CloneType(PickResolve(T, I), options);\n    return { ...D, ...R };\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Pick } from './pick.mjs';\n// prettier-ignore\nfunction FromPropertyKey(T, K, options) {\n    return {\n        [K]: Pick(T, [K], options)\n    };\n}\n// prettier-ignore\nfunction FromPropertyKeys(T, K, options) {\n    return K.reduce((Acc, LK) => {\n        return { ...Acc, ...FromPropertyKey(T, LK, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(T, K, options) {\n    return FromPropertyKeys(T, K.keys, options);\n}\n// prettier-ignore\nexport function PickFromMappedKey(T, K, options) {\n    const P = FromMappedKey(T, K, options);\n    return MappedResult(P);\n}\n",
  "import { Readonly } from '../readonly/index.mjs';\nimport { Optional } from '../optional/index.mjs';\n/** `[Json]` Creates a Readonly and Optional property */\nexport function ReadonlyOptional(schema) {\n    return Readonly(Optional(schema));\n}\n",
  "import { Object } from '../object/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { IsTemplateLiteralFinite } from '../template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact } from '../patterns/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/value.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsInteger, IsLiteral, IsNumber, IsString, IsRegExp, IsTemplateLiteral, IsUnion } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// RecordCreateFromPattern\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromPattern(pattern, T, options) {\n    return {\n        ...options,\n        [Kind]: 'Record',\n        type: 'object',\n        patternProperties: { [pattern]: CloneType(T) }\n    };\n}\n// ------------------------------------------------------------------\n// RecordCreateFromKeys\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromKeys(K, T, options) {\n    const P = K.reduce((Acc, K) => ({ ...Acc, [K]: CloneType(T) }), {});\n    return Object(P, { ...options, [Hint]: 'Record' });\n}\n// prettier-ignore\nfunction FromTemplateLiteralKey(K, T, options) {\n    return (IsTemplateLiteralFinite(K)\n        ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)\n        : RecordCreateFromPattern(K.pattern, T, options));\n}\n// prettier-ignore\nfunction FromUnionKey(K, T, options) {\n    return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);\n}\n// prettier-ignore\nfunction FromLiteralKey(K, T, options) {\n    return RecordCreateFromKeys([K.toString()], T, options);\n}\n// prettier-ignore\nfunction FromRegExpKey(K, T, options) {\n    return RecordCreateFromPattern(K.source, T, options);\n}\n// prettier-ignore\nfunction FromStringKey(K, T, options) {\n    const pattern = IsUndefined(K.pattern) ? PatternStringExact : K.pattern;\n    return RecordCreateFromPattern(pattern, T, options);\n}\n// prettier-ignore\nfunction FromIntegerKey(_, T, options) {\n    return RecordCreateFromPattern(PatternNumberExact, T, options);\n}\n// prettier-ignore\nfunction FromNumberKey(_, T, options) {\n    return RecordCreateFromPattern(PatternNumberExact, T, options);\n}\n// ------------------------------------------------------------------\n// TRecordOrObject\n// ------------------------------------------------------------------\n/** `[Json]` Creates a Record type */\nexport function Record(K, T, options = {}) {\n    // prettier-ignore\n    return (IsUnion(K) ? FromUnionKey(K.anyOf, T, options) :\n        IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) :\n            IsLiteral(K) ? FromLiteralKey(K.const, T, options) :\n                IsInteger(K) ? FromIntegerKey(K, T, options) :\n                    IsNumber(K) ? FromNumberKey(K, T, options) :\n                        IsRegExp(K) ? FromRegExpKey(K, T, options) :\n                            IsString(K) ? FromStringKey(K, T, options) :\n                                Never(options));\n}\n",
  "import { CloneType } from '../clone/type.mjs';\nimport { IsUndefined } from '../guard/value.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\n// Auto Tracked For Recursive Types without ID's\nlet Ordinal = 0;\n/** `[Json]` Creates a Recursive type */\nexport function Recursive(callback, options = {}) {\n    if (IsUndefined(options.$id))\n        options.$id = `T${Ordinal++}`;\n    const thisType = callback({ [Kind]: 'This', $ref: `${options.$id}` });\n    thisType.$id = options.$id;\n    // prettier-ignore\n    return CloneType({ ...options, [Hint]: 'Recursive', ...thisType });\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsString, IsUndefined } from '../guard/value.mjs';\n/** `[Json]` Creates a Ref type. */\nexport function Ref(unresolved, options = {}) {\n    if (IsString(unresolved))\n        return { ...options, [Kind]: 'Ref', $ref: unresolved };\n    if (IsUndefined(unresolved.$id))\n        throw new Error('Reference target type must specify an $id');\n    return {\n        ...options,\n        [Kind]: 'Ref',\n        $ref: unresolved.$id,\n    };\n}\n",
  "import { IsString } from '../guard/value.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a RegExp type */\nexport function RegExp(unresolved, options = {}) {\n    const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;\n    return { ...options, [Kind]: 'RegExp', type: 'RegExp', source: expr.source, flags: expr.flags };\n}\n",
  "import { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { OptionalKind, TransformKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { RequiredFromMappedResult } from './required-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsIntersect, IsUnion, IsObject } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T) {\n    return T.map(L => RequiredResolve(L));\n}\n// prettier-ignore\nfunction FromProperties(T) {\n    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {\n        return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };\n    }, {});\n}\n// prettier-ignore\nfunction RequiredResolve(T) {\n    return (IsIntersect(T) ? Intersect(FromRest(T.allOf)) :\n        IsUnion(T) ? Union(FromRest(T.anyOf)) :\n            IsObject(T) ? Object(FromProperties(T.properties)) :\n                Object({}));\n}\n/** `[Json]` Constructs a type where all properties are required */\nexport function Required(T, options = {}) {\n    if (IsMappedResult(T)) {\n        return RequiredFromMappedResult(T, options);\n    }\n    else {\n        const D = Discard(T, [TransformKind, '$id', 'required']);\n        const R = CloneType(RequiredResolve(T), options);\n        return { ...D, ...R };\n    }\n}\n",
  "import { MappedResult } from '../mapped/index.mjs';\nimport { Required } from './required.mjs';\n// prettier-ignore\nfunction FromProperties(P, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Required(P[K2], options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, options) {\n    return FromProperties(R.properties, options);\n}\n// prettier-ignore\nexport function RequiredFromMappedResult(R, options) {\n    const P = FromMappedResult(R, options);\n    return MappedResult(P);\n}\n",
  "import { CloneRest } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsTuple } from '../guard/type.mjs';\n// prettier-ignore\nfunction RestResolve(T) {\n    return (IsIntersect(T) ? [...T.allOf] :\n        IsUnion(T) ? [...T.anyOf] :\n            IsTuple(T) ? [...(T.items ?? [])] :\n                []);\n}\n/** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\nexport function Rest(T) {\n    return CloneRest(RestResolve(T));\n}\n",
  "import { CloneType } from '../clone/type.mjs';\n/** `[JavaScript]` Extracts the ReturnType from the given Function type */\nexport function ReturnType(schema, options = {}) {\n    return CloneType(schema.returns, options);\n}\n",
  "/** `[Json]` Omits compositing symbols from this schema. */\nexport function Strict(schema) {\n    return JSON.parse(JSON.stringify(schema));\n}\n",
  "import { TransformKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// TransformBuilders\n// ------------------------------------------------------------------\nexport class TransformDecodeBuilder {\n    schema;\n    constructor(schema) {\n        this.schema = schema;\n    }\n    Decode(decode) {\n        return new TransformEncodeBuilder(this.schema, decode);\n    }\n}\n// prettier-ignore\nexport class TransformEncodeBuilder {\n    schema;\n    decode;\n    constructor(schema, decode) {\n        this.schema = schema;\n        this.decode = decode;\n    }\n    EncodeTransform(encode, schema) {\n        const Encode = (value) => schema[TransformKind].Encode(encode(value));\n        const Decode = (value) => this.decode(schema[TransformKind].Decode(value));\n        const Codec = { Encode: Encode, Decode: Decode };\n        return { ...schema, [TransformKind]: Codec };\n    }\n    EncodeSchema(encode, schema) {\n        const Codec = { Decode: this.decode, Encode: encode };\n        return { ...schema, [TransformKind]: Codec };\n    }\n    Encode(encode) {\n        const schema = CloneType(this.schema);\n        return (IsTransform(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema));\n    }\n}\n/** `[Json]` Creates a Transform type */\nexport function Transform(schema) {\n    return new TransformDecodeBuilder(schema);\n}\n",
  "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Void type */\nexport function Void(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Void',\n        type: 'void',\n    };\n}\n",
  "// ------------------------------------------------------------------\n// JsonTypeBuilder\n// ------------------------------------------------------------------\nexport { JsonTypeBuilder } from './json.mjs';\n// ------------------------------------------------------------------\n// JavaScriptTypeBuilder\n// ------------------------------------------------------------------\nimport * as TypeBuilder from './type.mjs';\nimport { JavaScriptTypeBuilder } from './javascript.mjs';\n/** JavaScript Type Builder with Static Resolution for TypeScript */\nconst Type = TypeBuilder;\nexport { JavaScriptTypeBuilder };\nexport { Type };\n",
  "import { TransformEncode, TransformDecode, HasTransform, TransformDecodeCheckError, TransformEncodeCheckError } from '../value/transform/index.mjs';\nimport { Errors } from '../errors/index.mjs';\nimport { TypeSystemPolicy } from '../system/index.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { Never } from '../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsString, IsNumber, IsBigInt } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// TypeCheck\n// ------------------------------------------------------------------\nexport class TypeCheck {\n    schema;\n    references;\n    checkFunc;\n    code;\n    hasTransform;\n    constructor(schema, references, checkFunc, code) {\n        this.schema = schema;\n        this.references = references;\n        this.checkFunc = checkFunc;\n        this.code = code;\n        this.hasTransform = HasTransform(schema, references);\n    }\n    /** Returns the generated assertion code used to validate this type. */\n    Code() {\n        return this.code;\n    }\n    /** Returns an iterator for each error in this value. */\n    Errors(value) {\n        return Errors(this.schema, this.references, value);\n    }\n    /** Returns true if the value matches the compiled type. */\n    Check(value) {\n        return this.checkFunc(value);\n    }\n    /** Decodes a value or throws if error */\n    Decode(value) {\n        if (!this.checkFunc(value))\n            throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());\n        return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;\n    }\n    /** Encodes a value or throws if error */\n    Encode(value) {\n        const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;\n        if (!this.checkFunc(encoded))\n            throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());\n        return encoded;\n    }\n}\n// ------------------------------------------------------------------\n// Character\n// ------------------------------------------------------------------\nvar Character;\n(function (Character) {\n    function DollarSign(code) {\n        return code === 36;\n    }\n    Character.DollarSign = DollarSign;\n    function IsUnderscore(code) {\n        return code === 95;\n    }\n    Character.IsUnderscore = IsUnderscore;\n    function IsAlpha(code) {\n        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\n    }\n    Character.IsAlpha = IsAlpha;\n    function IsNumeric(code) {\n        return code >= 48 && code <= 57;\n    }\n    Character.IsNumeric = IsNumeric;\n})(Character || (Character = {}));\n// ------------------------------------------------------------------\n// MemberExpression\n// ------------------------------------------------------------------\nvar MemberExpression;\n(function (MemberExpression) {\n    function IsFirstCharacterNumeric(value) {\n        if (value.length === 0)\n            return false;\n        return Character.IsNumeric(value.charCodeAt(0));\n    }\n    function IsAccessor(value) {\n        if (IsFirstCharacterNumeric(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);\n            if (!check)\n                return false;\n        }\n        return true;\n    }\n    function EscapeHyphen(key) {\n        return key.replace(/'/g, \"\\\\'\");\n    }\n    function Encode(object, key) {\n        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;\n    }\n    MemberExpression.Encode = Encode;\n})(MemberExpression || (MemberExpression = {}));\n// ------------------------------------------------------------------\n// Identifier\n// ------------------------------------------------------------------\nvar Identifier;\n(function (Identifier) {\n    function Encode($id) {\n        const buffer = [];\n        for (let i = 0; i < $id.length; i++) {\n            const code = $id.charCodeAt(i);\n            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {\n                buffer.push($id.charAt(i));\n            }\n            else {\n                buffer.push(`_${code}_`);\n            }\n        }\n        return buffer.join('').replace(/__/g, '_');\n    }\n    Identifier.Encode = Encode;\n})(Identifier || (Identifier = {}));\n// ------------------------------------------------------------------\n// LiteralString\n// ------------------------------------------------------------------\nvar LiteralString;\n(function (LiteralString) {\n    function Escape(content) {\n        return content.replace(/'/g, \"\\\\'\");\n    }\n    LiteralString.Escape = Escape;\n})(LiteralString || (LiteralString = {}));\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class TypeCompilerUnknownTypeError extends TypeBoxError {\n    schema;\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexport class TypeCompilerTypeGuardError extends TypeBoxError {\n    schema;\n    constructor(schema) {\n        super('Preflight validation check failed to guard for the given schema');\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// Policy\n// ------------------------------------------------------------------\nexport var Policy;\n(function (Policy) {\n    function IsExactOptionalProperty(value, key, expression) {\n        return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;\n    }\n    Policy.IsExactOptionalProperty = IsExactOptionalProperty;\n    function IsObjectLike(value) {\n        return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;\n    }\n    Policy.IsObjectLike = IsObjectLike;\n    function IsRecordLike(value) {\n        return !TypeSystemPolicy.AllowArrayObject\n            ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`\n            : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;\n    }\n    Policy.IsRecordLike = IsRecordLike;\n    function IsNumberLike(value) {\n        return !TypeSystemPolicy.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;\n    }\n    Policy.IsNumberLike = IsNumberLike;\n    function IsVoidLike(value) {\n        return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;\n    }\n    Policy.IsVoidLike = IsVoidLike;\n})(Policy || (Policy = {}));\n/** Compiles Types for Runtime Type Checking */\nexport var TypeCompiler;\n(function (TypeCompiler) {\n    // ----------------------------------------------------------------\n    // Guards\n    // ----------------------------------------------------------------\n    function IsAnyOrUnknown(schema) {\n        return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n    }\n    // ----------------------------------------------------------------\n    // Types\n    // ----------------------------------------------------------------\n    function* FromAny(schema, references, value) {\n        yield 'true';\n    }\n    function* FromArray(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        const [parameter, accumulator] = [CreateParameter('value', 'any'), CreateParameter('acc', 'number')];\n        if (IsNumber(schema.maxItems))\n            yield `${value}.length <= ${schema.maxItems}`;\n        if (IsNumber(schema.minItems))\n            yield `${value}.length >= ${schema.minItems}`;\n        const elementExpression = CreateExpression(schema.items, references, 'value');\n        yield `${value}.every((${parameter}) => ${elementExpression})`;\n        if (IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {\n            const containsSchema = IsSchema(schema.contains) ? schema.contains : Never();\n            const checkExpression = CreateExpression(containsSchema, references, 'value');\n            const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];\n            const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];\n            const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;\n            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(' && ');\n            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;\n        }\n        if (schema.uniqueItems === true) {\n            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;\n            const block = `const set = new Set(); for(const element of value) { ${check} }`;\n            yield `((${parameter}) => { ${block} )(${value})`;\n        }\n    }\n    function* FromAsyncIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;\n    }\n    function* FromBigInt(schema, references, value) {\n        yield `(typeof ${value} === 'bigint')`;\n        if (IsBigInt(schema.exclusiveMaximum))\n            yield `${value} < BigInt(${schema.exclusiveMaximum})`;\n        if (IsBigInt(schema.exclusiveMinimum))\n            yield `${value} > BigInt(${schema.exclusiveMinimum})`;\n        if (IsBigInt(schema.maximum))\n            yield `${value} <= BigInt(${schema.maximum})`;\n        if (IsBigInt(schema.minimum))\n            yield `${value} >= BigInt(${schema.minimum})`;\n        if (IsBigInt(schema.multipleOf))\n            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;\n    }\n    function* FromBoolean(schema, references, value) {\n        yield `(typeof ${value} === 'boolean')`;\n    }\n    function* FromConstructor(schema, references, value) {\n        yield* Visit(schema.returns, references, `${value}.prototype`);\n    }\n    function* FromDate(schema, references, value) {\n        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;\n        if (IsNumber(schema.exclusiveMaximumTimestamp))\n            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;\n        if (IsNumber(schema.exclusiveMinimumTimestamp))\n            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;\n        if (IsNumber(schema.maximumTimestamp))\n            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;\n        if (IsNumber(schema.minimumTimestamp))\n            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;\n        if (IsNumber(schema.multipleOfTimestamp))\n            yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;\n    }\n    function* FromFunction(schema, references, value) {\n        yield `(typeof ${value} === 'function')`;\n    }\n    function* FromInteger(schema, references, value) {\n        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;\n        if (IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if (IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* FromIntersect(schema, references, value) {\n        const check1 = schema.allOf.map((schema) => CreateExpression(schema, references, value)).join(' && ');\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;\n            yield `(${check1} && ${check2})`;\n        }\n        else if (IsSchema(schema.unevaluatedProperties)) {\n            const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;\n            yield `(${check1} && ${check2})`;\n        }\n        else {\n            yield `(${check1})`;\n        }\n    }\n    function* FromIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;\n    }\n    function* FromLiteral(schema, references, value) {\n        if (typeof schema.const === 'number' || typeof schema.const === 'boolean') {\n            yield `(${value} === ${schema.const})`;\n        }\n        else {\n            yield `(${value} === '${LiteralString.Escape(schema.const)}')`;\n        }\n    }\n    function* FromNever(schema, references, value) {\n        yield `false`;\n    }\n    function* FromNot(schema, references, value) {\n        const expression = CreateExpression(schema.not, references, value);\n        yield `(!${expression})`;\n    }\n    function* FromNull(schema, references, value) {\n        yield `(${value} === null)`;\n    }\n    function* FromNumber(schema, references, value) {\n        yield Policy.IsNumberLike(value);\n        if (IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if (IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* FromObject(schema, references, value) {\n        yield Policy.IsObjectLike(value);\n        if (IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const knownKeys = Object.getOwnPropertyNames(schema.properties);\n        for (const knownKey of knownKeys) {\n            const memberExpression = MemberExpression.Encode(value, knownKey);\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, memberExpression);\n                if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property))\n                    yield `('${knownKey}' in ${value})`;\n            }\n            else {\n                const expression = CreateExpression(property, references, memberExpression);\n                yield Policy.IsExactOptionalProperty(value, knownKey, expression);\n            }\n        }\n        if (schema.additionalProperties === false) {\n            if (schema.required && schema.required.length === knownKeys.length) {\n                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;\n            }\n            else {\n                const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);\n            const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;\n        }\n    }\n    function* FromPromise(schema, references, value) {\n        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;\n    }\n    function* FromRecord(schema, references, value) {\n        yield Policy.IsRecordLike(value);\n        if (IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n        const variable = CreateVariable(`${new RegExp(patternKey)}`);\n        const check1 = CreateExpression(patternSchema, references, 'value');\n        const check2 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? 'false' : 'true';\n        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;\n        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;\n    }\n    function* FromRef(schema, references, value) {\n        const target = Deref(schema, references);\n        // Reference: If we have seen this reference before we can just yield and return the function call.\n        // If this isn't the case we defer to visit to generate and set the function for subsequent passes.\n        if (state.functions.has(schema.$ref))\n            return yield `${CreateFunctionName(schema.$ref)}(${value})`;\n        yield* Visit(target, references, value);\n    }\n    function* FromRegExp(schema, references, value) {\n        const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);\n        yield `(typeof ${value} === 'string')`;\n        yield `${variable}.test(${value})`;\n    }\n    function* FromString(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        if (IsNumber(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if (IsNumber(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        if (schema.pattern !== undefined) {\n            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n            yield `${variable}.test(${value})`;\n        }\n        if (schema.format !== undefined) {\n            yield `format('${schema.format}', ${value})`;\n        }\n    }\n    function* FromSymbol(schema, references, value) {\n        yield `(typeof ${value} === 'symbol')`;\n    }\n    function* FromTemplateLiteral(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n        yield `${variable}.test(${value})`;\n    }\n    function* FromThis(schema, references, value) {\n        // Note: This types are assured to be hoisted prior to this call. Just yield the function.\n        yield `${CreateFunctionName(schema.$ref)}(${value})`;\n    }\n    function* FromTuple(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (schema.items === undefined)\n            return yield `${value}.length === 0`;\n        yield `(${value}.length === ${schema.maxItems})`;\n        for (let i = 0; i < schema.items.length; i++) {\n            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);\n            yield `${expression}`;\n        }\n    }\n    function* FromUndefined(schema, references, value) {\n        yield `${value} === undefined`;\n    }\n    function* FromUnion(schema, references, value) {\n        const expressions = schema.anyOf.map((schema) => CreateExpression(schema, references, value));\n        yield `(${expressions.join(' || ')})`;\n    }\n    function* FromUint8Array(schema, references, value) {\n        yield `${value} instanceof Uint8Array`;\n        if (IsNumber(schema.maxByteLength))\n            yield `(${value}.length <= ${schema.maxByteLength})`;\n        if (IsNumber(schema.minByteLength))\n            yield `(${value}.length >= ${schema.minByteLength})`;\n    }\n    function* FromUnknown(schema, references, value) {\n        yield 'true';\n    }\n    function* FromVoid(schema, references, value) {\n        yield Policy.IsVoidLike(value);\n    }\n    function* FromKind(schema, references, value) {\n        const instance = state.instances.size;\n        state.instances.set(instance, schema);\n        yield `kind('${schema[Kind]}', ${instance}, ${value})`;\n    }\n    function* Visit(schema, references, value, useHoisting = true) {\n        const references_ = IsString(schema.$id) ? [...references, schema] : references;\n        const schema_ = schema;\n        // --------------------------------------------------------------\n        // Hoisting\n        // --------------------------------------------------------------\n        if (useHoisting && IsString(schema.$id)) {\n            const functionName = CreateFunctionName(schema.$id);\n            if (state.functions.has(functionName)) {\n                return yield `${functionName}(${value})`;\n            }\n            else {\n                const functionCode = CreateFunction(functionName, schema, references, 'value', false);\n                state.functions.set(functionName, functionCode);\n                return yield `${functionName}(${value})`;\n            }\n        }\n        switch (schema_[Kind]) {\n            case 'Any':\n                return yield* FromAny(schema_, references_, value);\n            case 'Array':\n                return yield* FromArray(schema_, references_, value);\n            case 'AsyncIterator':\n                return yield* FromAsyncIterator(schema_, references_, value);\n            case 'BigInt':\n                return yield* FromBigInt(schema_, references_, value);\n            case 'Boolean':\n                return yield* FromBoolean(schema_, references_, value);\n            case 'Constructor':\n                return yield* FromConstructor(schema_, references_, value);\n            case 'Date':\n                return yield* FromDate(schema_, references_, value);\n            case 'Function':\n                return yield* FromFunction(schema_, references_, value);\n            case 'Integer':\n                return yield* FromInteger(schema_, references_, value);\n            case 'Intersect':\n                return yield* FromIntersect(schema_, references_, value);\n            case 'Iterator':\n                return yield* FromIterator(schema_, references_, value);\n            case 'Literal':\n                return yield* FromLiteral(schema_, references_, value);\n            case 'Never':\n                return yield* FromNever(schema_, references_, value);\n            case 'Not':\n                return yield* FromNot(schema_, references_, value);\n            case 'Null':\n                return yield* FromNull(schema_, references_, value);\n            case 'Number':\n                return yield* FromNumber(schema_, references_, value);\n            case 'Object':\n                return yield* FromObject(schema_, references_, value);\n            case 'Promise':\n                return yield* FromPromise(schema_, references_, value);\n            case 'Record':\n                return yield* FromRecord(schema_, references_, value);\n            case 'Ref':\n                return yield* FromRef(schema_, references_, value);\n            case 'RegExp':\n                return yield* FromRegExp(schema_, references_, value);\n            case 'String':\n                return yield* FromString(schema_, references_, value);\n            case 'Symbol':\n                return yield* FromSymbol(schema_, references_, value);\n            case 'TemplateLiteral':\n                return yield* FromTemplateLiteral(schema_, references_, value);\n            case 'This':\n                return yield* FromThis(schema_, references_, value);\n            case 'Tuple':\n                return yield* FromTuple(schema_, references_, value);\n            case 'Undefined':\n                return yield* FromUndefined(schema_, references_, value);\n            case 'Union':\n                return yield* FromUnion(schema_, references_, value);\n            case 'Uint8Array':\n                return yield* FromUint8Array(schema_, references_, value);\n            case 'Unknown':\n                return yield* FromUnknown(schema_, references_, value);\n            case 'Void':\n                return yield* FromVoid(schema_, references_, value);\n            default:\n                if (!TypeRegistry.Has(schema_[Kind]))\n                    throw new TypeCompilerUnknownTypeError(schema);\n                return yield* FromKind(schema_, references_, value);\n        }\n    }\n    // ----------------------------------------------------------------\n    // Compiler State\n    // ----------------------------------------------------------------\n    // prettier-ignore\n    const state = {\n        language: 'javascript', // target language\n        functions: new Map(), // local functions\n        variables: new Map(), // local variables\n        instances: new Map() // exterior kind instances\n    };\n    // ----------------------------------------------------------------\n    // Compiler Factory\n    // ----------------------------------------------------------------\n    function CreateExpression(schema, references, value, useHoisting = true) {\n        return `(${[...Visit(schema, references, value, useHoisting)].join(' && ')})`;\n    }\n    function CreateFunctionName($id) {\n        return `check_${Identifier.Encode($id)}`;\n    }\n    function CreateVariable(expression) {\n        const variableName = `local_${state.variables.size}`;\n        state.variables.set(variableName, `const ${variableName} = ${expression}`);\n        return variableName;\n    }\n    function CreateFunction(name, schema, references, value, useHoisting = true) {\n        const [newline, pad] = ['\\n', (length) => ''.padStart(length, ' ')];\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const expression = [...Visit(schema, references, value, useHoisting)].map((expression) => `${pad(4)}${expression}`).join(` &&${newline}`);\n        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\\n}`;\n    }\n    function CreateParameter(name, type) {\n        const annotation = state.language === 'typescript' ? `: ${type}` : '';\n        return `${name}${annotation}`;\n    }\n    function CreateReturns(type) {\n        return state.language === 'typescript' ? `: ${type}` : '';\n    }\n    // ----------------------------------------------------------------\n    // Compile\n    // ----------------------------------------------------------------\n    function Build(schema, references, options) {\n        const functionCode = CreateFunction('check', schema, references, 'value'); // will populate functions and variables\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const functions = [...state.functions.values()];\n        const variables = [...state.variables.values()];\n        // prettier-ignore\n        const checkFunction = IsString(schema.$id) // ensure top level schemas with $id's are hoisted\n            ? `return function check(${parameter})${returns} {\\n  return ${CreateFunctionName(schema.$id)}(value)\\n}`\n            : `return ${functionCode}`;\n        return [...variables, ...functions, checkFunction].join('\\n');\n    }\n    /** Generates the code used to assert this type and returns it as a string */\n    function Code(...args) {\n        const defaults = { language: 'javascript' };\n        // prettier-ignore\n        const [schema, references, options] = (args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] :\n            args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] :\n                args.length === 3 ? [args[0], args[1], args[2]] :\n                    args.length === 1 ? [args[0], [], defaults] :\n                        [null, [], defaults]);\n        // compiler-reset\n        state.language = options.language;\n        state.variables.clear();\n        state.functions.clear();\n        state.instances.clear();\n        if (!IsSchema(schema))\n            throw new TypeCompilerTypeGuardError(schema);\n        for (const schema of references)\n            if (!IsSchema(schema))\n                throw new TypeCompilerTypeGuardError(schema);\n        return Build(schema, references, options);\n    }\n    TypeCompiler.Code = Code;\n    /** Compiles a TypeBox type for optimal runtime type checking. Types must be valid TypeBox types of TSchema */\n    function Compile(schema, references = []) {\n        const generatedCode = Code(schema, references, { language: 'javascript' });\n        const compiledFunction = globalThis.Function('kind', 'format', 'hash', generatedCode);\n        const instances = new Map(state.instances);\n        function typeRegistryFunction(kind, instance, value) {\n            if (!TypeRegistry.Has(kind) || !instances.has(instance))\n                return false;\n            const checkFunc = TypeRegistry.Get(kind);\n            const schema = instances.get(instance);\n            return checkFunc(schema, value);\n        }\n        function formatRegistryFunction(format, value) {\n            if (!FormatRegistry.Has(format))\n                return false;\n            const checkFunc = FormatRegistry.Get(format);\n            return checkFunc(value);\n        }\n        function hashFunction(value) {\n            return Hash(value);\n        }\n        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);\n        return new TypeCheck(schema, references, checkFunction, generatedCode);\n    }\n    TypeCompiler.Compile = Compile;\n})(TypeCompiler || (TypeCompiler = {}));\n",
  "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.partitioned) {\n    str += '; Partitioned'\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} val\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n",
  "// @ts-ignore\nimport { parse } from 'cookie'\nimport type { Context } from './context'\n\nimport { isNumericString, unsignCookie } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\ntype MutateCookie<T = unknown> = CookieOptions & {\n\tvalue?: T\n} extends infer A\n\t? A | ((previous: A) => A)\n\t: never\n\ntype CookieJar = Record<string, Cookie>\n\nexport class Cookie<T = unknown> implements CookieOptions {\n\tpublic name: string | undefined\n\tprivate setter: Context['set'] | undefined\n\n\tconstructor(\n\t\tprivate _value: T,\n\t\tpublic property: Readonly<CookieOptions> = {}\n\t) {}\n\n\tget() {\n\t\treturn this._value\n\t}\n\n\tget value(): T {\n\t\treturn this._value as any\n\t}\n\n\tset value(value: T) {\n\t\tif (typeof value === 'object') {\n\t\t\tif (JSON.stringify(this.value) === JSON.stringify(value)) return\n\t\t} else if (this.value === value) return\n\n\t\tthis._value = value as any\n\n\t\tthis.sync()\n\t}\n\n\tadd<T>(config: MutateCookie<T>): Cookie<T> {\n\t\tconst updated = Object.assign(\n\t\t\tthis.property,\n\t\t\ttypeof config === 'function'\n\t\t\t\t? config(Object.assign(this.property, this.value) as any)\n\t\t\t\t: config\n\t\t)\n\n\t\tif ('value' in updated) {\n\t\t\tthis._value = updated.value as any\n\n\t\t\tdelete updated.value\n\t\t}\n\n\t\tthis.property = updated\n\t\treturn this.sync() as any\n\t}\n\n\tset<T>(config: MutateCookie): Cookie<T> {\n\t\tconst updated =\n\t\t\ttypeof config === 'function'\n\t\t\t\t? config(Object.assign(this.property, this.value) as any)\n\t\t\t\t: config\n\n\t\tif ('value' in updated) {\n\t\t\tthis._value = updated.value as any\n\n\t\t\tdelete updated.value\n\t\t}\n\n\t\tthis.property = updated\n\t\treturn this.sync() as any\n\t}\n\n\tremove(\n\t\toptions?: Pick<CookieOptions, 'domain' | 'path' | 'sameSite' | 'secure'>\n\t) {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\tdomain: options?.domain,\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tpath: options?.path,\n\t\t\tsameSite: options?.sameSite,\n\t\t\tsecure: options?.secure,\n\t\t\tvalue: '' as any\n\t\t})\n\t}\n\n\tget domain() {\n\t\treturn this.property.domain\n\t}\n\n\tset domain(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.domain === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.domain = value\n\n\t\tthis.sync()\n\t}\n\n\tget expires() {\n\t\treturn this.property.expires\n\t}\n\n\tset expires(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.expires?.getTime() === value?.getTime()) return\n\n\t\t// @ts-ignore\n\t\tthis.property.expires = value\n\n\t\tthis.sync()\n\t}\n\n\tget httpOnly() {\n\t\treturn this.property.httpOnly\n\t}\n\n\tset httpOnly(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.domain === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.httpOnly = value\n\n\t\tthis.sync()\n\t}\n\n\tget maxAge() {\n\t\treturn this.property.maxAge\n\t}\n\n\tset maxAge(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.maxAge === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.maxAge = value\n\n\t\tthis.sync()\n\t}\n\n\tget path() {\n\t\treturn this.property.path\n\t}\n\n\tset path(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.path === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.path = value\n\n\t\tthis.sync()\n\t}\n\n\tget priority() {\n\t\treturn this.property.priority\n\t}\n\n\tset priority(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.priority === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.priority = value\n\n\t\tthis.sync()\n\t}\n\n\tget sameSite() {\n\t\treturn this.property.sameSite\n\t}\n\n\tset sameSite(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.sameSite === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.sameSite = value\n\n\t\tthis.sync()\n\t}\n\n\tget secure() {\n\t\treturn this.property.secure\n\t}\n\n\tset secure(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.secure === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.secure = value\n\n\t\tthis.sync()\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: this.value?.toString() ?? ''\n\t}\n\n\tprivate sync() {\n\t\tif (!this.name || !this.setter) return this\n\n\t\tif (!this.setter.cookie)\n\t\t\tthis.setter.cookie = {\n\t\t\t\t[this.name]: Object.assign(this.property, {\n\t\t\t\t\tvalue: this.toString()\n\t\t\t\t})\n\t\t\t}\n\t\telse\n\t\t\tthis.setter.cookie[this.name] = Object.assign(this.property, {\n\t\t\t\tvalue: this.toString()\n\t\t\t})\n\n\t\treturn this\n\t}\n}\n\nexport const createCookieJar = (\n\tinitial: CookieJar,\n\tset: Context['set'],\n\tproperties?: CookieOptions\n) =>\n\tnew Proxy(initial as CookieJar, {\n\t\tget(target, key: string) {\n\t\t\tif (key in target) return target[key]\n\n\t\t\t// @ts-ignore\n\t\t\tconst cookie = new Cookie(\n\t\t\t\tundefined,\n\t\t\t\tproperties ? { ...properties } : undefined\n\t\t\t)\n\t\t\t// @ts-ignore\n\t\t\tcookie.setter = set\n\t\t\tcookie.name = key\n\n\t\t\t// @ts-ignore\n\t\t\treturn cookie\n\t\t},\n\t\tset(target, key: string, value) {\n\t\t\tif (!(value instanceof Cookie)) return false\n\n\t\t\tif (!set.cookie) set.cookie = {}\n\n\t\t\t// @ts-ignore\n\t\t\tvalue.setter = set\n\t\t\tvalue.name = key\n\n\t\t\t// @ts-ignore\n\t\t\tvalue.sync()\n\n\t\t\ttarget[key] = value\n\n\t\t\treturn true\n\t\t}\n\t})\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecret,\n\t\tsign,\n\t\t...properties\n\t}: CookieOptions & {\n\t\tsecret?: string | string[]\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar({}, set, properties)\n\n\tconst jar: CookieJar = {}\n\tconst isStringKey = typeof secret === 'string'\n\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst cookieKeys = Object.keys(parse(cookieString))\n\tfor (let i = 0; i < cookieKeys.length; i++) {\n\t\tconst key = cookieKeys[i]\n\t\tlet value = parse(cookieString)[key]\n\n\t\tif (sign === true || sign?.includes(key)) {\n\t\t\tif (!secret)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = await unsignCookie(value as string, secret)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (value === false) throw new InvalidCookieSignature(key)\n\t\t\t} else {\n\t\t\t\tlet fail = true\n\t\t\t\tfor (let i = 0; i < secret.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secret[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tfail = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fail) throw new InvalidCookieSignature(key)\n\t\t\t}\n\t\t}\n\n\t\tif (value === undefined) continue\n\n\t\tconst start = (value as string).charCodeAt(0)\n\t\tif (start === 123 || start === 91)\n\t\t\ttry {\n\t\t\t\tconst cookie = new Cookie(JSON.parse(value as string))\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tcookie.setter = set\n\t\t\t\tcookie.name = key\n\n\t\t\t\tjar[key] = cookie\n\n\t\t\t\tcontinue\n\t\t\t} catch {\n\t\t\t\t// Not empty\n\t\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNumericString(value)) value = +value\n\t\t// @ts-ignore\n\t\telse if (value === 'true') value = true\n\t\t// @ts-ignore\n\t\telse if (value === 'false') value = false\n\n\t\tconst cookie = new Cookie(value, properties)\n\n\t\t// @ts-ignore\n\t\tcookie.setter = set\n\t\tcookie.name = key\n\n\t\tjar[key] = cookie\n\t}\n\n\treturn createCookieJar(jar, set)\n}\n",
  "// @ts-ignore\nimport { serialize } from 'cookie'\nimport { StatusMap } from './utils'\n\nimport type { Context } from './context'\nimport { Cookie } from './cookie'\nimport { ELYSIA_RESPONSE } from './error'\n\nconst hasHeaderShorthand = 'toJSON' in new Headers()\n\ntype SetResponse = Omit<Context['set'], 'status'> & {\n\tstatus: number\n}\n\nexport const isNotEmpty = (obj: Object) => {\n\tfor (const x in obj) return true\n\n\treturn false\n}\n\nconst handleFile = (response: File | Blob, set?: Context['set']) => {\n\tconst size = response.size\n\n\tif (\n\t\t(size &&\n\t\t\tset &&\n\t\t\tset.status !== 206 &&\n\t\t\tset.status !== 304 &&\n\t\t\tset.status !== 412 &&\n\t\t\tset.status !== 416) ||\n\t\t(!set && size)\n\t) {\n\t\tif (set) {\n\t\t\tif (set.headers instanceof Headers)\n\t\t\t\tif (hasHeaderShorthand) set.headers = set.headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of set.headers.entries())\n\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\treturn new Response(response as Blob, {\n\t\t\t\tstatus: set.status as number,\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`\n\t\t\t\t\t},\n\t\t\t\t\tset.headers\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\treturn new Response(response as Blob, {\n\t\t\theaders: {\n\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`\n\t\t\t}\n\t\t})\n\t}\n\n\treturn new Response(response as Blob)\n}\n\nexport const parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\tif (!headers || !Array.isArray(setCookie)) return headers\n\n\theaders.delete('Set-Cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'Set-Cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nexport const cookieToHeader = (cookies: Context['set']['cookie']) => {\n\tif (!cookies || typeof cookies !== 'object' || !isNotEmpty(cookies))\n\t\treturn undefined\n\n\tconst set: string[] = []\n\n\tfor (const [key, property] of Object.entries(cookies)) {\n\t\tif (!key || !property) continue\n\n\t\tif (Array.isArray(property.value)) {\n\t\t\tfor (let i = 0; i < property.value.length; i++) {\n\t\t\t\tlet value = property.value[i]\n\t\t\t\tif (value === undefined || value === null) continue\n\n\t\t\t\tif (typeof value === 'object') value = JSON.stringify(value)\n\n\t\t\t\tset.push(serialize(key, value, property))\n\t\t\t}\n\t\t} else {\n\t\t\tlet value = property.value\n\t\t\tif (value === undefined || value === null) continue\n\n\t\t\tif (typeof value === 'object') value = JSON.stringify(value)\n\n\t\t\tset.push(serialize(key, property.value, property))\n\t\t}\n\t}\n\n\tif (set.length === 0) return undefined\n\tif (set.length === 1) return set[0]\n\n\treturn set\n}\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set']\n): Response => {\n\t// @ts-ignore\n\tif (response?.[response.$passthrough])\n\t\t// @ts-ignore\n\t\tresponse = response[response.$passthrough]\n\n\t// @ts-ignore\n\tif (response?.[ELYSIA_RESPONSE]) {\n\t\t// @ts-ignore\n\t\tset.status = response[ELYSIA_RESPONSE]\n\t\t// @ts-ignore\n\t\tresponse = response.response\n\t}\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie))\n\t\t\tset.headers['Set-Cookie'] = cookieToHeader(set.cookie)\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers),\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as SetResponse)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as SetResponse)\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = { ...set.headers }\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn response.then((x) => mapResponse(x, set))\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123) {\n\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\treturn new Response(\n\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t) as any\n\t\t\t\t}\n\n\t\t\t\treturn new Response(r, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapCompactResponse(x)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn new Response('')\n\t\t\t\t})\n\n\t\t\t// ? Maybe response or Blob\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\n\t\t\t\treturn new Response(r)\n\t\t}\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set']\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\tif (\n\t\t// @ts-ignore\n\t\tresponse?.$passthrough\n\t)\n\t\t// @ts-ignore\n\t\tresponse = response[response.$passthrough]\n\n\t// @ts-ignore\n\tif (response?.[ELYSIA_RESPONSE]) {\n\t\t// @ts-ignore\n\t\tset.status = response[ELYSIA_RESPONSE]\n\t\t// @ts-ignore\n\t\tresponse = response.response\n\t}\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie))\n\t\t\tset.headers['Set-Cookie'] = cookieToHeader(set.cookie)\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers),\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as SetResponse)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = Object.assign({}, set.headers)\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (!(key in set.headers)) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123) {\n\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\treturn new Response(\n\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t) as any\n\t\t\t\t}\n\n\t\t\t\treturn new Response(r, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\n\t\t\t\treturn new Response(r)\n\t\t}\n}\n\nexport const mapCompactResponse = (response: unknown): Response => {\n\tif (\n\t\t// @ts-ignore\n\t\tresponse?.$passthrough\n\t)\n\t\t// @ts-ignore\n\t\tresponse = response[response.$passthrough]\n\n\t// @ts-ignore\n\tif (response?.[ELYSIA_RESPONSE])\n\t\t// @ts-ignore\n\t\treturn mapResponse(response.response, {\n\t\t\t// @ts-ignore\n\t\t\tstatus: response[ELYSIA_RESPONSE],\n\t\t\theaders: {}\n\t\t})\n\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\t\treturn new Response(response as string)\n\n\t\tcase 'Blob':\n\t\t\treturn handleFile(response as File | Blob)\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'ReadableStream':\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\t// @ts-ignore\n\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\tconst r = mapCompactResponse(x)\n\n\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\treturn new Response('')\n\t\t\t})\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tdefault:\n\t\t\tconst r = JSON.stringify(response)\n\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t}) as any\n\n\t\t\treturn new Response(r)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus: set?.status !== 200 ? (set?.status as number) ?? 500 : 500,\n\t\t\theaders: set?.headers\n\t\t}\n\t)\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro\n} from './types'\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nexport const mergeDeep = <\n\tconst A extends Record<string, any>,\n\tconst B extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (!(key in target)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\n\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ttarget: A,\n\tsource: B\n): A & B =>\n\tmergeDeep(target, source, {\n\t\tskipKeys: ['properties']\n\t})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\tif (!a) return []\n\n\t// ! Must copy to remove side-effect\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) {\n\t\t\tarray.push(item)\n\t\t}\n\t}\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'onResponse',\n\t'mapResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nexport const mergeHook = (\n\ta?: LocalHook<any, any, any, any> | LifeCycleStore,\n\tb?: LocalHook<any, any, any, any>\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\treturn {\n\t\t...a,\n\t\t...b,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a?.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta?.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta?.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta?.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta?.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta?.mapResponse ?? [],\n\t\t\tb?.mapResponse ?? []\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []) as any,\n\t\terror: mergeObjectArray(a?.error ?? [], b?.error ?? [])\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema, Object.values(models))\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema, references)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema\n\t\t\t\t\t\t? compile(schema, Object.values(models))\n\t\t\t\t\t\t: schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tif (hasHash) return Bun.hash(s) as number\n\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\t// @ts-ignore\n\t\tif (checksum && !x.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\t...a,\n\t\t...b,\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse as any,\n\t\t\t'parse' in b ? b?.parse ?? [] : undefined ?? ([] as any)\n\t\t).map(injectChecksum),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse as any,\n\t\t\t(b?.mapResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\ttrace: a.trace,\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop ?? [] : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = (\n\thook: LocalHook<any, any>,\n\tinject = true\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as LocalHook<any, any>\n}\n\nexport const asGlobal = <T extends MaybeArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends MaybeArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any>\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as LocalHook<any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport type HTTPStatusName = keyof typeof StatusMap\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst encoder = new TextEncoder()\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\tconst hmacArray = Array.from(new Uint8Array(hmacBuffer))\n\tconst digest = btoa(String.fromCharCode(...hmacArray))\n\treturn `${val}.${digest.replace(/=+$/, '')}`\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: BaseMacro,\n\tproperty: Record<string, unknown>,\n\thooks = property\n) => {\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (primitiveHooks.includes(key as any) || !(key in extension)) continue\n\n\t\tif (typeof extension[key] === 'function') {\n\t\t\textension[key](value)\n\t\t} else if (typeof extension[key] === 'object')\n\t\t\ttraceBackMacro(extension[key], value as any, hooks)\n\t}\n}\n\nexport const isNumericString = (message: string) =>\n\t!Number.isNaN(parseInt(message))\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro\n} from './types'\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nexport const mergeDeep = <\n\tconst A extends Record<string, any>,\n\tconst B extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (!(key in target)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\n\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ttarget: A,\n\tsource: B\n): A & B =>\n\tmergeDeep(target, source, {\n\t\tskipKeys: ['properties']\n\t})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\tif (!a) return []\n\n\t// ! Must copy to remove side-effect\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) {\n\t\t\tarray.push(item)\n\t\t}\n\t}\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'onResponse',\n\t'mapResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nexport const mergeHook = (\n\ta?: LocalHook<any, any, any, any> | LifeCycleStore,\n\tb?: LocalHook<any, any, any, any>\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\treturn {\n\t\t...a,\n\t\t...b,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a?.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta?.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta?.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta?.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta?.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta?.mapResponse ?? [],\n\t\t\tb?.mapResponse ?? []\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []) as any,\n\t\terror: mergeObjectArray(a?.error ?? [], b?.error ?? [])\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema, Object.values(models))\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema, references)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema\n\t\t\t\t\t\t? compile(schema, Object.values(models))\n\t\t\t\t\t\t: schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tif (hasHash) return Bun.hash(s) as number\n\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\t// @ts-ignore\n\t\tif (checksum && !x.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\t...a,\n\t\t...b,\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse as any,\n\t\t\t'parse' in b ? b?.parse ?? [] : undefined ?? ([] as any)\n\t\t).map(injectChecksum),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse as any,\n\t\t\t(b?.mapResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\ttrace: a.trace,\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop ?? [] : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = (\n\thook: LocalHook<any, any>,\n\tinject = true\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as LocalHook<any, any>\n}\n\nexport const asGlobal = <T extends MaybeArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends MaybeArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any>\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as LocalHook<any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport type HTTPStatusName = keyof typeof StatusMap\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst encoder = new TextEncoder()\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\tconst hmacArray = Array.from(new Uint8Array(hmacBuffer))\n\tconst digest = btoa(String.fromCharCode(...hmacArray))\n\treturn `${val}.${digest.replace(/=+$/, '')}`\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: BaseMacro,\n\tproperty: Record<string, unknown>,\n\thooks = property\n) => {\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (primitiveHooks.includes(key as any) || !(key in extension)) continue\n\n\t\tif (typeof extension[key] === 'function') {\n\t\t\textension[key](value)\n\t\t} else if (typeof extension[key] === 'object')\n\t\t\ttraceBackMacro(extension[key], value as any, hooks)\n\t}\n}\n\nexport const isNumericString = (message: string) =>\n\t!Number.isNaN(parseInt(message))\n",
  "import { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\nimport { TSchema } from '@sinclair/typebox'\n\nimport { StatusMap } from './utils'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t  ? process?.env\n\t\t  : undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport const ELYSIA_RESPONSE = Symbol('ElysiaResponse')\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\n\nexport const error = <\n\tconst Code extends number | keyof typeof StatusMap,\n\tconst T\n>(\n\tcode: Code,\n\tresponse: T\n): {\n\t[ELYSIA_RESPONSE]: Code extends keyof typeof StatusMap\n\t\t? (typeof StatusMap)[Code]\n\t\t: Code\n\tresponse: T\n} =>\n\t({\n\t\t// @ts-ignore\n\t\t[ELYSIA_RESPONSE]: StatusMap[code] ?? code,\n\t\tresponse\n\t}) as const\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'PARSE')\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic key: string,\n\t\tmessage?: string\n\t) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\tconst error = isProduction\n\t\t\t? undefined\n\t\t\t: 'Errors' in validator\n\t\t\t? validator.Errors(value).First()\n\t\t\t: Value.Errors(validator, value).First()\n\n\t\tconst customError = error?.schema.error\n\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t? error.schema.error(type, validator, value)\n\t\t\t\t: error.schema.error\n\t\t\t: undefined\n\n\t\tconst accessor = error?.path?.slice(1) || 'root'\n\t\tlet message = ''\n\n\t\tif (customError) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype,\n\t\t\t\tmessage: error?.message\n\t\t\t})\n\t\t} else {\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype,\n\t\t\t\t\tat: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected: Value.Create(\n\t\t\t\t\t\t// @ts-ignore private field\n\t\t\t\t\t\tvalidator.schema\n\t\t\t\t\t),\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors: [...validator.Errors(value)]\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn [...this.validator.Errors(this.value)]\n\t}\n\n\tstatic simplifyModel(validator: TSchema | TypeCheck<any>) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders\n\t\t})\n\t}\n}\n",
  "import type { ServerWebSocket, WebSocketHandler } from 'bun'\n\nimport type { TSchema } from '@sinclair/typebox'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\nimport { ValidationError } from '../error'\nimport type { Context } from '../context'\n\nimport type { DecoratorBase, RouteSchema } from '../types'\n\nexport const websocket: WebSocketHandler<any> = {\n\topen(ws) {\n\t\tws.data.open?.(ws)\n\t},\n\tmessage(ws, message) {\n\t\tws.data.message?.(ws, message)\n\t},\n\tdrain(ws) {\n\t\tws.data.drain?.(ws)\n\t},\n\tclose(ws, code, reason) {\n\t\tws.data.close?.(ws, code, reason)\n\t}\n}\n\nexport class ElysiaWS<\n\tWS extends ServerWebSocket<{\n\t\tvalidator?: TypeCheck<TSchema>\n\t}>,\n\tRoute extends RouteSchema = RouteSchema,\n\tDecorators extends DecoratorBase = {\n\t\trequest: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t}\n> {\n\tid: number\n\tvalidator?: TypeCheck<TSchema>\n\n\tconstructor(public raw: WS, public data: Context<Route, Decorators>) {\n\t\tthis.validator = raw.data.validator\n\t\tthis.id = Date.now()\n\t}\n\n\tget publish() {\n\t\treturn (\n\t\t\ttopic: string,\n\t\t\tdata: Route['response'] = undefined,\n\t\t\tcompress?: boolean\n\t\t) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.publish(topic, data as unknown as string, compress)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget send() {\n\t\treturn (data: Route['response']) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (Buffer.isBuffer(data)) {\n\t\t\t\tthis.raw.send(data as unknown as Buffer)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.send(data as unknown as string)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget subscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.subscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget unsubscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.unsubscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget cork() {\n\t\treturn (callback: (ws: WS) => this) => {\n\t\t\tthis.raw.cork(callback as any)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget close() {\n\t\treturn () => {\n\t\t\tthis.raw.close()\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget terminate() {\n\t\treturn this.raw.terminate.bind(this.raw)\n\t}\n\n\tget isSubscribed() {\n\t\treturn this.raw.isSubscribed.bind(this.raw)\n\t}\n\n\tget remoteAddress() {\n\t\treturn this.raw.remoteAddress\n\t}\n}\n",
  "import { type Elysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck } from '@sinclair/typebox/compiler'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\n// @ts-ignore\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport { signCookie } from './utils'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nimport { CookieOptions, parseCookie } from './cookie'\n\nimport type {\n\tComposedHandler,\n\tElysiaConfig,\n\tHandler,\n\tLifeCycleStore,\n\tPreHandler,\n\tSchemaValidator,\n\tTraceEvent,\n\tTraceReporter\n} from './types'\n\nconst headersHasToJSON = new Headers().toJSON\nconst findAliases = new RegExp(` (\\\\w+) = context`, 'g')\n\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\tif (hasTrace) {\n\t\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\tlet handled = false\n\n\t\t\treturn () => {\n\t\t\t\tif (handled) return\n\n\t\t\t\thandled = true\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = ''\n\t}: {\n\t\tinjectResponse?: string\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 400; throw new ValidationError(\n'${type}',\n${type},\n${value}\n)`\n\t\t\t: `c.set.status = 400; return new ValidationError(\n\t'${type}',\n\t${type},\n\t${value}\n).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n)`\n\t\t\t: `return new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n).toResponse(c.set.headers)`\n\n\t\treturn `\\n${injectResponse}\n\t\tif(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {\n\tif(!(response instanceof Error))\n\t\t${returnError}\n}\\n`\n\t}\n})\n\nexport const isFnUse = (keyword: string, fnLiteral: string) => {\n\tif (fnLiteral.startsWith('[object ')) return false\n\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\t// Using object destructuring\n\tif (argument.charCodeAt(0) === 123) {\n\t\t// Since Function already format the code, styling is enforced\n\t\tif (argument.includes(keyword)) return true\n\n\t\tif (restIndex === -1) return false\n\t}\n\n\t// Match dot notation and named access\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${argument}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t) {\n\t\treturn true\n\t}\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${restAlias}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t)\n\t\treturn true\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [params] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))\n\t\t\treturn true\n\n\treturn false\n}\n\nconst isContextPassToFunction = (fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\n\tif(fnLiteral.startsWith(\"[object\")) return false\n\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tfor (const alias of aliases)\n\t\tif (new RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${alias}\\\\b[^)]*\\\\)`).test(fnLiteral))\n\t\t\treturn true\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [renamed] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (\n\t\t\tnew RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${renamed}\\\\b[^)]*\\\\)`).test(\n\t\t\t\tfnLiteral\n\t\t\t)\n\t\t)\n\t\t\treturn true\n\n\treturn false\n}\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (expectedProperty: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\nconst getUnionedType = (validator: TypeCheck<any> | undefined) => {\n\tif (!validator) return\n\n\t// @ts-ignore\n\tconst schema = validator?.schema\n\n\tif (schema && 'anyOf' in schema) {\n\t\tlet foundDifference = false\n\t\tconst type: string = schema.anyOf[0].type\n\n\t\tfor (const validator of schema.anyOf as { type: string }[]) {\n\t\t\tif (validator.type !== type) {\n\t\t\t\tfoundDifference = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!foundDifference) return type\n\t}\n\n\t// @ts-ignore\n\treturn validator.schema?.type\n}\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsync = (fn: Function) => {\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nconst getDestructureQuery = (fn: string) => {\n\tif (\n\t\t!fn.includes('query: {') ||\n\t\tfn.includes('query,') ||\n\t\tfn.includes('query }')\n\t)\n\t\treturn false\n\n\tconst start = fn.indexOf('query: {')\n\n\tfn = fn.slice(start + 9)\n\tfn = fn.slice(0, fn.indexOf('}'))\n\n\treturn fn.split(',').map((x) => {\n\t\tconst indexOf = x.indexOf(':')\n\n\t\tif (indexOf === -1) return x.trim()\n\n\t\treturn x.slice(0, indexOf).trim()\n\t})\n}\n\nexport const composeHandler = ({\n\tpath,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\thandleError,\n\tdefinitions,\n\tschema,\n\tonRequest,\n\tconfig,\n\tgetReporter,\n\tsetHeader\n}: {\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\thandleError: Elysia['handleError']\n\tdefinitions?: Elysia['definitions']['type']\n\tschema?: Elysia['schema']\n\tonRequest: PreHandler<any, any>[]\n\tconfig: ElysiaConfig<any>\n\tgetReporter: () => TraceReporter\n\tsetHeader: Object | undefined\n}): ComposedHandler => {\n\tconst hasErrorHandler =\n\t\tconfig.forceErrorEncapsulation ||\n\t\thooks.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst isHandleFn = typeof handler === 'function'\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceLiteral = hooks.trace.map((x) => x.toString())\n\n\tlet hasUnknownContext = false\n\n\tif (isHandleFn && isContextPassToFunction(handler.toString()))\n\t\thasUnknownContext = true\n\n\tif (!hasUnknownContext)\n\t\tfor (const [key, value] of Object.entries(hooks)) {\n\t\t\tif (\n\t\t\t\t!Array.isArray(value) ||\n\t\t\t\t!value.length ||\n\t\t\t\t![\n\t\t\t\t\t'parse',\n\t\t\t\t\t'transform',\n\t\t\t\t\t'beforeHandle',\n\t\t\t\t\t'afterHandle',\n\t\t\t\t\t'onResponse'\n\t\t\t\t].includes(key)\n\t\t\t)\n\t\t\t\tcontinue\n\n\t\t\tfor (const handle of value) {\n\t\t\t\tif (typeof handle !== 'function') continue\n\n\t\t\t\tif (isContextPassToFunction(handle.toString())) {\n\t\t\t\t\thasUnknownContext = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUnknownContext) break\n\t\t}\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = {\n\t\tparse: traceLiteral.some((x) => isFnUse('parse', x)),\n\t\ttransform: traceLiteral.some((x) => isFnUse('transform', x)),\n\t\thandle: traceLiteral.some((x) => isFnUse('handle', x)),\n\t\tbeforeHandle: traceLiteral.some((x) => isFnUse('beforeHandle', x)),\n\t\tafterHandle: traceLiteral.some((x) => isFnUse('afterHandle', x)),\n\t\terror: hasErrorHandler || traceLiteral.some((x) => isFnUse('error', x))\n\t}\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst lifeCycleLiteral =\n\t\tvalidator || (method !== 'GET' && method !== 'HEAD')\n\t\t\t? [\n\t\t\t\t\thandler,\n\t\t\t\t\t...hooks.transform,\n\t\t\t\t\t...hooks.beforeHandle,\n\t\t\t\t\t...hooks.afterHandle,\n\t\t\t\t\t...hooks.mapResponse\n\t\t\t  ].map((x) => (typeof x === 'function' ? x.toString() : `${x}`))\n\t\t\t: []\n\n\tconst hasBody =\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(hasUnknownContext ||\n\t\t\t(hooks.type !== 'none' &&\n\t\t\t\t(!!validator.body ||\n\t\t\t\t\t!!hooks.type ||\n\t\t\t\t\tlifeCycleLiteral.some((fn) => isFnUse('body', fn)))))\n\n\tconst hasHeaders =\n\t\thasUnknownContext ||\n\t\tvalidator.headers ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('headers', fn)) ||\n\t\t(setHeader && Object.keys(setHeader).length)\n\n\tconst hasCookie =\n\t\thasUnknownContext ||\n\t\t!!validator.cookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('cookie', fn))\n\n\t// @ts-ignore\n\tconst cookieMeta = validator?.cookie?.schema as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\t// encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler)\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecret: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tconst hasQuery =\n\t\thasUnknownContext ||\n\t\tvalidator.query ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('query', fn))\n\n\tif (hasQuery) {\n\t\tlet destructured = [] as string[]\n\t\tlet referenceFullQuery = false\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-ignore\n\t\t\tdestructured = Object.keys(validator.query.schema.properties)\n\t\t} else\n\t\t\tfor (const event of lifeCycleLiteral) {\n\t\t\t\tconst queries = getDestructureQuery(event)\n\n\t\t\t\tif (!queries) {\n\t\t\t\t\treferenceFullQuery = true\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const query of queries)\n\t\t\t\t\tif (destructured.indexOf(query) === -1)\n\t\t\t\t\t\tdestructured.push(query)\n\t\t\t}\n\n\t\tif (!referenceFullQuery && destructured.length) {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tconst url = decodeURIComponent(c.request.url.slice(c.qi + 1))\n\t\t\t\tlet memory = 0\n\n\t\t\t\t${destructured\n\t\t\t\t\t.map(\n\t\t\t\t\t\t(name, index) => `\n\t\t\t\t\t\tmemory = url.indexOf('${name}=')\n\n\t\t\t\t\t\tconst a${index} = memory === -1 ? undefined : url.slice(memory = memory + ${\n\t\t\t\t\t\t\tname.length + 1\n\t\t\t\t\t\t}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`\n\t\t\t\t\t)\n\t\t\t\t\t.join('\\n')}\n\n\t\t\t\tc.query = {\n\t\t\t\t\t${destructured.map((name, index) => `${name}: a${index}`).join(', ')}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.query = {}\n\t\t\t}`\n\t\t} else {\n\t\t\tfnLiteral += `c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}`\n\t\t}\n\t}\n\n\tconst traceLiterals = hooks.trace.map((x) => x.toString())\n\tconst hasTraceSet = traceLiterals.some(\n\t\t(fn) => isFnUse('set', fn) || isContextPassToFunction(fn)\n\t)\n\n\thasUnknownContext || hooks.trace.some((fn) => isFnUse('set', fn.toString()))\n\n\tconst hasSet =\n\t\t(setHeader && Object.keys(setHeader).length) ||\n\t\thasTraceSet ||\n\t\thasCookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('set', fn)) ||\n\t\tonRequest.some((fn) => isFnUse('set', fn.toString()))\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? '\\n try {\\n' : ''\n\n\tif (hasTraceSet) {\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.mapResponse.length ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst type = getUnionedType(validator?.body)\n\n\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\tif (hooks.type) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hooks.parse.length) fnLiteral += '}}'\n\t\t} else {\n\t\t\tconst getAotParser = () => {\n\t\t\t\tif (hooks.parse.length && type && !Array.isArray(hooks.type)) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst schema = validator?.body?.schema\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\thasType('File', schema) ||\n\t\t\t\t\t\t\t\thasType('Files', schema)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\treturn `c.body = {}\n\n\t\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t// else {\n\t\t\t\t\t\t\t// \t// Since it's an object an not accepting file\n\t\t\t\t\t\t\t// \t// we can infer that it's JSON\n\t\t\t\t\t\t\t// \tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// fnLiteral += defaultParser\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst aotParse = getAotParser()\n\n\t\t\tif (aotParse) fnLiteral += aotParse\n\t\t\telse {\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t\tfnLiteral += hasHeaders\n\t\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n`\n\n\t\t\t\tif (hooks.parse.length) {\n\t\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\t\tname: hooks.parse[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\t\tendUnit()\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t\t}\n\n\t\t\t\t\tendReport()\n\t\t\t\t}\n\n\t\t\t\tif (hooks.parse.length) fnLiteral += `if (!used)`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tc.body = await c.request.json()\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tc.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\\n`\n\n\t\t\t\tfnLiteral += '}\\n'\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.name\n\t\t\t})\n\n\t\t\t// @ts-ignore\n\t\t\tif (transform.$elysia === 'derive')\n\t\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t\t? `Object.assign(c, await transform[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, transform[${i}](c));`\n\t\t\telse\n\t\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t\t? `await transform[${i}](c);`\n\t\t\t\t\t: `transform[${i}](c);`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.headers.params))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed = typeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.params.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed = typeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.query.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed = typeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t\tfnLiteral += `c.query['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.body.schema))\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n    \t\t\t\tc.body = Object.assign(${JSON.stringify(\n\t\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t) ?? {}\n\t\t\t\t\t)}, c.body)\n\n    \t\t\t\tif(body.Check(c.query) === false) {\n        \t\t\t\t${composeValidation('body')}\n     \t\t\t}\n            }`\n\t\t\telse\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n\t\t\t${composeValidation('body')}\n\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(validator.cookie?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n    \t\t\tfor(const [key, value] of Object.entries(c.cookie))\n    \t\t\t\tcookieValue[key] = value.value\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.cookie.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.cookie.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.cookie.schema))\n\t\t\t\tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: beforeHandle.name\n\t\t\t})\n\n\t\t\tconst returning = hasReturn(beforeHandle.toString())\n\n\t\t\t// @ts-ignore\n\t\t\tif (beforeHandle.$elysia === 'resolve') {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `Object.assign(c, await beforeHandle[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, beforeHandle[${i}](c));`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `be = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(be !== undefined) {\\n`\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn ? handler.name : undefined\n\t\t\t\t\t})()\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst returning = hasReturn(\n\t\t\t\t\t\t\thooks.afterHandle[i].toString()\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af !== undefined) { c.response = be = af }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += `c.response = be`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\t\t\t\tif(mr !== undefined) c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(be, c.set)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? handler.name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = c.response = await ${handle};\\n`\n\t\t\t\t: `let r = c.response = ${handle};\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst returning = hasReturn(hooks.afterHandle[i].toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response = af }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `c.response = af}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hooks.mapResponse.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tfnLiteral += `\\nmr = onMapResponse[${i}](c)\n\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\tif(mr !== undefined) c.response = mr\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? handler.name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) { \n\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response)\n\t\t\t\tfnLiteral += `return ${handle}.clone()\\n`\n\t\t\telse if (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t} else {\n\t\t\tif (traceConditions.handle || hasCookie) {\n\t\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\t\tendHandle()\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\n\t\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t\t} else {\n\t\t\t\tendHandle()\n\n\t\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tif (handler instanceof Response)\n\t\t\t\t\tfnLiteral += `return ${handle}.clone()\\n`\n\t\t\t\telse if (hasSet)\n\t\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(${handled})\\n`\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\n} catch(error) {`\n\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\n\n\t\tif (!set.status || set.status < 300) set.status = error?.status || 500\n\t`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\t// console.log(fnLiteral)\n\n\tfnLiteral = `const {\n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tresolve,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tmapResponse: onMapResponse,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function handle(c) {\n\t\t${hooks.beforeHandle.length ? 'let be' : ''}\n\t\t${hooks.afterHandle.length ? 'let af' : ''}\n\t\t${hooks.mapResponse.length ? 'let mr' : ''}\n\n\t\t${schema && definitions ? 'c.schema = schema; c.defs = definitions;' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks,\n\t\tvalidator,\n\t\thandleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent\n\t})\n}\n\nexport const composeGeneralHandler = (\n\tapp: Elysia<any, any, any, any, any, any>\n) => {\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.decorators))\n\t\tdecoratorsLiteral += `,${key}: app.decorators.${key}`\n\n\t// @ts-ignore\n\tconst { router, staticRouter } = app\n\n\tconst hasTrace = app.event.trace.length > 0\n\n\tconst findDynamicRoute = `\n\tconst route = router.find(request.method, path) ${\n\t\trouter.root.ALL ? '?? router.find(\"ALL\", path)' : ''\n\t}\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: app.event.request.length\n\t\t\t\t? `new Response(error404Message, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t\t\t: `error404.clone()`\n\t\t}\n\n\tctx.params = route.params\n\n\treturn route.store(ctx)`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(staticRouter.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tapp: { store, router, staticRouter, wsRouter },\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter,\n\t\thandleError\n\t} = data\n\n\tconst notFound = new NotFoundError()\n\n\t${app.event.request.length ? `const onRequest = app.event.request` : ''}\n\t${staticRouter.variables}\n\t${\n\t\tapp.event.error.length\n\t\t\t? ''\n\t\t\t: `\n\tconst error404Message = notFound.message.toString()\n\tconst error404 = new Response(error404Message, { status: 404 });\n\t`\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\\n`\n\n\tif(app.event.request.length)\n\t\tfnLiteral += `let re`\n\n\n\tconst traceLiteral = app.event.trace.map((x) => x.toString())\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: app.event.trace.some((fn) => {\n\t\t\tconst literal = fn.toString()\n\n\t\t\treturn isFnUse('set', literal) || isContextPassToFunction(literal)\n\t\t}),\n\t\tcondition: {\n\t\t\trequest: traceLiteral.some(\n\t\t\t\t(x) => isFnUse('request', x) || isContextPassToFunction(x)\n\t\t\t)\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tset: {\n\t\t\t\t\theaders: ${\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tObject.keys(app.setHeaders ?? {}).length\n\t\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t\t: '{}'\n\t\t\t\t\t},\n\t\t\t\t\tstatus: 200\n\t\t\t\t}\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `\\n try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst fn = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(fn.toString())\n\t\t\tconst maybeAsync = isAsync(fn)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].name\n\t\t\t})\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `re = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif(withReturn)\n\t\t\t\t\tfnLiteral += `if(re !== undefined) return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += `\n\t\tconst url = request.url\n\t\tconst s = url.indexOf('/', 11)\n\t\tconst qi = ctx.qi = url.indexOf('?', s + 1)\n\t\tconst path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`\n\t} else {\n\t\tfnLiteral += `\n\t\tconst url = request.url\n\t\tconst s = url.indexOf('/', 11)\n\t\tconst qi = url.indexOf('?', s + 1)\n\t\tconst path = url.substring(s, qi === -1 ? undefined : qi)\n\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tset: {\n\t\t\t\theaders: ${\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tObject.keys(app.setHeaders ?? {}).length\n\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t: '{}'\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t\t}\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\ttraceLiteral.some((x) => isFnUse('context', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('store', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('set', x))\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\t// @ts-ignore\n\tconst wsPaths = app.wsPaths\n\t// @ts-ignore\n\tconst wsRouter = app.wsRouter\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = wsRouter.find('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-ignore\n\tapp.handleError = handleError\n\n\t// console.log(fnLiteral)\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\thandleError\n\t})\n}\n\nexport const composeErrorHandler = (\n\tapp: Elysia<any, any, any, any, any, any>\n) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onError, onResponse: res } },\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t} = inject\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error) {\n\t\tlet r\n\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\n\t\tif(error[ELYSIA_RESPONSE]) {\n\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\terror.message = error.response\n\t\t}\n`\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${\n\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t}onError[${i}](context)`\n\n\t\tif (hasReturn(handler.toString()))\n\t\t\tfnLiteral += `r = ${response}; if(r !== undefined) {\n\t\t\t\tif(r instanceof Response) return r\n\n\t\t\t\tif(r[ELYSIA_RESPONSE]) {\n\t\t\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\t\t\terror.message = error.response\n\t\t\t\t}\n\t\t\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r, set)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 400\n\t\treturn new Response(\n\t\t\terror.message,\n\t\t\t{ headers: set.headers, status: set.status }\n\t\t)\n\t} else {\n\t\tif(error.code && typeof error.status === \"number\")\n\t\t\treturn new Response(\n\t\t\t\terror.message,\n\t\t\t\t{ headers: set.headers, status: error.status }\n\t\t\t)\n\n\t\treturn mapResponse(error, set)\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t})\n}\n",
  "import { type Elysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck } from '@sinclair/typebox/compiler'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\n// @ts-ignore\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport { signCookie } from './utils'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nimport { CookieOptions, parseCookie } from './cookie'\n\nimport type {\n\tComposedHandler,\n\tElysiaConfig,\n\tHandler,\n\tLifeCycleStore,\n\tPreHandler,\n\tSchemaValidator,\n\tTraceEvent,\n\tTraceReporter\n} from './types'\n\nconst headersHasToJSON = new Headers().toJSON\nconst findAliases = new RegExp(` (\\\\w+) = context`, 'g')\n\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\tif (hasTrace) {\n\t\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\tlet handled = false\n\n\t\t\treturn () => {\n\t\t\t\tif (handled) return\n\n\t\t\t\thandled = true\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = ''\n\t}: {\n\t\tinjectResponse?: string\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 400; throw new ValidationError(\n'${type}',\n${type},\n${value}\n)`\n\t\t\t: `c.set.status = 400; return new ValidationError(\n\t'${type}',\n\t${type},\n\t${value}\n).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n)`\n\t\t\t: `return new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n).toResponse(c.set.headers)`\n\n\t\treturn `\\n${injectResponse}\n\t\tif(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {\n\tif(!(response instanceof Error))\n\t\t${returnError}\n}\\n`\n\t}\n})\n\nexport const isFnUse = (keyword: string, fnLiteral: string) => {\n\tif (fnLiteral.startsWith('[object ')) return false\n\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\t// Using object destructuring\n\tif (argument.charCodeAt(0) === 123) {\n\t\t// Since Function already format the code, styling is enforced\n\t\tif (argument.includes(keyword)) return true\n\n\t\tif (restIndex === -1) return false\n\t}\n\n\t// Match dot notation and named access\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${argument}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t) {\n\t\treturn true\n\t}\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${restAlias}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t)\n\t\treturn true\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [params] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))\n\t\t\treturn true\n\n\treturn false\n}\n\nconst isContextPassToFunction = (fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\n\tif(fnLiteral.startsWith(\"[object\")) return false\n\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tfor (const alias of aliases)\n\t\tif (new RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${alias}\\\\b[^)]*\\\\)`).test(fnLiteral))\n\t\t\treturn true\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [renamed] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (\n\t\t\tnew RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${renamed}\\\\b[^)]*\\\\)`).test(\n\t\t\t\tfnLiteral\n\t\t\t)\n\t\t)\n\t\t\treturn true\n\n\treturn false\n}\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (expectedProperty: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\nconst getUnionedType = (validator: TypeCheck<any> | undefined) => {\n\tif (!validator) return\n\n\t// @ts-ignore\n\tconst schema = validator?.schema\n\n\tif (schema && 'anyOf' in schema) {\n\t\tlet foundDifference = false\n\t\tconst type: string = schema.anyOf[0].type\n\n\t\tfor (const validator of schema.anyOf as { type: string }[]) {\n\t\t\tif (validator.type !== type) {\n\t\t\t\tfoundDifference = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!foundDifference) return type\n\t}\n\n\t// @ts-ignore\n\treturn validator.schema?.type\n}\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsync = (fn: Function) => {\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nconst getDestructureQuery = (fn: string) => {\n\tif (\n\t\t!fn.includes('query: {') ||\n\t\tfn.includes('query,') ||\n\t\tfn.includes('query }')\n\t)\n\t\treturn false\n\n\tconst start = fn.indexOf('query: {')\n\n\tfn = fn.slice(start + 9)\n\tfn = fn.slice(0, fn.indexOf('}'))\n\n\treturn fn.split(',').map((x) => {\n\t\tconst indexOf = x.indexOf(':')\n\n\t\tif (indexOf === -1) return x.trim()\n\n\t\treturn x.slice(0, indexOf).trim()\n\t})\n}\n\nexport const composeHandler = ({\n\tpath,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\thandleError,\n\tdefinitions,\n\tschema,\n\tonRequest,\n\tconfig,\n\tgetReporter,\n\tsetHeader\n}: {\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\thandleError: Elysia['handleError']\n\tdefinitions?: Elysia['definitions']['type']\n\tschema?: Elysia['schema']\n\tonRequest: PreHandler<any, any>[]\n\tconfig: ElysiaConfig<any>\n\tgetReporter: () => TraceReporter\n\tsetHeader: Object | undefined\n}): ComposedHandler => {\n\tconst hasErrorHandler =\n\t\tconfig.forceErrorEncapsulation ||\n\t\thooks.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst isHandleFn = typeof handler === 'function'\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceLiteral = hooks.trace.map((x) => x.toString())\n\n\tlet hasUnknownContext = false\n\n\tif (isHandleFn && isContextPassToFunction(handler.toString()))\n\t\thasUnknownContext = true\n\n\tif (!hasUnknownContext)\n\t\tfor (const [key, value] of Object.entries(hooks)) {\n\t\t\tif (\n\t\t\t\t!Array.isArray(value) ||\n\t\t\t\t!value.length ||\n\t\t\t\t![\n\t\t\t\t\t'parse',\n\t\t\t\t\t'transform',\n\t\t\t\t\t'beforeHandle',\n\t\t\t\t\t'afterHandle',\n\t\t\t\t\t'onResponse'\n\t\t\t\t].includes(key)\n\t\t\t)\n\t\t\t\tcontinue\n\n\t\t\tfor (const handle of value) {\n\t\t\t\tif (typeof handle !== 'function') continue\n\n\t\t\t\tif (isContextPassToFunction(handle.toString())) {\n\t\t\t\t\thasUnknownContext = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUnknownContext) break\n\t\t}\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = {\n\t\tparse: traceLiteral.some((x) => isFnUse('parse', x)),\n\t\ttransform: traceLiteral.some((x) => isFnUse('transform', x)),\n\t\thandle: traceLiteral.some((x) => isFnUse('handle', x)),\n\t\tbeforeHandle: traceLiteral.some((x) => isFnUse('beforeHandle', x)),\n\t\tafterHandle: traceLiteral.some((x) => isFnUse('afterHandle', x)),\n\t\terror: hasErrorHandler || traceLiteral.some((x) => isFnUse('error', x))\n\t}\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst lifeCycleLiteral =\n\t\tvalidator || (method !== 'GET' && method !== 'HEAD')\n\t\t\t? [\n\t\t\t\t\thandler,\n\t\t\t\t\t...hooks.transform,\n\t\t\t\t\t...hooks.beforeHandle,\n\t\t\t\t\t...hooks.afterHandle,\n\t\t\t\t\t...hooks.mapResponse\n\t\t\t  ].map((x) => (typeof x === 'function' ? x.toString() : `${x}`))\n\t\t\t: []\n\n\tconst hasBody =\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(hasUnknownContext ||\n\t\t\t(hooks.type !== 'none' &&\n\t\t\t\t(!!validator.body ||\n\t\t\t\t\t!!hooks.type ||\n\t\t\t\t\tlifeCycleLiteral.some((fn) => isFnUse('body', fn)))))\n\n\tconst hasHeaders =\n\t\thasUnknownContext ||\n\t\tvalidator.headers ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('headers', fn)) ||\n\t\t(setHeader && Object.keys(setHeader).length)\n\n\tconst hasCookie =\n\t\thasUnknownContext ||\n\t\t!!validator.cookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('cookie', fn))\n\n\t// @ts-ignore\n\tconst cookieMeta = validator?.cookie?.schema as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\t// encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler)\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecret: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tconst hasQuery =\n\t\thasUnknownContext ||\n\t\tvalidator.query ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('query', fn))\n\n\tif (hasQuery) {\n\t\tlet destructured = [] as string[]\n\t\tlet referenceFullQuery = false\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-ignore\n\t\t\tdestructured = Object.keys(validator.query.schema.properties)\n\t\t} else\n\t\t\tfor (const event of lifeCycleLiteral) {\n\t\t\t\tconst queries = getDestructureQuery(event)\n\n\t\t\t\tif (!queries) {\n\t\t\t\t\treferenceFullQuery = true\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const query of queries)\n\t\t\t\t\tif (destructured.indexOf(query) === -1)\n\t\t\t\t\t\tdestructured.push(query)\n\t\t\t}\n\n\t\tif (!referenceFullQuery && destructured.length) {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tconst url = decodeURIComponent(c.request.url.slice(c.qi + 1))\n\t\t\t\tlet memory = 0\n\n\t\t\t\t${destructured\n\t\t\t\t\t.map(\n\t\t\t\t\t\t(name, index) => `\n\t\t\t\t\t\tmemory = url.indexOf('${name}=')\n\n\t\t\t\t\t\tconst a${index} = memory === -1 ? undefined : url.slice(memory = memory + ${\n\t\t\t\t\t\t\tname.length + 1\n\t\t\t\t\t\t}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`\n\t\t\t\t\t)\n\t\t\t\t\t.join('\\n')}\n\n\t\t\t\tc.query = {\n\t\t\t\t\t${destructured.map((name, index) => `${name}: a${index}`).join(', ')}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.query = {}\n\t\t\t}`\n\t\t} else {\n\t\t\tfnLiteral += `c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}`\n\t\t}\n\t}\n\n\tconst traceLiterals = hooks.trace.map((x) => x.toString())\n\tconst hasTraceSet = traceLiterals.some(\n\t\t(fn) => isFnUse('set', fn) || isContextPassToFunction(fn)\n\t)\n\n\thasUnknownContext || hooks.trace.some((fn) => isFnUse('set', fn.toString()))\n\n\tconst hasSet =\n\t\t(setHeader && Object.keys(setHeader).length) ||\n\t\thasTraceSet ||\n\t\thasCookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('set', fn)) ||\n\t\tonRequest.some((fn) => isFnUse('set', fn.toString()))\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? '\\n try {\\n' : ''\n\n\tif (hasTraceSet) {\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.mapResponse.length ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst type = getUnionedType(validator?.body)\n\n\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\tif (hooks.type) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hooks.parse.length) fnLiteral += '}}'\n\t\t} else {\n\t\t\tconst getAotParser = () => {\n\t\t\t\tif (hooks.parse.length && type && !Array.isArray(hooks.type)) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst schema = validator?.body?.schema\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\thasType('File', schema) ||\n\t\t\t\t\t\t\t\thasType('Files', schema)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\treturn `c.body = {}\n\n\t\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t// else {\n\t\t\t\t\t\t\t// \t// Since it's an object an not accepting file\n\t\t\t\t\t\t\t// \t// we can infer that it's JSON\n\t\t\t\t\t\t\t// \tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// fnLiteral += defaultParser\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst aotParse = getAotParser()\n\n\t\t\tif (aotParse) fnLiteral += aotParse\n\t\t\telse {\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t\tfnLiteral += hasHeaders\n\t\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n`\n\n\t\t\t\tif (hooks.parse.length) {\n\t\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\t\tname: hooks.parse[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\t\tendUnit()\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t\t}\n\n\t\t\t\t\tendReport()\n\t\t\t\t}\n\n\t\t\t\tif (hooks.parse.length) fnLiteral += `if (!used)`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tc.body = await c.request.json()\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tc.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\\n`\n\n\t\t\t\tfnLiteral += '}\\n'\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.name\n\t\t\t})\n\n\t\t\t// @ts-ignore\n\t\t\tif (transform.$elysia === 'derive')\n\t\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t\t? `Object.assign(c, await transform[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, transform[${i}](c));`\n\t\t\telse\n\t\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t\t? `await transform[${i}](c);`\n\t\t\t\t\t: `transform[${i}](c);`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.headers.params))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed = typeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.params.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed = typeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.query.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed = typeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t\tfnLiteral += `c.query['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.body.schema))\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n    \t\t\t\tc.body = Object.assign(${JSON.stringify(\n\t\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t) ?? {}\n\t\t\t\t\t)}, c.body)\n\n    \t\t\t\tif(body.Check(c.query) === false) {\n        \t\t\t\t${composeValidation('body')}\n     \t\t\t}\n            }`\n\t\t\telse\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n\t\t\t${composeValidation('body')}\n\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(validator.cookie?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n    \t\t\tfor(const [key, value] of Object.entries(c.cookie))\n    \t\t\t\tcookieValue[key] = value.value\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.cookie.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.cookie.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.cookie.schema))\n\t\t\t\tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: beforeHandle.name\n\t\t\t})\n\n\t\t\tconst returning = hasReturn(beforeHandle.toString())\n\n\t\t\t// @ts-ignore\n\t\t\tif (beforeHandle.$elysia === 'resolve') {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `Object.assign(c, await beforeHandle[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, beforeHandle[${i}](c));`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `be = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(be !== undefined) {\\n`\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn ? handler.name : undefined\n\t\t\t\t\t})()\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst returning = hasReturn(\n\t\t\t\t\t\t\thooks.afterHandle[i].toString()\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af !== undefined) { c.response = be = af }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += `c.response = be`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\t\t\t\tif(mr !== undefined) c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(be, c.set)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? handler.name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = c.response = await ${handle};\\n`\n\t\t\t\t: `let r = c.response = ${handle};\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst returning = hasReturn(hooks.afterHandle[i].toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response = af }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `c.response = af}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hooks.mapResponse.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tfnLiteral += `\\nmr = onMapResponse[${i}](c)\n\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\tif(mr !== undefined) c.response = mr\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? handler.name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) { \n\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response)\n\t\t\t\tfnLiteral += `return ${handle}.clone()\\n`\n\t\t\telse if (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t} else {\n\t\t\tif (traceConditions.handle || hasCookie) {\n\t\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\t\tendHandle()\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\n\t\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t\t} else {\n\t\t\t\tendHandle()\n\n\t\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tif (handler instanceof Response)\n\t\t\t\t\tfnLiteral += `return ${handle}.clone()\\n`\n\t\t\t\telse if (hasSet)\n\t\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(${handled})\\n`\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\n} catch(error) {`\n\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\n\n\t\tif (!set.status || set.status < 300) set.status = error?.status || 500\n\t`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\t// console.log(fnLiteral)\n\n\tfnLiteral = `const {\n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tresolve,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tmapResponse: onMapResponse,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function handle(c) {\n\t\t${hooks.beforeHandle.length ? 'let be' : ''}\n\t\t${hooks.afterHandle.length ? 'let af' : ''}\n\t\t${hooks.mapResponse.length ? 'let mr' : ''}\n\n\t\t${schema && definitions ? 'c.schema = schema; c.defs = definitions;' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks,\n\t\tvalidator,\n\t\thandleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent\n\t})\n}\n\nexport const composeGeneralHandler = (\n\tapp: Elysia<any, any, any, any, any, any>\n) => {\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.decorators))\n\t\tdecoratorsLiteral += `,${key}: app.decorators.${key}`\n\n\t// @ts-ignore\n\tconst { router, staticRouter } = app\n\n\tconst hasTrace = app.event.trace.length > 0\n\n\tconst findDynamicRoute = `\n\tconst route = router.find(request.method, path) ${\n\t\trouter.root.ALL ? '?? router.find(\"ALL\", path)' : ''\n\t}\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: app.event.request.length\n\t\t\t\t? `new Response(error404Message, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t\t\t: `error404.clone()`\n\t\t}\n\n\tctx.params = route.params\n\n\treturn route.store(ctx)`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(staticRouter.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tapp: { store, router, staticRouter, wsRouter },\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter,\n\t\thandleError\n\t} = data\n\n\tconst notFound = new NotFoundError()\n\n\t${app.event.request.length ? `const onRequest = app.event.request` : ''}\n\t${staticRouter.variables}\n\t${\n\t\tapp.event.error.length\n\t\t\t? ''\n\t\t\t: `\n\tconst error404Message = notFound.message.toString()\n\tconst error404 = new Response(error404Message, { status: 404 });\n\t`\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\\n`\n\n\tif(app.event.request.length)\n\t\tfnLiteral += `let re`\n\n\n\tconst traceLiteral = app.event.trace.map((x) => x.toString())\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: app.event.trace.some((fn) => {\n\t\t\tconst literal = fn.toString()\n\n\t\t\treturn isFnUse('set', literal) || isContextPassToFunction(literal)\n\t\t}),\n\t\tcondition: {\n\t\t\trequest: traceLiteral.some(\n\t\t\t\t(x) => isFnUse('request', x) || isContextPassToFunction(x)\n\t\t\t)\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tset: {\n\t\t\t\t\theaders: ${\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tObject.keys(app.setHeaders ?? {}).length\n\t\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t\t: '{}'\n\t\t\t\t\t},\n\t\t\t\t\tstatus: 200\n\t\t\t\t}\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `\\n try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst fn = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(fn.toString())\n\t\t\tconst maybeAsync = isAsync(fn)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].name\n\t\t\t})\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `re = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif(withReturn)\n\t\t\t\t\tfnLiteral += `if(re !== undefined) return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += `\n\t\tconst url = request.url\n\t\tconst s = url.indexOf('/', 11)\n\t\tconst qi = ctx.qi = url.indexOf('?', s + 1)\n\t\tconst path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`\n\t} else {\n\t\tfnLiteral += `\n\t\tconst url = request.url\n\t\tconst s = url.indexOf('/', 11)\n\t\tconst qi = url.indexOf('?', s + 1)\n\t\tconst path = url.substring(s, qi === -1 ? undefined : qi)\n\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tset: {\n\t\t\t\theaders: ${\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tObject.keys(app.setHeaders ?? {}).length\n\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t: '{}'\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t\t}\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\ttraceLiteral.some((x) => isFnUse('context', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('store', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('set', x))\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\t// @ts-ignore\n\tconst wsPaths = app.wsPaths\n\t// @ts-ignore\n\tconst wsRouter = app.wsRouter\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = wsRouter.find('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-ignore\n\tapp.handleError = handleError\n\n\t// console.log(fnLiteral)\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\thandleError\n\t})\n}\n\nexport const composeErrorHandler = (\n\tapp: Elysia<any, any, any, any, any, any>\n) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onError, onResponse: res } },\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t} = inject\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error) {\n\t\tlet r\n\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\n\t\tif(error[ELYSIA_RESPONSE]) {\n\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\terror.message = error.response\n\t\t}\n`\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${\n\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t}onError[${i}](context)`\n\n\t\tif (hasReturn(handler.toString()))\n\t\t\tfnLiteral += `r = ${response}; if(r !== undefined) {\n\t\t\t\tif(r instanceof Response) return r\n\n\t\t\t\tif(r[ELYSIA_RESPONSE]) {\n\t\t\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\t\t\terror.message = error.response\n\t\t\t\t}\n\t\t\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r, set)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 400\n\t\treturn new Response(\n\t\t\terror.message,\n\t\t\t{ headers: set.headers, status: set.status }\n\t\t)\n\t} else {\n\t\tif(error.code && typeof error.status === \"number\")\n\t\t\treturn new Response(\n\t\t\t\terror.message,\n\t\t\t\t{ headers: set.headers, status: error.status }\n\t\t\t)\n\n\t\treturn mapResponse(error, set)\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t})\n}\n",
  "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport { ElysiaErrors, NotFoundError, ValidationError } from './error'\n\nimport type { Context } from './context'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\nimport { parseCookie } from './cookie'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tlet context: Context\n\n\t\t// @ts-ignore\n\t\tif (app.decorators) {\n\t\t\t// @ts-ignore\n\t\t\tcontext = app.decorators as any as Context\n\n\t\t\tcontext.request = request\n\t\t\tcontext.set = set\n\t\t\tcontext.store = app.store\n\t\t} else {\n\t\t\tcontext = {\n\t\t\t\tset,\n\t\t\t\tstore: app.store,\n\t\t\t\trequest\n\t\t\t} as any as Context\n\t\t}\n\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tq = url.indexOf('?', s + 1),\n\t\t\tpath = q === -1 ? url.substring(s) : url.substring(s, q)\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst onRequest = app.event.request[i]\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find(request.method, path) ??\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\tfor (let i = 0; i < app.event.parse.length; i++) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tlet temp = app.event.parse[i](context, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-ignore\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = q === -1 ? {} : parseQuery(url.substring(q + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\t// @ts-ignore\n\t\t\tconst cookieMeta = validator?.cookie?.schema as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tcontext.cookie = await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcontext.headers.cookie,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecret:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined\n\t\t\t)\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst operation = hooks.transform[i](context)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (hooks.transform[i].$elysia === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.cookie) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie?.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i](context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in cookieMeta.properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-ignore\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\t// @ts-ignore\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any>) =>\n\tasync (context: Context, error: ElysiaErrors) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\t// @ts-ignore\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tlet response = app.event.error[i](errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, context.set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport { ElysiaErrors, NotFoundError, ValidationError } from './error'\n\nimport type { Context } from './context'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\nimport { parseCookie } from './cookie'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tlet context: Context\n\n\t\t// @ts-ignore\n\t\tif (app.decorators) {\n\t\t\t// @ts-ignore\n\t\t\tcontext = app.decorators as any as Context\n\n\t\t\tcontext.request = request\n\t\t\tcontext.set = set\n\t\t\tcontext.store = app.store\n\t\t} else {\n\t\t\tcontext = {\n\t\t\t\tset,\n\t\t\t\tstore: app.store,\n\t\t\t\trequest\n\t\t\t} as any as Context\n\t\t}\n\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tq = url.indexOf('?', s + 1),\n\t\t\tpath = q === -1 ? url.substring(s) : url.substring(s, q)\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst onRequest = app.event.request[i]\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find(request.method, path) ??\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\tfor (let i = 0; i < app.event.parse.length; i++) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tlet temp = app.event.parse[i](context, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-ignore\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = q === -1 ? {} : parseQuery(url.substring(q + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\t// @ts-ignore\n\t\t\tconst cookieMeta = validator?.cookie?.schema as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tcontext.cookie = await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcontext.headers.cookie,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecret:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined\n\t\t\t)\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst operation = hooks.transform[i](context)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (hooks.transform[i].$elysia === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.cookie) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie?.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i](context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in cookieMeta.properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-ignore\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\t// @ts-ignore\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any>) =>\n\tasync (context: Context, error: ElysiaErrors) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\t// @ts-ignore\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tlet response = app.event.error[i](errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, context.set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import { NumberOptions } from '@sinclair/typebox'\nimport { TypeSystem } from '@sinclair/typebox/system'\nimport {\n\tType,\n\ttype SchemaOptions,\n\ttype TNull,\n\ttype TUnion,\n\ttype TSchema,\n\ttype TUndefined,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tFormatRegistry\n} from '@sinclair/typebox'\nimport { type TypeCheck } from '@sinclair/typebox/compiler'\nimport { CookieOptions } from './cookie'\nimport { Value } from '@sinclair/typebox/value'\nimport { ValidationError } from './error'\n\nconst t = Object.assign({}, Type)\n\ntry {\n\tTypeSystem.Format('email', (value) =>\n\t\t/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format('uuid', (value) =>\n\t\t/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format(\n\t\t'date',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n\n\tTypeSystem.Format(\n\t\t'date-time',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n} catch (error) {\n\t// Not empty\n}\n\ntype MaybeArray<T> = T | T[]\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumberOptions\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<\n\t\t\t| (string & {})\n\t\t\t| 'image'\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/gif'\n\t\t\t| 'image/tiff'\n\t\t\t| 'image/x-icon'\n\t\t\t| 'image/svg'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'audio'\n\t\t\t| 'audio/mpeg'\n\t\t\t| 'audio/x-ms-wma'\n\t\t\t| 'audio/vnd.rn-realaudio'\n\t\t\t| 'audio/x-wav'\n\t\t\t| 'video'\n\t\t\t| 'video/mpeg'\n\t\t\t| 'video/mp4'\n\t\t\t| 'video/quicktime'\n\t\t\t| 'video/x-ms-wmv'\n\t\t\t| 'video/x-msvideo'\n\t\t\t| 'video/x-flv'\n\t\t\t| 'video/webm'\n\t\t\t| 'text'\n\t\t\t| 'text/css'\n\t\t\t| 'text/csv'\n\t\t\t| 'text/html'\n\t\t\t| 'text/javascript'\n\t\t\t| 'text/plain'\n\t\t\t| 'text/xml'\n\t\t\t| 'application'\n\t\t\t| 'application/ogg'\n\t\t\t| 'application/pdf'\n\t\t\t| 'application/xhtml'\n\t\t\t| 'application/html'\n\t\t\t| 'application/json'\n\t\t\t| 'application/ld+json'\n\t\t\t| 'application/xml'\n\t\t\t| 'application/zip'\n\t\t\t| 'font'\n\t\t\t| 'font/woff2'\n\t\t\t| 'font/woff'\n\t\t\t| 'font/ttf'\n\t\t\t| 'font/otf'\n\t\t>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\nconst Files = TypeSystem.Type<File[], ElysiaTypeOptions.Files>(\n\t'Files',\n\t(options, value) => {\n\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\tif (options.minItems && value.length < options.minItems) return false\n\n\t\tif (options.maxItems && value.length > options.maxItems) return false\n\n\t\tfor (let i = 0; i < value.length; i++)\n\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\treturn true\n\t}\n)\n\nFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\nFormatRegistry.Set('ObjectString', (value) => {\n\tlet start = value.charCodeAt(0)\n\n\t// If starts with ' ', '\\t', '\\n', then trim first\n\tif (start === 9 || start === 10 || start === 32)\n\t\tstart = value.trimStart().charCodeAt(0)\n\n\tif (start !== 123 && start !== 91) return false\n\n\ttry {\n\t\tJSON.parse(value)\n\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n})\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) =>\n\t\tt\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: ''\n\t\t\t\t\t}),\n\t\t\t\t\tt.Object(properties, options)\n\t\t\t\t], options)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => JSON.stringify(value)) as any as TObject<T>,\n\tFile: TypeSystem.Type<File, ElysiaTypeOptions.File>('File', validateFile),\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tt\n\t\t\t.Transform(t.Union([Files(options)]))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T): TUnion<[T, TNull]> =>\n\t\tt.Union([t.Null(), schema]) as any,\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T): TUnion<[T, TUndefined]> =>\n\t\tt.Union([t.Null(), t.Undefined(), schema]) as any,\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions &\n\t\t\tCookieOptions & {\n\t\t\t\t/**\n\t\t\t\t * Secret key for signing cookie\n\t\t\t\t *\n\t\t\t\t * If array is passed, will use Key Rotation.\n\t\t\t\t *\n\t\t\t\t * Key rotation is when an encryption key is retired\n\t\t\t\t * and replaced by generating a new cryptographic key.\n\t\t\t\t */\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\t/**\n\t\t\t\t * Specified cookie name to be signed globally\n\t\t\t\t */\n\t\t\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t\t\t}\n\t): TObject<T> => t.Object(properties, options)\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface JavaScriptTypeBuilder {\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\t// @ts-ignore\n\t\tFile: typeof ElysiaType.File\n\t\t// @ts-ignore\n\t\tFiles: typeof ElysiaType.Files\n\t\tNullable: typeof ElysiaType.Nullable\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| ((\n\t\t\t\t\ttype: string,\n\t\t\t\t\tvalidator: TypeCheck<any>,\n\t\t\t\t\tvalue: unknown\n\t\t\t  ) => string | void)\n\t}\n}\n\nt.ObjectString = ElysiaType.ObjectString\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nt.Numeric = ElysiaType.Numeric\n\nt.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nt.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty\n\nt.Cookie = ElysiaType.Cookie\n\nexport { t }\n\nexport * from '@sinclair/typebox/system'\nexport * from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(t.String())\n\n// console.log(v.Decode.toString())\n\n// const T = t.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
  "import type { Serve, Server, ServerWebSocket } from 'bun'\n\nimport { Memoirist } from 'memoirist'\nimport EventEmitter from 'eventemitter3'\nimport type { Static, TSchema } from '@sinclair/typebox'\n\nimport { createTraceListener } from './trace'\nimport type { Context } from './context'\n\nimport { ElysiaWS, websocket } from './ws'\nimport type { WS } from './ws/types'\n\nimport { isNotEmpty, mapEarlyResponse } from './handler'\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler\n} from './compose'\nimport {\n\tmergeHook,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tmergeDeep,\n\tmergeCookie,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasGlobal,\n\ttraceBackMacro,\n\treplaceUrlPath,\n\tprimitiveHooks,\n\tisNumericString\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tisProduction,\n\tERROR_CODE,\n\tELYSIA_RESPONSE,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError,\n} from './error'\n\nimport type {\n\tElysiaConfig,\n\tDecoratorBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tListenCallback,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tTraceReporter,\n\tTraceHandler,\n\tMaybeArray,\n\tGracefulHandler,\n\tGetPathParameter,\n\tMapResponse,\n\tChecksum,\n\tMacroManager,\n\tBaseMacro,\n\tMacroToProperty,\n\tTransformHandler\n} from './types'\nimport { t } from './type-system'\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(8080)\n * ```\n */\nexport default class Elysia<\n\tBasePath extends string = '',\n\tDecorators extends DecoratorBase = {\n\t\trequest: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t},\n\tDefinitions extends DefinitionBase = {\n\t\ttype: {}\n\t\terror: {}\n\t},\n\tParentSchema extends RouteSchema = {},\n\tMacro extends Record<string, unknown> = {},\n\tRoutes extends RouteBase = {},\n\tScoped extends boolean = false\n> {\n\tconfig: ElysiaConfig<BasePath>\n\tprivate dependencies: Record<string, Checksum[]> = {}\n\n\tstore: Decorators['store'] = {}\n\tprivate decorators = {} as Decorators['request']\n\tprivate definitions = {\n\t\ttype: {},\n\t\terror: {}\n\t} as {\n\t\ttype: Definitions['type']\n\t\terror: Definitions['error']\n\t}\n\n\tschema = {} as Routes\n\n\tprivate macros: ((manager: MacroManager<any, any, any>) => Macro)[] =\n\t\t[] as any\n\n\tevent: LifeCycleStore = {\n\t\tstart: [],\n\t\trequest: [],\n\t\tparse: [],\n\t\ttransform: [],\n\t\tbeforeHandle: [],\n\t\tafterHandle: [],\n\t\tmapResponse: [],\n\t\tonResponse: [],\n\t\ttrace: [],\n\t\terror: [],\n\t\tstop: []\n\t}\n\n\treporter: TraceReporter = new EventEmitter()\n\n\tserver: Server | null = null\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\tprivate validator: SchemaValidator | null = null\n\n\tprivate router = new Memoirist<ComposedHandler>()\n\tprivate wsRouter = new Memoirist<ComposedHandler>()\n\troutes: InternalRoute[] = []\n\n\tprivate staticRouter = {\n\t\thandlers: [] as ComposedHandler[],\n\t\tvariables: '',\n\t\tmap: {} as Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tcode: string\n\t\t\t\tall?: string\n\t\t\t}\n\t\t>,\n\t\tall: ''\n\t}\n\n\tprivate wsPaths: Record<string, number> = {}\n\tprivate dynamicRouter = new Memoirist<DynamicHandler>()\n\tprivate lazyLoadModules: Promise<Elysia<any, any>>[] = []\n\tpath: BasePath = '' as any\n\tstack: string | undefined = undefined\n\n\tconstructor(config?: Partial<ElysiaConfig<BasePath, Scoped>>) {\n\t\tthis.config = {\n\t\t\tforceErrorEncapsulation: true,\n\t\t\tprefix: '',\n\t\t\taot: true,\n\t\t\tstrictPath: false,\n\t\t\tscoped: false,\n\t\t\tcookie: {},\n\t\t\tanalytic: false,\n\t\t\t...config,\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t} as any\n\n\t\tif (config?.analytic && (config?.name || config?.seed !== undefined))\n\t\t\tthis.stack = new Error().stack\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpaths: string | Readonly<string[]>,\n\t\thandle: Handler<any, any, any> | any,\n\t\tlocalHook?: LocalHook<any, any, any, any, any>,\n\t\t{ allowMeta = false, skipPrefix = false } = {\n\t\t\tallowMeta: false as boolean | undefined,\n\t\t\tskipPrefix: false as boolean | undefined\n\t\t}\n\t) {\n\t\tif (typeof paths === 'string') paths = [paths]\n\n\t\tfor (let path of paths) {\n\t\t\tpath =\n\t\t\t\tpath === ''\n\t\t\t\t\t? path\n\t\t\t\t\t: path.charCodeAt(0) === 47\n\t\t\t\t\t? path\n\t\t\t\t\t: `/${path}`\n\n\t\t\tif (this.config.prefix && !skipPrefix)\n\t\t\t\tpath = this.config.prefix + path\n\n\t\t\tif (localHook?.type)\n\t\t\t\tswitch (localHook.type) {\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\tlocalHook.type = 'text/plain'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'json':\n\t\t\t\t\t\tlocalHook.type = 'application/json'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\t\tlocalHook.type = 'multipart/form-data'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\t\tlocalHook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\t\tlocalHook.type = 'application/octet-stream'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\tconst models = this.definitions.type as Record<string, TSchema>\n\n\t\t\tlet cookieValidator = getSchemaValidator(\n\t\t\t\tlocalHook?.cookie ?? (this.validator?.cookie as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels,\n\t\t\t\t\tadditionalProperties: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (isNotEmpty(this.config.cookie ?? {})) {\n\t\t\t\tif (cookieValidator) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcookieValidator.schema = mergeCookie(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\tthis.config.cookie ?? {}\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tcookieValidator = getSchemaValidator(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tt.Cookie({}, this.config.cookie),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst validator = {\n\t\t\t\tbody: getSchemaValidator(\n\t\t\t\t\tlocalHook?.body ?? (this.validator?.body as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\theaders: getSchemaValidator(\n\t\t\t\t\tlocalHook?.headers ?? (this.validator?.headers as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels,\n\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tparams: getSchemaValidator(\n\t\t\t\t\tlocalHook?.params ?? (this.validator?.params as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tquery: getSchemaValidator(\n\t\t\t\t\tlocalHook?.query ?? (this.validator?.query as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tcookie: cookieValidator,\n\t\t\t\tresponse: getResponseSchemaValidator(\n\t\t\t\t\tlocalHook?.response ?? (this.validator?.response as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t} as any\n\n\t\t\tconst globalHook = this.event\n\n\t\t\tconst loosePath = path.endsWith('/')\n\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t: path + '/'\n\n\t\t\tif (this.macros.length) {\n\t\t\t\tconst createManager =\n\t\t\t\t\t(stackName: keyof LifeCycleStore) =>\n\t\t\t\t\t(\n\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t| MaybeArray<Function>,\n\t\t\t\t\t\tfn?: MaybeArray<Function>\n\t\t\t\t\t) => {\n\t\t\t\t\t\tif (typeof type === 'function' || Array.isArray(type)) {\n\t\t\t\t\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\t\t\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\t\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\t\t\t\t\tif (Array.isArray(type))\n\t\t\t\t\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t\t\t\t\t).concat(type) as any\n\t\t\t\t\t\t\telse localHook[stackName].push(type)\n\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\t\t\t\t\tif (stack === 'global') {\n\t\t\t\t\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\t\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(\n\t\t\t\t\t\t\t\t\t\tfn\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t\t\t\t\t) as any\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t\t\t\t\t).concat(fn)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\t\t\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\t\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\t\t\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\t\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t\t\t\t\t;(localHook[stackName] as any[]).unshift(fn)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t;(localHook[stackName] as any[]).push(fn)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t\t\t\t\tlocalHook[stackName] = fn.concat(\n\t\t\t\t\t\t\t\t\t\tlocalHook[stackName]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlocalHook[stackName] =\n\t\t\t\t\t\t\t\t\t\tlocalHook[stackName].concat(fn)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tconst manager: MacroManager = {\n\t\t\t\t\tevents: {\n\t\t\t\t\t\tglobal: globalHook,\n\t\t\t\t\t\tlocal: localHook\n\t\t\t\t\t},\n\t\t\t\t\tonParse: createManager('parse'),\n\t\t\t\t\tonTransform: createManager('transform'),\n\t\t\t\t\tonBeforeHandle: createManager('beforeHandle'),\n\t\t\t\t\tonAfterHandle: createManager('afterHandle'),\n\t\t\t\t\tonResponse: createManager('onResponse'),\n\t\t\t\t\tonError: createManager('error')\n\t\t\t\t}\n\n\t\t\t\tfor (const macro of this.macros) {\n\t\t\t\t\tconst customHookValues: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\t\tlocalHook ?? {}\n\t\t\t\t\t)) {\n\t\t\t\t\t\tif (primitiveHooks.includes(key as any)) continue\n\n\t\t\t\t\t\tcustomHookValues[key] = value\n\t\t\t\t\t}\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (!macro.$elysiaChecksum)\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tmacro.$elysiaChecksum = []\n\n\t\t\t\t\tconst hash = checksum(JSON.stringify(customHookValues))\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (macro.$elysiaChecksum.includes(hash)) continue\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tmacro.$elysiaChecksum.push(\n\t\t\t\t\t\tchecksum(JSON.stringify(customHookValues))\n\t\t\t\t\t)\n\n\t\t\t\t\ttraceBackMacro(macro(manager), localHook as any)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst hooks = mergeHook(globalHook, localHook)\n\n\t\t\tconst isFn = typeof handle === 'function'\n\n\t\t\tif (this.config.aot === false) {\n\t\t\t\tthis.dynamicRouter.add(method, path, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle\n\t\t\t\t})\n\n\t\t\t\tif (this.config.strictPath === false) {\n\t\t\t\t\tthis.dynamicRouter.add(method, loosePath, {\n\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\t\thandle\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tthis.routes.push({\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\tcomposed: null,\n\t\t\t\t\thandler: handle,\n\t\t\t\t\thooks: hooks as any\n\t\t\t\t})\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst mainHandler = composeHandler({\n\t\t\t\tpath,\n\t\t\t\tmethod,\n\t\t\t\thooks,\n\t\t\t\tvalidator,\n\t\t\t\thandler: handle,\n\t\t\t\thandleError: this.handleError,\n\t\t\t\tonRequest: this.event.request,\n\t\t\t\tconfig: this.config,\n\t\t\t\tdefinitions: allowMeta ? this.definitions.type : undefined,\n\t\t\t\tschema: allowMeta ? this.schema : undefined,\n\t\t\t\tgetReporter: () => this.reporter,\n\t\t\t\tsetHeader: this.setHeaders\n\t\t\t})\n\n\t\t\t// @ts-ignore\n\t\t\tif (!isFn) {\n\t\t\t\tconst context = Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {},\n\t\t\t\t\t\tquery: {},\n\t\t\t\t\t\tparams: {} as never,\n\t\t\t\t\t\tbody: undefined,\n\t\t\t\t\t\trequest: new Request(`http://localhost${path}`),\n\t\t\t\t\t\tstore: this.store,\n\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\tset: {\n\t\t\t\t\t\t\theaders: this.setHeaders ?? {},\n\t\t\t\t\t\t\tstatus: 200\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tthis.decorators as any\n\t\t\t\t)\n\n\t\t\t\tlet response\n\n\t\t\t\tfor (const onRequest of Object.values(hooks.request)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst inner = mapEarlyResponse(\n\t\t\t\t\t\t\tonRequest(context),\n\t\t\t\t\t\t\tcontext.set\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (inner !== undefined) {\n\t\t\t\t\t\t\tresponse = inner\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tresponse = this.handleError(context, error as Error)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (response) mainHandler.response = response\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tmainHandler.response = mainHandler(context)\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tmainHandler.response = this.handleError(\n\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\terror as Error\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst existingRouteIndex = this.routes.findIndex(\n\t\t\t\t(route) => route.path === path && route.method === method\n\t\t\t)\n\n\t\t\tif (existingRouteIndex !== -1) {\n\t\t\t\t// remove route previously defined\n\t\t\t\tthis.routes.splice(existingRouteIndex, 1)\n\t\t\t}\n\n\t\t\tthis.routes.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: mainHandler,\n\t\t\t\thandler: handle,\n\t\t\t\thooks: hooks as any\n\t\t\t})\n\n\t\t\tif (method === '$INTERNALWS') {\n\t\t\t\tconst loose = this.config.strictPath\n\t\t\t\t\t? undefined\n\t\t\t\t\t: path.endsWith('/')\n\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t: path + '/'\n\n\t\t\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\t\t\tconst index = this.staticRouter.handlers.length\n\t\t\t\t\tthis.staticRouter.handlers.push(mainHandler)\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (mainHandler.response instanceof Response)\n\t\t\t\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response\\n`\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\\n`\n\n\t\t\t\t\tthis.wsPaths[path] = index\n\t\t\t\t\tif (loose) this.wsPaths[loose] = index\n\t\t\t\t} else {\n\t\t\t\t\tthis.wsRouter.add('ws', path, mainHandler)\n\t\t\t\t\tif (loose) this.wsRouter.add('ws', loose, mainHandler)\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\t\tconst index = this.staticRouter.handlers.length\n\t\t\t\tthis.staticRouter.handlers.push(mainHandler)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (mainHandler.response instanceof Response)\n\t\t\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response\\n`\n\t\t\t\telse\n\t\t\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\\n`\n\n\t\t\t\tif (!this.staticRouter.map[path])\n\t\t\t\t\tthis.staticRouter.map[path] = {\n\t\t\t\t\t\tcode: ''\n\t\t\t\t\t}\n\n\t\t\t\tif (method === 'ALL')\n\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\tpath\n\t\t\t\t\t].all = `default: return st${index}(ctx)\\n`\n\t\t\t\telse {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (mainHandler.response instanceof Response)\n\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t].code = `case '${method}': return st${index}.clone()\\n${this.staticRouter.map[path].code}`\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t].code = `case '${method}': return st${index}(ctx)\\n${this.staticRouter.map[path].code}`\n\t\t\t\t}\n\n\t\t\t\tif (!this.config.strictPath) {\n\t\t\t\t\tif (!this.staticRouter.map[loosePath])\n\t\t\t\t\t\tthis.staticRouter.map[loosePath] = {\n\t\t\t\t\t\t\tcode: ''\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif (method === 'ALL')\n\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\tloosePath\n\t\t\t\t\t\t].all = `default: return st${index}(ctx)\\n`\n\t\t\t\t\telse {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tif (mainHandler.response instanceof Response)\n\t\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\t\tloosePath\n\t\t\t\t\t\t\t].code = `case '${method}': return st${index}.clone()\\n${this.staticRouter.map[loosePath].code}`\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\t\tloosePath\n\t\t\t\t\t\t\t].code = `case '${method}': return st${index}(ctx)\\n${this.staticRouter.map[loosePath].code}`\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.router.add(method, path, mainHandler)\n\t\t\t\tif (!this.config.strictPath)\n\t\t\t\t\tthis.router.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath.endsWith('/')\n\t\t\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t\t\t: path + '/',\n\t\t\t\t\t\tmainHandler\n\t\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setHeaders?: Context['set']['headers']\n\theaders(header: Context['set']['headers'] | undefined) {\n\t\tif (!header) return this\n\n\t\tif (!this.setHeaders) this.setHeaders = {}\n\n\t\tthis.setHeaders = mergeDeep(this.setHeaders, header)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ url, port }) => {\n\t *         console.log(\"Running at ${url}:${port}\")\n\t *     })\n\t *     .listen(8080)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('request', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse(parser: MaybeArray<BodyHandler<ParentSchema, Decorators>>) {\n\t\tthis.on('parse', parser)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('transform', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<Resolver extends Object>(\n\t\tresolver: (\n\t\t\tcontext: Prettify<Context<ParentSchema, Decorators>>\n\t\t) => MaybePromise<Resolver> extends { store: any } ? never : Resolver\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: Decorators['store']\n\t\t\tderive: Decorators['resolve']\n\t\t\tresolve: Prettify<Decorators['resolve'] & Awaited<Resolver>>\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\t// @ts-ignore\n\t\tresolver.$elysia = 'resolve'\n\n\t\treturn this.onBeforeHandle(resolver as any) as any\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Intercept request **before(()) main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('beforeHandle', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('afterHandle', handler as AfterHandler<any, any>)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('mapResponse', handler as MapResponse<any, any>)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Called when handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\n\tonResponse<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tVoidHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('response', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<Route extends RouteSchema = {}>(\n\t\thandler: TraceHandler<Route, Decorators>\n\t) {\n\t\tthis.reporter.on(\n\t\t\t'event',\n\t\t\tcreateTraceListener(\n\t\t\t\t() => this.reporter,\n\t\t\t\tthis.event.trace.length,\n\t\t\t\thandler\n\t\t\t)\n\t\t)\n\n\t\tthis.on('trace', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): Elysia<any, any, any, any, any, any, any> {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code\n\n\t\t\t// @ts-ignore\n\t\t\tthis.definitions.error[code] = error\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<Schema extends RouteSchema = {}>(\n\t\thandler: ErrorHandler<\n\t\t\tDefinitions['error'],\n\t\t\tMergeSchema<Schema, ParentSchema>,\n\t\t\tDecorators\n\t\t>\n\t) {\n\t\tthis.on('error', handler as ErrorHandler<any, any, any>)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Exclude<Event, 'onResponse'> | 'response',\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t) {\n\t\tfor (let handler of Array.isArray(handlers) ? handlers : [handlers]) {\n\t\t\thandler = asGlobal(handler)\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse.splice(\n\t\t\t\t\t\tthis.event.parse.length - 1,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\thandler as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'mapResponse':\n\t\t\t\t\tthis.event.mapResponse.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'response':\n\t\t\t\t\tthis.event.onResponse.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop.push(handler as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\tgroup<\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any, any>,\n\t\tconst Prefix extends string\n\t>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tDecorators,\n\t\t\t\tDefinitions,\n\t\t\t\tParentSchema,\n\t\t\t\tMacro,\n\t\t\t\t{}\n\t\t\t>\n\t\t) => NewElysia\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tany,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tPluginDecorators,\n\t\t\t\tPluginDefinitions,\n\t\t\t\tPluginSchema,\n\t\t\t\tMacro,\n\t\t\t\tPrettify<Routes & NewElysia['schema']>\n\t\t  >\n\t\t: this\n\n\tgroup<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any, any>,\n\t\tconst Prefix extends string,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Prefix}`\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tDecorators,\n\t\t\t\tDefinitions,\n\t\t\t\tSchema,\n\t\t\t\tMacro,\n\t\t\t\t{}\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<Routes & NewElysia['schema']>\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun:\n\t\t\t| LocalHook<any, any, any, any, any>\n\t\t\t| ((\n\t\t\t\t\tgroup: Elysia<any, any, any, any, any, any, any>\n\t\t\t  ) => Elysia<any, any, any, any, any, any, any>),\n\t\trun?: (\n\t\t\tgroup: Elysia<any, any, any, any, any, any, any>\n\t\t) => Elysia<any, any, any, any, any, any, any>\n\t): this {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.store = this.store\n\t\tinstance.definitions = this.definitions\n\t\tinstance.getServer = () => this.server\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.decorators = mergeDeep(this.decorators, instance.decorators)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...this.event.request,\n\t\t\t\t...(sandbox.event.request as any)\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...this.event.onResponse,\n\t\t\t\t...(sandbox.event.onResponse as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.routes).forEach(\n\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as LocalHook<\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany\n\t\t\t\t\t>\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...localHook,\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [...localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t\t\t: [localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks as LocalHook<any, any, any, any, any>, {\n\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tBasePath\n\t\t>\n\t): Elysia<BasePath, Decorators, Definitions, Route, Macro, Routes, Scoped>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any, any>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tDecorators,\n\t\t\t\tDefinitions,\n\t\t\t\tSchema,\n\t\t\t\tMacro,\n\t\t\t\t{},\n\t\t\t\tScoped\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<Routes & NewElysia['schema']>\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook: LocalHook<any, any, any, any, any>,\n\t\trun?: (\n\t\t\tgroup: Elysia<any, any, any, any, any, any, any>\n\t\t) => Elysia<any, any, any, any, any, any, any>\n\t): Elysia<any, any, any, any, any, any, any> {\n\t\tif (!run) {\n\t\t\tthis.event = mergeLifeCycle(this.event, hook)\n\t\t\tthis.validator = {\n\t\t\t\tbody: hook.body,\n\t\t\t\theaders: hook.headers,\n\t\t\t\tparams: hook.params,\n\t\t\t\tquery: hook.query,\n\t\t\t\tresponse: hook.response\n\t\t\t}\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst instance = new Elysia<any>({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.store = this.store\n\t\tinstance.definitions = this.definitions\n\n\t\tconst sandbox = run(instance)\n\t\tthis.decorators = mergeDeep(this.decorators, instance.decorators)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...this.event.request,\n\t\t\t\t...sandbox.event.request\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...this.event.onResponse,\n\t\t\t\t...sandbox.event.onResponse\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.routes).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as LocalHook<any, any, any, any, any>, {\n\t\t\t\t\t\t...(localHook as LocalHook<any, any, any, any, any>),\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t? [...localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t\t: [localHook.error, ...sandbox.event.error]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t// Inline Fn\n\tuse<NewElysia extends Elysia<any, any, any, any, any, any, any> = this>(\n\t\tplugin: MaybePromise<(app: NewElysia) => MaybePromise<NewElysia>>\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tinfer PluginMacro,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\trequest: Prettify<\n\t\t\t\t\t\tDecorators['request'] & PluginDecorators['request']\n\t\t\t\t\t>\n\t\t\t\t\tstore: Prettify<\n\t\t\t\t\t\tDecorators['store'] & PluginDecorators['store']\n\t\t\t\t\t>\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tDecorators['derive'] & PluginDecorators['derive']\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tDecorators['resolve'] & PluginDecorators['resolve']\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: Prettify<\n\t\t\t\t\t\tDefinitions['type'] & PluginDefinitions['type']\n\t\t\t\t\t>\n\t\t\t\t\terror: Prettify<\n\t\t\t\t\t\tDefinitions['error'] & PluginDefinitions['error']\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tPrettify<MergeSchema<ParentSchema, PluginSchema>>,\n\t\t\t\tPrettify<Macro & PluginMacro>,\n\t\t\t\tRoutes & NewElysia['schema'],\n\t\t\t\tScoped\n\t\t  >\n\t\t: this\n\n\t// Entire Instance\n\tuse<NewElysia extends Elysia<any, any, any, any, any, any, any>>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tinfer PluginMacro,\n\t\tany,\n\t\tinfer IsScoped\n\t>\n\t\t? IsScoped extends true\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tDecorators,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tParentSchema,\n\t\t\t\t\tMacro,\n\t\t\t\t\tBasePath extends ``\n\t\t\t\t\t\t? Routes & NewElysia['schema']\n\t\t\t\t\t\t: Routes & AddPrefix<BasePath, NewElysia['schema']>,\n\t\t\t\t\tScoped\n\t\t\t  >\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\t{\n\t\t\t\t\t\trequest: Prettify<\n\t\t\t\t\t\t\tDecorators['request'] & PluginDecorators['request']\n\t\t\t\t\t\t>\n\t\t\t\t\t\tstore: Prettify<\n\t\t\t\t\t\t\tDecorators['store'] & PluginDecorators['store']\n\t\t\t\t\t\t>\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tDecorators['derive'] & PluginDecorators['derive']\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tDecorators['resolve'] & PluginDecorators['resolve']\n\t\t\t\t\t\t>\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: Prettify<\n\t\t\t\t\t\t\tDefinitions['type'] & PluginDefinitions['type']\n\t\t\t\t\t\t>\n\t\t\t\t\t\terror: Prettify<\n\t\t\t\t\t\t\tDefinitions['error'] & PluginDefinitions['error']\n\t\t\t\t\t\t>\n\t\t\t\t\t},\n\t\t\t\t\tPrettify<MergeSchema<ParentSchema, PluginSchema>>,\n\t\t\t\t\tPrettify<Macro & PluginMacro>,\n\t\t\t\t\tBasePath extends ``\n\t\t\t\t\t\t? Routes & NewElysia['schema']\n\t\t\t\t\t\t: Routes & AddPrefix<BasePath, NewElysia['schema']>,\n\t\t\t\t\tScoped\n\t\t\t  >\n\t\t: this\n\n\t// Import Fn\n\tuse<NewElysia extends Elysia<any, any, any, any, any, any, any>>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (\n\t\t\t\telysia: Elysia<any, any, any, any, any, any, any>\n\t\t\t) => MaybePromise<NewElysia>\n\t\t}>\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tinfer PluginMacro,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\trequest: Decorators['request'] & PluginDecorators['request']\n\t\t\t\t\tstore: Decorators['store'] & PluginDecorators['store']\n\t\t\t\t\tderive: Decorators['derive'] & PluginDecorators['derive']\n\t\t\t\t\tresolve: Decorators['resolve'] & PluginDecorators['resolve']\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: Definitions['type'] & PluginDefinitions['type']\n\t\t\t\t\terror: Definitions['error'] & PluginDefinitions['error']\n\t\t\t\t},\n\t\t\t\tMergeSchema<ParentSchema, PluginSchema>,\n\t\t\t\tPrettify<Macro & PluginMacro>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['schema']\n\t\t\t\t\t: Routes & AddPrefix<BasePath, NewElysia['schema']>,\n\t\t\t\tScoped\n\t\t  >\n\t\t: this\n\n\t// Import entire instance\n\tuse<LazyLoadElysia extends Elysia<any, any, any, any, any, any, any>>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): LazyLoadElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tinfer PluginMacro,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\trequest: PluginDecorators['request'] & Decorators['request']\n\t\t\t\t\tstore: PluginDecorators['store'] & Decorators['store']\n\t\t\t\t\tderive: Decorators['derive'] & PluginDecorators['derive']\n\t\t\t\t\tresolve: Decorators['resolve'] & PluginDecorators['resolve']\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: PluginDefinitions['type'] & Definitions['type']\n\n\t\t\t\t\terror: PluginDefinitions['error'] & Definitions['error']\n\t\t\t\t},\n\t\t\t\tMergeSchema<PluginSchema, ParentSchema>,\n\t\t\t\tPrettify<Macro & PluginMacro>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & LazyLoadElysia['schema']\n\t\t\t\t\t: Routes & AddPrefix<BasePath, LazyLoadElysia['schema']>\n\t\t  >\n\t\t: this\n\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| Elysia<any, any, any, any, any, any, any>\n\t\t\t| MaybePromise<\n\t\t\t\t\t(\n\t\t\t\t\t\tapp: Elysia<any, any, any, any, any, any, any>\n\t\t\t\t\t) => MaybePromise<Elysia<any, any, any, any, any, any, any>>\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault: Elysia<any, any, any, any, any, any, any>\n\t\t\t  }>\n\t\t\t| Promise<{\n\t\t\t\t\tdefault: (\n\t\t\t\t\t\telysia: Elysia<any, any, any, any, any, any, any>\n\t\t\t\t\t) => MaybePromise<Elysia<any, any, any, any, any, any, any>>\n\t\t\t  }>\n\t): Elysia<any, any, any, any, any, any, any> {\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.lazyLoadModules.push(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function') {\n\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t) as unknown as Elysia\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t})\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\n\t\t\treturn this as unknown as any\n\t\t} else return this._use(plugin)\n\n\t\treturn this\n\t}\n\n\tprivate _use(\n\t\tplugin:\n\t\t\t| Elysia<any, any, any, any, any, any, any>\n\t\t\t| ((\n\t\t\t\t\tapp: Elysia<any, any, any, any, any, any, any>\n\t\t\t  ) => MaybePromise<Elysia<any, any, any, any, any, any, any>>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.lazyLoadModules.push(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tthis.compile()\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks\n\t\t\t\t\t\t\t\t} of Object.values(plugin.routes)) {\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tmergeHook(\n\t\t\t\t\t\t\t\t\t\t\thooks as LocalHook<\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((x) => x.compile())\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tconst { name, seed } = plugin.config\n\n\t\tplugin.getServer = () => this.getServer()\n\t\tthis.headers(plugin.setHeaders)\n\n\t\tconst isScoped = plugin.config.scoped\n\t\tif (isScoped) {\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(\n\t\t\t\t\t!this.config?.analytic\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\t\tstack: plugin.stack,\n\t\t\t\t\t\t\t\troutes: plugin.routes,\n\t\t\t\t\t\t\t\tdecorators: plugin.decorators,\n\t\t\t\t\t\t\t\tstore: plugin.store,\n\t\t\t\t\t\t\t\ttype: plugin.definitions.type,\n\t\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\t\t.filter((x) => x.$elysia === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\t\t.filter((x) => x.$elysia === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t  }\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tplugin.model(this.definitions.type as any)\n\t\t\tplugin.error(this.definitions.error as any)\n\t\t\tplugin.macros = [...this.macros, ...plugin.macros]\n\n\t\t\tplugin.onRequest((context) => {\n\t\t\t\tObject.assign(context, this.decorators)\n\t\t\t\tObject.assign(context.store, this.store)\n\t\t\t})\n\n\t\t\tplugin.event.trace = [...this.event.trace, ...plugin.event.trace]\n\n\t\t\tif (plugin.config.aot) plugin.compile()\n\n\t\t\tconst instance = this.mount(plugin.fetch)\n\t\t\tthis.routes = this.routes.concat(instance.routes)\n\n\t\t\treturn this\n\t\t} else {\n\t\t\tplugin.reporter = this.reporter\n\t\t\tfor (const trace of plugin.event.trace) this.trace(trace)\n\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\t!this.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tthis.macros.push(...plugin.macros)\n\t\t\t}\n\t\t}\n\n\t\tthis.decorate(plugin.decorators)\n\t\tthis.state(plugin.store)\n\t\tthis.model(plugin.definitions.type)\n\t\tthis.error(plugin.definitions.error)\n\n\t\tfor (const { method, path, handler, hooks } of Object.values(\n\t\t\tplugin.routes\n\t\t)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tmergeHook(\n\t\t\t\t\thooks as LocalHook<any, any, any, any, any, any, any>,\n\t\t\t\t\t{\n\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tif (!isScoped)\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(\n\t\t\t\t\t!this.config?.analytic\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\t\tstack: plugin.stack,\n\t\t\t\t\t\t\t\troutes: plugin.routes,\n\t\t\t\t\t\t\t\tdecorators: plugin.decorators,\n\t\t\t\t\t\t\t\tstore: plugin.store,\n\t\t\t\t\t\t\t\ttype: plugin.definitions.type,\n\t\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\t\t.filter((x) => x?.$elysia === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\t\t.filter((x) => x?.$elysia === 'resolve')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t  }\n\t\t\t\t)\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\tcurrent\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t)\n\t\t\t}\n\n\t\treturn this\n\t}\n\n\tmacro<const NewMacro extends BaseMacro>(\n\t\tmacro: (\n\t\t\troute: MacroManager<Routes, Decorators, Definitions['error']>\n\t\t) => NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro & Partial<MacroToProperty<NewMacro>>,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\tthis.macros.push(macro as any)\n\n\t\treturn this as any\n\t}\n\n\tmount(\n\t\thandle:\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| Elysia<any, any, any, any, any, any, any>\n\t): this\n\tmount(\n\t\tpath: string,\n\t\thandle:\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| Elysia<any, any, any, any, any, any, any>\n\t): this\n\n\tmount(\n\t\tpath:\n\t\t\t| string\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| Elysia<any, any, any, any, any, any, any>,\n\t\thandle?:\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| Elysia<any, any, any, any, any, any, any>\n\t) {\n\t\tif (\n\t\t\tpath instanceof Elysia ||\n\t\t\ttypeof path === 'function' ||\n\t\t\tpath.length === 0 ||\n\t\t\tpath === '/'\n\t\t) {\n\t\t\tconst run =\n\t\t\t\ttypeof path === 'function'\n\t\t\t\t\t? path\n\t\t\t\t\t: path instanceof Elysia\n\t\t\t\t\t? path.compile().fetch\n\t\t\t\t\t: handle instanceof Elysia\n\t\t\t\t\t? handle.compile().fetch\n\t\t\t\t\t: handle!\n\n\t\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t\trun(\n\t\t\t\t\tnew Request(\n\t\t\t\t\t\treplaceUrlPath(request.url, path || '/'),\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t\tthis.all(\n\t\t\t\t'/',\n\t\t\t\thandler as any,\n\t\t\t\t{\n\t\t\t\t\ttype: 'none'\n\t\t\t\t} as any\n\t\t\t)\n\t\t\tthis.all(\n\t\t\t\t'/*',\n\t\t\t\thandler as any,\n\t\t\t\t{\n\t\t\t\t\ttype: 'none'\n\t\t\t\t} as any\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst length = path.length\n\n\t\tif (handle instanceof Elysia) handle = handle.compile().fetch\n\n\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t(handle as Function)!(\n\t\t\t\tnew Request(\n\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\trequest\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.all(\n\t\t\tpath,\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\tthis.all(\n\t\t\tpath + (path.endsWith('/') ? '*' : '/*'),\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [OPTIONS]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with any method\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\toptions: WS.LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: Route['response']\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tconst transform = options.transformMessage\n\t\t\t? Array.isArray(options.transformMessage)\n\t\t\t\t? options.transformMessage\n\t\t\t\t: [options.transformMessage]\n\t\t\t: undefined\n\n\t\tlet server: Server | null = null\n\n\t\tconst validateMessage = getSchemaValidator(options?.body, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>\n\t\t})\n\n\t\tconst validateResponse = getSchemaValidator(options?.response as any, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>\n\t\t})\n\n\t\tconst parseMessage = (message: any) => {\n\t\t\tif (typeof message === 'string') {\n\t\t\t\tconst start = message?.charCodeAt(0)\n\n\t\t\t\tif (start === 47 || start === 123)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Not empty\n\t\t\t\t\t}\n\t\t\t\telse if (isNumericString(message)) message = +message\n\t\t\t}\n\n\t\t\tif (transform?.length)\n\t\t\t\tfor (let i = 0; i < transform.length; i++) {\n\t\t\t\t\tconst temp = transform[i](message)\n\n\t\t\t\t\tif (temp !== undefined) message = temp\n\t\t\t\t}\n\n\t\t\treturn message\n\t\t}\n\n\t\tthis.route(\n\t\t\t'$INTERNALWS',\n\t\t\tpath as any,\n\t\t\t// @ts-ignore\n\t\t\t(context) => {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { set, path, qi, headers, query, params } = context\n\n\t\t\t\tif (server === null) server = this.getServer()\n\n\t\t\t\tif (\n\t\t\t\t\tserver?.upgrade<any>(context.request, {\n\t\t\t\t\t\theaders:\n\t\t\t\t\t\t\ttypeof options.upgrade === 'function'\n\t\t\t\t\t\t\t\t? options.upgrade(context as any as Context)\n\t\t\t\t\t\t\t\t: options.upgrade,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tvalidator: validateResponse,\n\t\t\t\t\t\t\topen(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.open?.(new ElysiaWS(ws, context as any))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: (ws: ServerWebSocket<any>, msg: any) => {\n\t\t\t\t\t\t\t\tconst message = parseMessage(msg)\n\n\t\t\t\t\t\t\t\tif (validateMessage?.Check(message) === false)\n\t\t\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t\t\tvalidateMessage,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t).message as string\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\toptions.message?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tmessage as any\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdrain(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.drain?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose(\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\tcode: number,\n\t\t\t\t\t\t\t\treason: string\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toptions.close?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\treason\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t\treturn\n\n\t\t\t\tset.status = 400\n\n\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t},\n\t\t\t{\n\t\t\t\tbeforeHandle: options.beforeHandle,\n\t\t\t\ttransform: options.transform,\n\t\t\t\theaders: options.headers,\n\t\t\t\tparams: options.params,\n\t\t\t\tquery: options.query\n\t\t\t} as any\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with custom method\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('CUSTOM', '/', () => 'hi')\n\t *     .route('CUSTOM', '/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Handle extends\n\t\t\t| Exclude<Route['response'], Handle>\n\t\t\t| Handler<Route, Decorators, `${BasePath}${Path}`>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\t{\n\t\t\tconfig,\n\t\t\t...hook\n\t\t}: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\t`${BasePath}${Path}`\n\t\t> & {\n\t\t\tconfig: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t}\n\t\t} = {\n\t\t\tconfig: {\n\t\t\t\tallowMeta: false\n\t\t\t}\n\t\t} as any\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\t[method in Lowercase<Method>]: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: undefined extends Route['params']\n\t\t\t\t\t\t\t? Path extends `${string}/${':' | '*'}${string}`\n\t\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tHandle extends (...a: any) => infer Returned\n\t\t\t\t\t\t\t\t\t\t? Returned\n\t\t\t\t\t\t\t\t\t\t: Handle\n\t\t\t\t\t\t\t  ) extends infer Res\n\t\t\t\t\t\t\t\t? keyof Res extends typeof ELYSIA_RESPONSE\n\t\t\t\t\t\t\t\t\t? Prettify<\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t200: Exclude<\n\t\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t} & (Extract<\n\t\t\t\t\t\t\t\t\t\t\t\tRes,\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t> extends infer ErrorResponse extends {\n\t\t\t\t\t\t\t\t\t\t\t\t[ELYSIA_RESPONSE]: number\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: any\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[status in ErrorResponse[typeof ELYSIA_RESPONSE]]: ErrorResponse['response']\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Res\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add(method, path, handler as any, hook, config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: Prettify<\n\t\t\t\tDecorators['store'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: Prettify<Decorators['store'] & Store>\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tstate<const NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Decorators['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: NewStore\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\tname: string | number | symbol | Record<string, unknown> | Function,\n\t\tvalue?: unknown\n\t) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tthis.store = mergeDeep(this.store, name)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tthis.store = name(this.store)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tif (!(name in this.store)) {\n\t\t\t// eslint-disable-next-line no-extra-semi\n\t\t\t;(this.store as Record<string | number | symbol, unknown>)[name] =\n\t\t\t\tvalue\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, const Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Prettify<\n\t\t\t\tDecorators['request'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Decorators['store']\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Prettify<Decorators['request'] & NewDecorators>\n\t\t\tstore: Decorators['store']\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Decorators['request']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: NewDecorators\n\t\t\tstore: Decorators['store']\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\tname: string | Record<string, unknown> | Function,\n\t\tvalue?: unknown\n\t) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tthis.decorators = mergeDeep(this.decorators, name)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tthis.decorators = name(this.decorators)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (!(name in this.decorators)) this.decorators[name] = value\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<Derivative extends Object>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<Context<ParentSchema, Decorators>>\n\t\t) => MaybePromise<Derivative> extends { store: any }\n\t\t\t? never\n\t\t\t: Derivative\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: Decorators['store']\n\t\t\tderive: Prettify<Decorators['derive'] & Awaited<Derivative>>\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\t// @ts-ignore\n\t\ttransform.$elysia = 'derive'\n\n\t\treturn this.onTransform(transform as any) as any\n\t}\n\n\tmodel<Name extends string, Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & { [name in Name]: Static<Model> }\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tmodel<Recorder extends Record<string, TSchema>>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & {\n\t\t\t\t\t[key in keyof Recorder]: Static<Recorder[key]>\n\t\t\t\t}\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (decorators: {\n\t\t\t[type in keyof Definitions['type']]: ReturnType<\n\t\t\t\ttypeof t.Unsafe<Definitions['type'][type]>\n\t\t\t>\n\t\t}) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tObject.entries(name).forEach(([key, value]) => {\n\t\t\t\t\tif (!(key in this.definitions.type))\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tthis.definitions.type[key] = value as TSchema\n\t\t\t\t})\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.type = name(this.definitions.type)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\n\t\treturn this as any\n\t}\n\n\tmapDerive<const NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Decorators['request']) => MaybePromise<NewStore>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: NewStore\n\t\t\tderive: Decorators['derive']\n\t\t\tresolve: Decorators['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\t// @ts-ignore\n\t\tmapper.$elysia = 'derive'\n\n\t\treturn this.onTransform(mapper as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Decorators['request']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Decorators['request']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Decorators['request']>\n\t\t\t\t: Decorators['request']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Decorators['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Decorators['store']>\n\t\t\t\t\t: AddSuffix<Word, Decorators['store']>\n\t\t\t\t: Decorators['store']\n\t\t\tderive: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Decorators['derive']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Decorators['derive']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Decorators['derive']>\n\t\t\t\t: Decorators['derive']\n\t\t\tresolve: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Decorators['resolve']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Decorators['resolve']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Decorators['resolve']>\n\t\t\t\t: Decorators['resolve']\n\t\t},\n\t\t{\n\t\t\ttype: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['type']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['type']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['type']>\n\t\t\t\t: Definitions['type']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tMacro,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t: (suffix: string, word: string) => word + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.decorators)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.decorators[key]\n\n\t\t\t\t\tthis.decorators = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.store[key]\n\n\t\t\t\t\tthis.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tthis.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this)\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload({\n\t\t\t\t...this.server,\n\t\t\t\tfetch: this.fetch\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Use handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> => {\n\t\tif (process.env.NODE_ENV === 'production')\n\t\t\tconsole.warn(\n\t\t\t\t\"Performance degradation found. Please call Elysia.compile() before using 'fetch'\"\n\t\t\t)\n\n\t\treturn (this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\t}\n\n\tprivate handleError = async (\n\t\tcontext: Context,\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) =>\n\t\t(this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\n\tprivate outerErrorHandler = (error: Error) =>\n\t\tnew Response(error.message || error.name || 'Error', {\n\t\t\t// @ts-ignore\n\t\t\tstatus: error?.status ?? 500\n\t\t})\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(8080)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tif (!Bun) throw new Error('Bun to run')\n\n\t\tthis.compile()\n\n\t\tif (typeof options === 'string') {\n\t\t\toptions = +options.trim()\n\n\t\t\tif (Number.isNaN(options))\n\t\t\t\tthrow new Error('Port must be a numeric value')\n\t\t}\n\n\t\tconst fetch = this.fetch\n\n\t\tconst serve =\n\t\t\ttypeof options === 'object'\n\t\t\t\t? ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t...this.config.serve,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...this.config.websocket,\n\t\t\t\t\t\t\t...websocket\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t  } as Serve)\n\t\t\t\t: ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t...this.config.serve,\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...this.config.websocket,\n\t\t\t\t\t\t\t...websocket\n\t\t\t\t\t\t},\n\t\t\t\t\t\tport: options,\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t  } as Serve)\n\n\t\tif (typeof Bun === 'undefined')\n\t\t\tthrow new Error(\n\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t)\n\n\t\tthis.server = Bun?.serve(serve)\n\n\t\tif (this.event.start.length)\n\t\t\tfor (let i = 0; i < this.event.start.length; i++)\n\t\t\t\tthis.event.start[i](this)\n\n\t\tif (callback) callback(this.server!)\n\n\t\tprocess.on('beforeExit', () => {\n\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\tthis.event.stop[i](this)\n\t\t})\n\n\t\tPromise.all(this.lazyLoadModules).then(() => {\n\t\t\tBun?.gc(false)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(8080)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t */\n\tstop = async () => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tthis.server.stop()\n\n\t\tif (this.event.stop.length)\n\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\tthis.event.stop[i](this)\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn Promise.all(this.lazyLoadModules)\n\t}\n}\n\nexport { Elysia }\n\nexport { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler'\nexport { t } from './type-system'\nexport { Cookie, type CookieOptions } from './cookie'\n\nexport {\n\tgetSchemaValidator,\n\tmergeDeep,\n\tmergeHook,\n\tmergeObjectArray,\n\tgetResponseSchemaValidator\n} from './utils'\n\nexport {\n\terror,\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature\n} from './error'\n\nexport type { Context, PreContext } from './context'\n\nexport type {\n\tElysiaConfig,\n\tDecoratorBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tErrorHandler,\n\tAfterHandler,\n\tLifeCycleEvent,\n\tTraceEvent,\n\tLifeCycleStore,\n\tMaybePromise,\n\tListenCallback,\n\tUnwrapSchema,\n\tTraceHandler,\n\tTraceProcess,\n\tTraceReporter,\n\tTraceStream,\n\tChecksum\n} from './types'\n\nexport type { Static, TSchema } from '@sinclair/typebox'\n"
  ],
  "mappings": "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AAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAI/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACjC,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACxC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAClC,EAAG,GAAI,GAAI,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AmB,CAAC,EAAEAC1iggggB9CGO,SAAS,EAAO,EAAG,CACtB,OAAO,IAAI,IAAI,EAAG,EAGf,SAAS,EAAK,EAAG,CACpB,OAAO,GAAI,MAAM,EAGd,SAAS,EAAM,CAAC,EAAQ,CAC3B,OAAO,GAAI,OAAO,CAAM,EAGrB,SAAS,EAAG,CAAC,EAAQ,CACxB,OAAO,GAAI,IAAI,CAAM,EAGlB,SAAS,EAAG,CAAC,EAAQ,EAAM,CAC9B,GAAI,IAAI,EAAQ,CAAI,EAGjB,SAAS,EAAG,CAAC,EAAQ,CACxB,OAAO,GAAI,IAAI,CAAM,EAvBzB,IAAM,GAAM,IAAIAChgggggBhBGO,SAAS,EAAO,EAAG,CACtB,OAAO,IAAI,IAAI,EAAG,EAGf,SAAS,EAAK,EAAG,CACpB,OAAO,GAAI,MAAM,EAGd,SAAS,EAAM,CAAC,EAAM,CACzB,OAAO,GAAI,OAAO,CAAI,EAGnB,SAAS,EAAG,CAAC,EAAM,CACtB,OAAO,GAAI,IAAI,CAAI,EAGhB,SAAS,EAAG,CAAC,EAAM,EAAM,CAC5B,GAAI,IAAI,EAAM,CAAI,EAGf,SAAS,EAAG,CAAC,EAAM,CACtB,OAAO,GAAI,IAAI,CAAI,EAvBvB,IAAM,GAAM,IAAIAChgggggBhBCO,IAAM,GAAgB,OAAO,IAAI,mBAAmB,EAE9C,GAAe,OAAO,IAAI,kBAAkB,EAE5C,GAAe,OAAO,IAAI,kBAAkB,EAE5C,GAAO,OAAO,IAAI,cAAc,EAEhC,EAAO,OAAO,IAAI,cAAcACxgggggB7CEO,SAAS,EAAM,CAAC,EAAU,CAAC,EAAG,CACjC,MAAO,IACA,GACF,GAAO,EAAQ,IAAS,QAC7BACrgggggBJCO,MAAM,UAAqB,KAAM,CACpC,WAAW,CAAC,EAAS,CACjB,MAAM,CAAO,EAErBACpgggggBAOO,MAAM,WAAoC,CAAa,CAC1D,WAAW,CAAC,EAAM,CACd,MAAM,wBAAwB,aAAgB,EAEtD,CACO,MAAM,WAAkC,CAAa,CACxD,WAAW,CAAC,EAAM,CACd,MAAM,4BAA4B,aAAgB,EAE1D,CAKO,IAAI,GACX,SAAU,CAAC,EAAY,CAEnB,SAAS,CAAI,CAAC,EAAM,EAAO,CACvB,GAAI,GAA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AU,CAAC,EACxC,IAAI,CAAC,IAAU,EAAQ,CAAK,CAAC,EAChD,EAAS,GAAS,EAAU,CAAI,EAChC,EAAQ,EAAM,CAAM,EAC1B,OAAO,GAAgB,CAAC,CAAK,EAAG,CAAO,GAGlC,WAAgB,CAAC,EAAO,EAAM,CACnC,cAAe,IAAU,SAAY,IAAS,eAAiB,GAAkB,CAAK,EAClF,IAAS,aAAe,GAAgB,CAAK,EACzC,IAAS,YAAc,GAAe,CAAK,EACvC,IAAS,YAAc,GAAe,CAAK,EACvC,EAAS,EAAM,SAAS,GAGnC,WAAQ,CAAC,EAAG,EAAG,CACpB,OAAO,EAAE,IAAI,KAAK,GAAU,EAAG,CAAC,CAAC,GAG9B,SAAS,EAAS,CAAC,EAAQ,EAAM,EAAU,CAAC,EAAG,CAElD,OAEA,GAAY,CAAM,EAAI,GAAuB,EAAQ,EAAM,CAAO,EAE9D,GAAkB,CAAM,EAAI,GAAoB,EAAQ,EAAM,CAAM,EAChE,EAAQ,CAAM,EAAI,EAAM,GAAS,EAAO,MAAO,CAAI,EAAG,CAAO,EACzD,GAAU,CAAM,EAAI,EAAQ,GAAiB,EAAO,MAAO,CAAI,EAAG,CAAO,EACrEAC3jggggBpBEO,SAAS,EAAU,CAAC,EAAG,EAAU,CAAC,EAAG,CACxC,OAAO,GAAU,EAAG,aAAc,CAAOAClgggggB7CEO,SAAS,EAAS,CAAC,EAAG,EAAU,CAAC,EAAG,CACvC,OAAO,GAAU,EAAG,YAAa,CAAOAClgggggB5CEO,SAAS,EAAY,CAAC,EAAG,EAAU,CAAC,EAAG,CAC1C,OAAO,GAAU,EAAG,eAAgB,CAAOAClgggggB/CEO,SAAS,EAAS,CAAC,EAAG,EAAU,CAAC,EAAG,CACvC,OAAO,GAAU,EAAG,YAAa,CAAOAClgggggB5CGO,SAAS,EAAG,CAAC,EAAQ,EAAS,CACjC,MAAO,IACA,GACF,GAAO,MACR,IAAK,EAAU,CAAM,CACzBACvgggggBJGA,IAAS,WAAc,CAAC,EAAG,EAAG,EAAS,CACnC,OAAO,WAAW,OAAO,oBAAoB,CAAC,EAAE,OAAO,CAAC,EAAK,IAAO,CAChE,MAAO,IAAK,GAAM,GAAK,GAAK,EAAE,GAAK,EAAG,CAAO,CAAE,GAChD,CAAC,C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",
  "debugId": "9A79793649744BA764756e2164756e21",
  "names": []
}