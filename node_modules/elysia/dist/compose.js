import{Value as e}from"@sinclair/typebox/value";import{parse as r}from"fast-querystring";import t from"fast-decode-uri-component";import{signCookie as s}from"./utils";import{mapEarlyResponse as n,mapResponse as o,mapCompactResponse as a,isNotEmpty as i}from"./handler";import{NotFoundError as c,ValidationError as f,InternalServerError as l,ERROR_CODE as u,ELYSIA_RESPONSE as p}from"./error";import{parseCookie as d}from"./cookie";let m=new Headers().toJSON,y=RegExp(" (\\w+) = context","g"),h={value:0},$=({hasTrace:e,hasTraceSet:r=!1,addFn:t,condition:s={}})=>e?(t(`
const reporter = getReporter()
`),(e,{name:n,attribute:o="",unit:a=0}={})=>{let i=e.indexOf("."),c=-1===i;if("request"!==e&&"response"!==e&&!s[c?e:e.slice(0,i)])return()=>{r&&"afterHandle"===e&&t(`
await traceDone
`)};c?n||=e:n||="anonymous",t("\n"+`reporter.emit('event', {
					id,
					event: '${e}',
					type: 'begin',
					name: '${n}',
					time: performance.now(),
					${c?`unit: ${a},`:""}
					${o}
				})`.replace(/(\t| |\n)/g,"")+"\n");let f=!1;return()=>{!f&&(f=!0,t("\n"+`reporter.emit('event', {
							id,
							event: '${e}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g,"")+"\n"),r&&"afterHandle"===e&&t(`
await traceDone
`))}}):()=>()=>{};export const hasReturn=e=>{let r=e.indexOf(")");return 61===e.charCodeAt(r+2)&&123!==e.charCodeAt(r+5)||e.includes("return")};let g=(e,{injectResponse:r=""}={})=>({composeValidation:(r,t=`c.${r}`)=>e?`c.set.status = 400; throw new ValidationError(
'${r}',
${r},
${t}
)`:`c.set.status = 400; return new ValidationError(
	'${r}',
	${r},
	${t}
).toResponse(c.set.headers)`,composeResponseValidation:(t="r")=>{let s=e?`throw new ValidationError(
'response',
response[c.set.status],
${t}
)`:`return new ValidationError(
'response',
response[c.set.status],
${t}
).toResponse(c.set.headers)`;return`
${r}
		if(!(${t} instanceof Response) && response[c.set.status]?.Check(${t}) === false) {
	if(!(response instanceof Error))
		${s}
}
`}});export const isFnUse=(e,r)=>{if(r.startsWith("[object "))return!1;r=(r=r.trimStart()).replaceAll(/^async /g,""),/^(\w+)\(/g.test(r)&&(r=r.slice(r.indexOf("(")));let t=40===r.charCodeAt(0)||r.startsWith("function")?r.slice(r.indexOf("(")+1,r.indexOf(")")):r.slice(0,r.indexOf("=")-1);if(""===t)return!1;let s=123===t.charCodeAt(0)?t.indexOf("..."):-1;if(123===t.charCodeAt(0)){if(t.includes(e))return!0;if(-1===s)return!1}if(r.match(RegExp(`${t}(.${e}|\\["${e}"\\])`)))return!0;let n=-1!==s?t.slice(s+3,t.indexOf(" ",s+3)):void 0;if(r.match(RegExp(`${n}(.${e}|\\["${e}"\\])`)))return!0;let o=[t];for(let e of(n&&o.push(n),r.matchAll(y)))o.push(e[1]);let a=RegExp(`{.*?} = (${o.join("|")})`,"g");for(let[t]of r.matchAll(a))if(t.includes(`{ ${e}`)||t.includes(`, ${e}`))return!0;return!1};let b=e=>{if((e=e.trimStart()).startsWith("[object"))return!1;e=e.replaceAll(/^async /g,""),/^(\w+)\(/g.test(e)&&(e=e.slice(e.indexOf("(")));let r=40===e.charCodeAt(0)||e.startsWith("function")?e.slice(e.indexOf("(")+1,e.indexOf(")")):e.slice(0,e.indexOf("=")-1);if(""===r)return!1;let t=123===r.charCodeAt(0)?r.indexOf("..."):-1,s=-1!==t?r.slice(t+3,r.indexOf(" ",t+3)):void 0,n=[r];for(let r of(s&&n.push(s),e.matchAll(y)))n.push(r[1]);for(let r of n)if(RegExp(`\\b\\w+\\([^)]*\\b${r}\\b[^)]*\\)`).test(e))return!0;let o=RegExp(`{.*?} = (${n.join("|")})`,"g");for(let[r]of e.matchAll(o))if(RegExp(`\\b\\w+\\([^)]*\\b${r}\\b[^)]*\\)`).test(e))return!0;return!1},k=Symbol.for("TypeBox.Kind");export const hasType=(e,r)=>{if(r){if(k in r&&r[k]===e)return!0;if("object"===r.type){let t=r.properties;for(let r of Object.keys(t)){let s=t[r];if("object"===s.type){if(hasType(e,s))return!0}else if(s.anyOf){for(let r=0;r<s.anyOf.length;r++)if(hasType(e,s.anyOf[r]))return!0}if(k in s&&s[k]===e)return!0}return!1}return r.properties&&k in r.properties&&r.properties[k]===e}};export const hasProperty=(e,r)=>{if(r){if("object"===r.type){let t=r.properties;if(!t)return!1;for(let r of Object.keys(t)){let s=t[r];if(e in s)return!0;if("object"===s.type){if(hasProperty(e,s))return!0}else if(s.anyOf){for(let r=0;r<s.anyOf.length;r++)if(hasProperty(e,s.anyOf[r]))return!0}}return!1}return e in r}};let R=Symbol.for("TypeBox.Transform");export const hasTransform=e=>{if(e){if("object"===e.type&&e.properties){let r=e.properties;for(let e of Object.keys(r)){let t=r[e];if("object"===t.type){if(hasTransform(t))return!0}else if(t.anyOf){for(let e=0;e<t.anyOf.length;e++)if(hasTransform(t.anyOf[e]))return!0}if(R in t)return!0}return!1}return R in e||e.properties&&R in e.properties}};let q=e=>{if(!e)return;let r=e?.schema;if(r&&"anyOf"in r){let e=!1,t=r.anyOf[0].type;for(let s of r.anyOf)if(s.type!==t){e=!0;break}if(!e)return t}return e.schema?.type},x=/(?:return|=>) \S+\(/g;export const isAsync=e=>{if("AsyncFunction"===e.constructor.name)return!0;let r=e.toString();return!r.includes("=> response.clone(")&&!!r.match(x)};let O=e=>{if(!e.includes("query: {")||e.includes("query,")||e.includes("query }"))return!1;let r=e.indexOf("query: {");return(e=(e=e.slice(r+9)).slice(0,e.indexOf("}"))).split(",").map(e=>{let r=e.indexOf(":");return -1===r?e.trim():e.slice(0,r).trim()})};export const composeHandler=({path:p,method:y,hooks:k,validator:R,handler:x,handleError:w,definitions:H,schema:E,onRequest:v,config:j,getReporter:A,setHeader:S})=>{let C=j.forceErrorEncapsulation||k.error.length>0||"undefined"==typeof Bun||k.onResponse.length>0||!!k.trace.length,F="function"==typeof x,T=F?"handler(c)":"handler",D=k.onResponse.length?`
;(async () => {${k.onResponse.map((e,r)=>`await res${r}(c)`).join(";")}})();
`:"",U=k.trace.map(e=>e.toString()),P=!1;if(F&&b(x.toString())&&(P=!0),!P){for(let[e,r]of Object.entries(k))if(Array.isArray(r)&&r.length&&["parse","transform","beforeHandle","afterHandle","onResponse"].includes(e)){for(let e of r)if("function"==typeof e&&b(e.toString())){P=!0;break}if(P)break}}let N={parse:U.some(e=>isFnUse("parse",e)),transform:U.some(e=>isFnUse("transform",e)),handle:U.some(e=>isFnUse("handle",e)),beforeHandle:U.some(e=>isFnUse("beforeHandle",e)),afterHandle:U.some(e=>isFnUse("afterHandle",e)),error:C||U.some(e=>isFnUse("error",e))},I=k.trace.length>0,V="",_=R||"GET"!==y&&"HEAD"!==y?[x,...k.transform,...k.beforeHandle,...k.afterHandle,...k.mapResponse].map(e=>"function"==typeof e?e.toString():`${e}`):[],L="GET"!==y&&"HEAD"!==y&&(P||"none"!==k.type&&(!!R.body||!!k.type||_.some(e=>isFnUse("body",e)))),M=P||R.headers||_.some(e=>isFnUse("headers",e))||S&&Object.keys(S).length,J=P||!!R.cookie||_.some(e=>isFnUse("cookie",e)),B=R?.cookie?.schema,W="";if(B?.sign){if(!B.secrets)throw Error(`t.Cookie required secret which is not set in (${y}) ${p}.`);let e=B.secrets?"string"==typeof B.secrets?B.secrets:B.secrets[0]:void 0;if(W+=`const _setCookie = c.set.cookie
		if(_setCookie) {`,!0===B.sign)W+=`for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${e}')
			}`;else for(let r of B.sign)W+=`if(_setCookie['${r}']?.value) { c.set.cookie['${r}'].value = await signCookie(_setCookie['${r}'].value, '${e}') }
`;W+="}\n"}let{composeValidation:Y,composeResponseValidation:G}=g(C);if(M&&(V+=m?`c.headers = c.request.headers.toJSON()
`:`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`),J){let e=(e,r)=>{let t=B?.[e]??r;return t?"string"==typeof t?`${e}: '${t}',`:t instanceof Date?`${e}: new Date(${t.getTime()}),`:`${e}: ${t},`:"string"==typeof r?`${e}: "${r}",`:`${e}: ${r},`},r=B?`{
			secret: ${void 0!==B.secrets?"string"==typeof B.secrets?`'${B.secrets}'`:"["+B.secrets.reduce((e,r)=>e+`'${r}',`,"")+"]":"undefined"},
			sign: ${!0===B.sign||(void 0!==B.sign?"["+B.sign.reduce((e,r)=>e+`'${r}',`,"")+"]":"undefined")},
			${e("domain")}
			${e("expires")}
			${e("httpOnly")}
			${e("maxAge")}
			${e("path","/")}
			${e("priority")}
			${e("sameSite")}
			${e("secure")}
		}`:"undefined";M?V+=`
c.cookie = await parseCookie(c.set, c.headers.cookie, ${r})
`:V+=`
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${r})
`}if(P||R.query||_.some(e=>isFnUse("query",e))){let e=[],r=!1;if(R.query&&"object"===R.query.schema.type)e=Object.keys(R.query.schema.properties);else for(let t of _){let s=O(t);if(!s){r=!0;continue}for(let r of s)-1===e.indexOf(r)&&e.push(r)}!r&&e.length?V+=`if(c.qi !== -1) {
				const url = decodeURIComponent(c.request.url.slice(c.qi + 1))
				let memory = 0

				${e.map((e,r)=>`
						memory = url.indexOf('${e}=')

						const a${r} = memory === -1 ? undefined : url.slice(memory = memory + ${e.length+1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join("\n")}

				c.query = {
					${e.map((e,r)=>`${e}: a${r}`).join(", ")}
				}
			} else {
				c.query = {}
			}`:V+="c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}"}let Q=k.trace.map(e=>e.toString()).some(e=>isFnUse("set",e)||b(e));P||k.trace.some(e=>isFnUse("set",e.toString()));let K=S&&Object.keys(S).length||Q||J||_.some(e=>isFnUse("set",e))||v.some(e=>isFnUse("set",e.toString()));I&&(V+="\nconst id = c.$$requestId\n");let z=$({hasTrace:I,hasTraceSet:Q,condition:N,addFn:e=>{V+=e}});if(V+=C?"\n try {\n":"",Q){V+=`
const traceDone = Promise.all([`;for(let e=0;e<k.trace.length;e++)V+=`new Promise(r => { reporter.once(\`res\${id}.${e}\`, r) }),`;V+=`])
`}let X="function"==typeof x&&isAsync(x),Z=J||L||Q||X||!!k.mapResponse.length||k.parse.length>0||k.afterHandle.some(isAsync)||k.beforeHandle.some(isAsync)||k.transform.some(isAsync),ee=z("parse",{unit:k.parse.length});if(L){let e=q(R?.body);if(k.type&&!Array.isArray(k.type)){if(k.type)switch(k.type){case"json":case"application/json":V+=`c.body = await c.request.json()
`;break;case"text":case"text/plain":V+=`c.body = await c.request.text()
`;break;case"urlencoded":case"application/x-www-form-urlencoded":V+=`c.body = parseQuery(await c.request.text())
`;break;case"arrayBuffer":case"application/octet-stream":V+=`c.body = await c.request.arrayBuffer()
`;break;case"formdata":case"multipart/form-data":V+=`c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`}k.parse.length&&(V+="}}")}else{let r=(()=>{if(k.parse.length&&e&&!Array.isArray(k.type)){let r=R?.body?.schema;if("object"===e&&(hasType("File",r)||hasType("Files",r)))return`c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`}})();if(r)V+=r;else{if(V+="\n"+(M?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')")+`
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`,k.parse.length){V+=`let used = false
`;let e=z("parse",{unit:k.parse.length});for(let e=0;e<k.parse.length;e++){let r=z("parse.unit",{name:k.parse[e].name}),t=`bo${e}`;0!==e&&(V+=`if(!used) {
`),V+=`let ${t} = parse[${e}](c, contentType)
if(${t} instanceof Promise) ${t} = await ${t}
if(${t} !== undefined) { c.body = ${t}; used = true }
`,r(),0!==e&&(V+="}")}e()}k.parse.length&&(V+="if (!used)"),V+=`
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}
}
`}}V+="\n"}if(ee(),k?.transform){let e=z("transform",{unit:k.transform.length});for(let e=0;e<k.transform.length;e++){let r=k.transform[e],t=z("transform.unit",{name:r.name});"derive"===r.$elysia?V+=isAsync(r)?`Object.assign(c, await transform[${e}](c));`:`Object.assign(c, transform[${e}](c));`:V+=isAsync(r)?`await transform[${e}](c);`:`transform[${e}](c);`,t()}e()}if(R){if(V+="\n",R.headers){if(hasProperty("default",R.headers.params))for(let[r,t]of Object.entries(e.Default(R.headers.schema,{}))){let e="object"==typeof t?JSON.stringify(t):`'${t}'`;e&&(V+=`c.headers['${r}'] ??= ${e}
`)}V+=`if(headers.Check(c.headers) === false) {
				${Y("headers")}
			}`,hasTransform(R.headers.schema)&&(V+=`
c.headers = headers.Decode(c.headers)
`)}if(R.params){if(hasProperty("default",R.params.schema))for(let[r,t]of Object.entries(e.Default(R.params.schema,{}))){let e="object"==typeof t?JSON.stringify(t):`'${t}'`;e&&(V+=`c.params['${r}'] ??= ${e}
`)}V+=`if(params.Check(c.params) === false) {
				${Y("params")}
			}`,hasTransform(R.params.schema)&&(V+=`
c.params = params.Decode(c.params)
`)}if(R.query){if(hasProperty("default",R.query.schema))for(let[r,t]of Object.entries(e.Default(R.query.schema,{}))){let e="object"==typeof t?JSON.stringify(t):`'${t}'`;e&&(V+=`c.query['${r}'] ??= ${e}
`)}V+=`if(query.Check(c.query) === false) {
				${Y("query")}
			}`,hasTransform(R.query.schema)&&(V+=`
c.query = query.Decode(Object.assign({}, c.query))
`)}if(R.body&&(hasProperty("default",R.body.schema)?V+=`if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(e.Default(R.body.schema,null)??{})}, c.body)

    				if(body.Check(c.query) === false) {
        				${Y("body")}
     			}
            }`:V+=`if(body.Check(c.body) === false) {
			${Y("body")}
		}`,hasTransform(R.body.schema)&&(V+=`
c.body = body.Decode(c.body)
`)),i(R.cookie?.schema.properties??{})){if(V+=`const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`,hasProperty("default",R.cookie.schema))for(let[r,t]of Object.entries(e.Default(R.cookie.schema,{})))V+=`cookieValue['${r}'] = ${"object"==typeof t?JSON.stringify(t):t}
`;V+=`if(cookie.Check(cookieValue) === false) {
				${Y("cookie","cookieValue")}
			}`,hasTransform(R.cookie.schema)&&(V+=`
c.cookie = params.Decode(c.cookie)
`)}}if(k?.beforeHandle){let e=z("beforeHandle",{unit:k.beforeHandle.length});for(let e=0;e<k.beforeHandle.length;e++){let r=k.beforeHandle[e],t=z("beforeHandle.unit",{name:r.name}),s=hasReturn(r.toString());if("resolve"===r.$elysia)V+=isAsync(r)?`Object.assign(c, await beforeHandle[${e}](c));`:`Object.assign(c, beforeHandle[${e}](c));`;else if(s){V+=isAsync(r)?`be = await beforeHandle[${e}](c);
`:`be = beforeHandle[${e}](c);
`,t(),V+=`if(be !== undefined) {
`;let s=z("afterHandle",{unit:k.transform.length});if(k.afterHandle){z("handle",{name:F?x.name:void 0})();for(let e=0;e<k.afterHandle.length;e++){let r=hasReturn(k.afterHandle[e].toString()),t=z("afterHandle.unit",{name:k.afterHandle[e].name});V+=`c.response = be
`,r?V+=(isAsync(k.afterHandle[e])?`af = await afterHandle[${e}](c)
`:`af = afterHandle[${e}](c)
`)+`if(af !== undefined) { c.response = be = af }
`:V+=isAsync(k.afterHandle[e])?`await afterHandle[${e}](c, be)
`:`afterHandle[${e}](c, be)
`,t()}}if(s(),R.response&&(V+=G("be")),k.mapResponse.length){V+="c.response = be";for(let e=0;e<k.mapResponse.length;e++)V+=`
if(mr === undefined) {
							mr = onMapResponse[${e}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`}V+=W+`return mapEarlyResponse(be, c.set)}
`}else V+=isAsync(r)?`await beforeHandle[${e}](c);
`:`beforeHandle[${e}](c);
`,t()}e()}if(k?.afterHandle.length){let e=z("handle",{name:F?x.name:void 0});k.afterHandle.length?V+=X?`let r = c.response = await ${T};
`:`let r = c.response = ${T};
`:V+=X?`let r = await ${T};
`:`let r = ${T};
`,e();let r=z("afterHandle",{unit:k.afterHandle.length});for(let e=0;e<k.afterHandle.length;e++){let t=hasReturn(k.afterHandle[e].toString()),s=z("afterHandle.unit",{name:k.afterHandle[e].name});t?(V+=isAsync(k.afterHandle[e])?`af = await afterHandle[${e}](c)
`:`af = afterHandle[${e}](c)
`,s(),R.response?(V+="if(af !== undefined) {",r(),V+=G("af")+"c.response = af }"):(V+="if(af !== undefined) {",r(),V+=`c.response = af}
`)):(V+=isAsync(k.afterHandle[e])?`await afterHandle[${e}](c)
`:`afterHandle[${e}](c)
`,s())}if(r(),V+=`r = c.response
`,R.response&&(V+=G()),V+=W,k.mapResponse.length)for(let e=0;e<k.mapResponse.length;e++)V+=`
mr = onMapResponse[${e}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;K?V+=`return mapResponse(r, c.set)
`:V+=`return mapCompactResponse(r)
`}else{let e=z("handle",{name:F?x.name:void 0});if(R.response||k.mapResponse.length){if(V+=X?`let r = await ${T};
`:`let r = ${T};
`,e(),R.response&&(V+=G()),z("afterHandle")(),k.mapResponse.length){V+="c.response = r";for(let e=0;e<k.mapResponse.length;e++)V+=`
if(mr === undefined) { 
						mr = onMapResponse[${e}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`}V+=W,x instanceof Response?V+=`return ${T}.clone()
`:K?V+=`return mapResponse(r, c.set)
`:V+=`return mapCompactResponse(r)
`}else if(N.handle||J){if(V+=X?`let r = await ${T};
`:`let r = ${T};
`,e(),z("afterHandle")(),k.mapResponse.length){V+="c.response = r";for(let e=0;e<k.mapResponse.length;e++)V+=`
if(mr === undefined) {
							mr = onMapResponse[${e}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`}V+=W,K?V+=`return mapResponse(r, c.set)
`:V+=`return mapCompactResponse(r)
`}else{e();let r=X?`await ${T}`:T;z("afterHandle")(),x instanceof Response?V+=`return ${T}.clone()
`:K?V+=`return mapResponse(${r}, c.set)
`:V+=`return mapCompactResponse(${r})
`}}if(C||D){V+=`
} catch(error) {`,Z||(V+="return (async () => {"),V+=`const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;let e=z("error",{unit:k.error.length});if(k.error.length){V+=`
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;for(let e=0;e<k.error.length;e++){let r=`er${e}`,t=z("error.unit",{name:k.error[e].name});V+=`
let ${r} = handleErrors[${e}](c)
`,isAsync(k.error[e])&&(V+=`if (${r} instanceof Promise) ${r} = await ${r}
`),t(),V+=`${r} = mapEarlyResponse(${r}, set)
if (${r}) {return ${r} }
`}}if(e(),V+=`return handleError(c, error)

`,Z||(V+="})()"),V+="}",D||I){V+=" finally { ";let e=z("response",{unit:k.onResponse.length});V+=D,e(),V+="}"}}return Function("hooks",V=`const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${k.onResponse.length?`const ${k.onResponse.map((e,r)=>`res${r} = onResponse[${r}]`).join(",")}`:""}

	return ${Z?"async":""} function handle(c) {
		${k.beforeHandle.length?"let be":""}
		${k.afterHandle.length?"let af":""}
		${k.mapResponse.length?"let mr":""}

		${E&&H?"c.schema = schema; c.defs = definitions;":""}
		${V}
	}`)({handler:x,hooks:k,validator:R,handleError:w,utils:{mapResponse:o,mapCompactResponse:a,mapEarlyResponse:n,parseQuery:r},error:{NotFoundError:c,ValidationError:f,InternalServerError:l},schema:E,definitions:H,ERROR_CODE:u,getReporter:A,requestId:h,parseCookie:d,signCookie:s,decodeURIComponent:t})};export const composeGeneralHandler=e=>{let r="",t="";for(let t of Object.keys(e.decorators))r+=`,${t}: app.decorators.${t}`;let{router:s,staticRouter:o}=e,a=e.event.trace.length>0,i=`
	const route = router.find(request.method, path) ${s.root.ALL?'?? router.find("ALL", path)':""}
	if (route === null)
		return ${e.event.error.length?"app.handleError(ctx, notFound)":e.event.request.length?`new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`:"error404.clone()"}

	ctx.params = route.params

	return route.store(ctx)`,f="";for(let[e,{code:r,all:t}]of Object.entries(o.map))f+=`case '${e}':
switch(request.method) {
${r}
${t??"default: break map"}}

`;let l=e.event.request.some(isAsync);t+=`const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${e.event.request.length?"const onRequest = app.event.request":""}
	${o.variables}
	${e.event.error.length?"":`
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${l?"async":""} function map(request) {
`,e.event.request.length&&(t+="let re");let u=e.event.trace.map(e=>e.toString()),p=$({hasTrace:a,hasTraceSet:e.event.trace.some(e=>{let r=e.toString();return isFnUse("set",r)||b(r)}),condition:{request:u.some(e=>isFnUse("request",e)||b(e))},addFn:e=>{t+=e}});if(e.event.request.length){t+=`
			${a?"const id = +requestId.value++":""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys(e.setHeaders??{}).length?"Object.assign({}, app.setHeaders)":"{}"},
					status: 200
				}
				${a?",$$requestId: +id":""}
				${r}
			}
		`;let s=p("request",{attribute:"ctx",unit:e.event.request.length});t+=`
 try {
`;for(let r=0;r<e.event.request.length;r++){let s=e.event.request[r],n=hasReturn(s.toString()),o=isAsync(s),a=p("request.unit",{name:e.event.request[r].name});n?(t+=`re = mapEarlyResponse(
					${o?"await":""} onRequest[${r}](ctx),
					ctx.set
				)
`,a(),n&&(t+=`if(re !== undefined) return re
`)):(t+=`${o?"await":""} onRequest[${r}](ctx)
`,a())}t+=`} catch (error) {
			return app.handleError(ctx, error)
		}`,s(),t+=`
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`}else t+=`
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${a?"const id = +requestId.value++":""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys(e.setHeaders??{}).length?"Object.assign({}, app.setHeaders)":"{}"},
				status: 200
			}
			${a?",$$requestId: id":""}
			${r}
		}`,p("request",{unit:e.event.request.length,attribute:u.some(e=>isFnUse("context",e))||u.some(e=>isFnUse("store",e))||u.some(e=>isFnUse("set",e))?"ctx":""})();let d=e.wsPaths,m=e.wsRouter;if(Object.keys(d).length||m.history.length){for(let[e,r]of(t+=`
			if(request.method === 'GET') {
				switch(path) {`,Object.entries(d)))t+=`
					case '${e}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${r}(ctx)

						break`;t+=`
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`}t+=`
		map: switch(path) {
			${f}

			default:
				break
		}

		${i}
	}`;let y=composeErrorHandler(e);return e.handleError=y,Function("data",t)({app:e,mapEarlyResponse:n,NotFoundError:c,getReporter:()=>e.reporter,requestId:h,handleError:y})};export const composeErrorHandler=e=>{let r=`const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${e.event.error.find(isAsync)?"async":""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;for(let t=0;t<e.event.error.length;t++){let s=e.event.error[t],n=`${isAsync(s)?"await ":""}onError[${t}](context)`;hasReturn(s.toString())?r+=`r = ${n}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}
`:r+=n+"\n"}return Function("inject",r+=`if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`)({app:e,mapResponse:o,ERROR_CODE:u,ELYSIA_RESPONSE:p})};